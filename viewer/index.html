<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://jia.je/unofficial-loongarch-intrinsics-guide/viewer/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Browse All Intrinsics - Unofficial LoongArch Intrinsics Guide</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../main.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Browse All Intrinsics";
        var mkdocs_page_input_path = "viewer.md";
        var mkdocs_page_url = "/unofficial-loongarch-intrinsics-guide/viewer/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
 <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }</style> <script src="../assets/javascripts/glightbox.min.js"></script></head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Unofficial LoongArch Intrinsics Guide
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Unofficial LoongArch Intrinsics Guide</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../latency_throughput/">Latency and Throughput of Instructions</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../migrating_avx/">Migrating from AVX to LASX</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../migrating_sse/">Migrating from SSE to LSX</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Browse All Intrinsics</a>
    <ul class="current">
    </ul>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Lasx</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/bitwise_operations/">Bitwise Operations</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/branch/">Branch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/float_comparison/">Floating Point Comparison</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/float_computation/">Floating Point Computation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/float_conversion/">Floating Point Conversion</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/float_misc/">Floating Point Misc</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/fma/">Fused Multiply-Add</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/integer_comparison/">Integer Comparison</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/integer_computation/">Integer Computation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/logical/">Logical</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/memory/">Memory Load & Store</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/misc/">Misc</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/permutation/">Permutation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/shift/">Shift</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/shuffling/">Shuffling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lasx/undocumented/">Undocumented Intrinsics</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Lsx</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/bitwise_operations/">Bitwise Operations</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/branch/">Branch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/float_comparison/">Floating Point Comparison</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/float_computation/">Floating Point Computation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/float_conversion/">Floating Point Conversion</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/float_misc/">Floating Point Misc</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/fma/">Fused Multiply-Add</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/integer_comparison/">Integer Comparison</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/integer_computation/">Integer Computation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/logical/">Logical</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/memory/">Memory Load & Store</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/misc/">Misc</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/permutation/">Permutation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/shift/">Shift</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/shuffling/">Shuffling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lsx/undocumented/">Undocumented Intrinsics</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Unofficial LoongArch Intrinsics Guide</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Browse All Intrinsics</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="browse-all-intrinsics">Browse All Intrinsics</h1>
<div id="app">

<div v-if="false">
  Loading... Please wait...
  <p></p>
</div>

<div v-cloak>

<b style="padding-top: 10px">Categories:</b>
<p></p>

<div v-for="group in allGroups">
  <input type="checkbox" :id="group" :value="group" v-model="groups" />
  <label :for="group" style="display: inline">{{ group }}</label>
</div>

<p></p>
<b style="padding-top: 10px">Instruction Set Extensions:</b>
<p></p>

<div v-for="extension in allExtensions">
  <input type="checkbox" :id="extension" :value="extension" v-model="extensions" />
  <label :for="extension" style="display: inline">{{ extension }}</label>
</div>

<p></p>
<b>Filter by content:</b>
<p></p>

<input v-model="search" placeholder="Search intrinsics using MiniSearch search syntax" style="width: 100%">

<p></p>
<p></p>

Found {{intrinsics.length}} intrinsics.

<p></p>
<p></p>
<p></p>
<details v-for="intrinsic in intrinsics.inner" v-show="intrinsic.display" style="margin-top: 5px;padding-left: 5px;border-top: 1px solid black;border-left: 5px solid black">
  <summary>{{ intrinsic.name }}</summary>
  <div v-html="intrinsic.content" style="padding: 10px"></div>
</details>

<p></p>
<p></p>

</div>
</div>

<script type="module">
  import { createApp, ref, computed, nextTick } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js';
  import MiniSearch from 'https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/es/index.js';

  const allIntrinsics =  [{"name": "__m128 __lsx_vfadd_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfadd_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfadd.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd single precision floating point elements in `a` to elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp32[i] + b.fp32[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfadd_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfadd.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add single precision floating point elements in <code>a</code> to elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp32[i] + b.fp32[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfcvt_s_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfcvt_s_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcvt.s.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double precision floating point elements in `a` and `b` to single precision.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.fp32[i] = b.fp64[i];\n}\nfor (; i < 4; i++) {\n  dst.fp32[i] = a.fp64[i - 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = b.fp64[0];\n  dst.fp32[1] = b.fp64[1];\n  dst.fp32[2] = a.fp64[0];\n  dst.fp32[3] = a.fp64[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfcvt_s_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcvt.s.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double precision floating point elements in <code>a</code> and <code>b</code> to single precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.fp32[i] = b.fp64[i];\n}\nfor (; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp64[i - 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = b.fp64[0];\n  dst.fp32[1] = b.fp64[1];\n  dst.fp32[2] = a.fp64[0];\n  dst.fp32[3] = a.fp64[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfcvth_s_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfcvth_s_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vfcvth.s.h vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert half precision floating point elements in higher half of `a` to single precision.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp16[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = a.fp16[4];\n  dst.fp32[1] = a.fp16[5];\n  dst.fp32[2] = a.fp16[6];\n  dst.fp32[3] = a.fp16[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfcvth_s_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcvth.s.h vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert half precision floating point elements in higher half of <code>a</code> to single precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp16[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = a.fp16[4];\n  dst.fp32[1] = a.fp16[5];\n  dst.fp32[2] = a.fp16[6];\n  dst.fp32[3] = a.fp16[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfcvtl_s_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfcvtl_s_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vfcvtl.s.h vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert half precision floating point elements in lower half of `a` to single precision.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp16[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = a.fp16[0];\n  dst.fp32[1] = a.fp16[1];\n  dst.fp32[2] = a.fp16[2];\n  dst.fp32[3] = a.fp16[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfcvtl_s_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcvtl.s.h vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert half precision floating point elements in lower half of <code>a</code> to single precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp16[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = a.fp16[0];\n  dst.fp32[1] = a.fp16[1];\n  dst.fp32[2] = a.fp16[2];\n  dst.fp32[3] = a.fp16[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfdiv_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfdiv_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfdiv.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide single precision floating point elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp32[i] / b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 19.5 | 0.13(1/7.5) |\n| 3A6000 | LA664 | 11 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11 | 0.22(1/4.5) |\n| 2K1000LA | LA264 | 12, 28 | 0.04(1/28) |\n| 2K3000 | LA364E | 12, 28 | 0.04(1/28) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfdiv_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfdiv.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide single precision floating point elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp32[i] / b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 19.5</td>\n<td>0.13(1/7.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.22(1/4.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>12, 28</td>\n<td>0.04(1/28)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>12, 28</td>\n<td>0.04(1/28)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vffint_s_l (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vffint_s_l (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vffint.s.l vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert 64-bit integer elements in `a` and `b` to single-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] =\n      (i < 2) ? (f32)(s32)a.dword[i]\n              : (f32)(s32)b.dword[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vffint_s_l (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vffint.s.l vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert 64-bit integer elements in <code>a</code> and <code>b</code> to single-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] =\n      (i &lt; 2) ? (f32)(s32)a.dword[i]\n              : (f32)(s32)b.dword[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vffint_s_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vffint_s_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vffint.s.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert signed 32-bit integer elements in `a` to single-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (f32)(s32)a.word[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vffint_s_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vffint.s.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert signed 32-bit integer elements in <code>a</code> to single-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (f32)(s32)a.word[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vffint_s_wu (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vffint_s_wu (__m128i a)\n#include <lsxintrin.h>\nInstruction: vffint.s.wu vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert unsigned 32-bit integer elements in `a` to single-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (f32)(u32)a.word[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vffint_s_wu (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vffint.s.wu vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert unsigned 32-bit integer elements in <code>a</code> to single-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (f32)(u32)a.word[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vflogb_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vflogb_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vflogb.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute 2-based logarithm of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = log2(a.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vflogb_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vflogb.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute 2-based logarithm of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = log2(a.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfmadd_s (__m128 a, __m128 b, __m128 c)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfmadd_s (__m128 a, __m128 b, __m128 c)\n#include <lsxintrin.h>\nInstruction: vfmadd.s vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, accumulate to elements in `c` and store the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i] + c.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfmadd_s (__m128 a, __m128 b, __m128 c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmadd.s vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, accumulate to elements in <code>c</code> and store the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i] + c.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfmax_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfmax_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfmax.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute maximum of single precision floating point elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = fmax(a.fp32[i], b.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfmax_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmax.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute maximum of single precision floating point elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = fmax(a.fp32[i], b.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfmaxa_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfmaxa_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfmaxa.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute maximum of single precision floating point elements in `a` and `b` by magnitude.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (abs(a.fp32[i]) > abs(b.fp32[i])) ? a.fp32[i] : b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfmaxa_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmaxa.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute maximum of single precision floating point elements in <code>a</code> and <code>b</code> by magnitude.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (abs(a.fp32[i]) &gt; abs(b.fp32[i])) ? a.fp32[i] : b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfmin_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfmin_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfmin.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute minimum of single precision floating point elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = fmin(a.fp32[i], b.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfmin_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmin.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute minimum of single precision floating point elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = fmin(a.fp32[i], b.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfmina_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfmina_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfmina.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute minimum of single precision floating point elements in `a` and `b` by magnitude.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (abs(a.fp32[i]) < abs(b.fp32[i])) ? a.fp32[i] : b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfmina_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmina.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute minimum of single precision floating point elements in <code>a</code> and <code>b</code> by magnitude.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (abs(a.fp32[i]) &lt; abs(b.fp32[i])) ? a.fp32[i] : b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfmsub_s (__m128 a, __m128 b, __m128 c)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfmsub_s (__m128 a, __m128 b, __m128 c)\n#include <lsxintrin.h>\nInstruction: vfmsub.s vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, subtract elements in `c` and store the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i] - c.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfmsub_s (__m128 a, __m128 b, __m128 c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmsub.s vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, subtract elements in <code>c</code> and store the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i] - c.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfmul_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfmul_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfmul.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply single precision floating point elements in `a` and elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfmul_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmul.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply single precision floating point elements in <code>a</code> and elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfnmadd_s (__m128 a, __m128 b, __m128 c)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfnmadd_s (__m128 a, __m128 b, __m128 c)\n#include <lsxintrin.h>\nInstruction: vfnmadd.s vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, accumulate to elements in `c` and store the negated result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = -(a.fp32[i] * b.fp32[i] + c.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfnmadd_s (__m128 a, __m128 b, __m128 c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfnmadd.s vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, accumulate to elements in <code>c</code> and store the negated result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = -(a.fp32[i] * b.fp32[i] + c.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfnmsub_s (__m128 a, __m128 b, __m128 c)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfnmsub_s (__m128 a, __m128 b, __m128 c)\n#include <lsxintrin.h>\nInstruction: vfnmsub.s vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, subtract elements in `c` and store the negated result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = -(a.fp32[i] * b.fp32[i] - c.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfnmsub_s (__m128 a, __m128 b, __m128 c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfnmsub.s vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, subtract elements in <code>c</code> and store the negated result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = -(a.fp32[i] * b.fp32[i] - c.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrecip_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrecip_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrecip.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute reciprocal of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = 1 / a.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 27 | 0.14(1/7) |\n| 3A6000 | LA664 | 11 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 27 | 0.12(1/8.5) |\n| 2K1000LA | LA264 | 28 | 0.04(1/28) |\n| 2K3000 | LA364E | 28 | 0.04(1/28) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrecip_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrecip.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute reciprocal of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = 1 / a.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>27</td>\n<td>0.14(1/7)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>27</td>\n<td>0.12(1/8.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>28</td>\n<td>0.04(1/28)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>28</td>\n<td>0.04(1/28)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrecipe_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrecipe_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrecipe.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute estimated reciprocal of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = 1 / a.fp32[i]; // estimated\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrecipe_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrecipe.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute estimated reciprocal of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = 1 / a.fp32[i]; // estimated\n}\n</code></pre>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrint_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrint_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrint.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, using current rounding mode specified in `fscr`, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrint_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrint.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, using current rounding mode specified in <code>fscr</code>, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrintrm_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrintrm_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrintrm.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards negative infinity, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrintrm_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrintrm.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards negative infinity, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrintrne_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrintrne_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrintrne.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards nearest even, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrintrne_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrintrne.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards nearest even, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrintrp_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrintrp_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrintrp.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards positive infinity, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrintrp_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrintrp.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards positive infinity, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrintrz_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrintrz_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrintrz.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards zero, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrintrz_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrintrz.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards zero, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrsqrt_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrsqrt_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrsqrt.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute reciprocal of square root of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = 1.0 / sqrt(a.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 21 | 0.11(1/9) |\n| 3A6000 | LA664 | 17 | 0.05(1/19) |\n| 3C6000 | LA664 | 21 | 0.11(1/9.5) |\n| 2K1000LA | LA264 | 26 | 0(1/62) |\n| 2K3000 | LA364E | 26 | 0(1/62) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrsqrt_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrsqrt.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute reciprocal of square root of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = 1.0 / sqrt(a.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>21</td>\n<td>0.11(1/9)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17</td>\n<td>0.05(1/19)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>21</td>\n<td>0.11(1/9.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>26</td>\n<td>0(1/62)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>26</td>\n<td>0(1/62)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfrsqrte_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfrsqrte_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfrsqrte.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute estimated reciprocal of square root of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = 1.0 / sqrt(a.fp32[i]); // estimated\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfrsqrte_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrsqrte.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute estimated reciprocal of square root of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = 1.0 / sqrt(a.fp32[i]); // estimated\n}\n</code></pre>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfscaleb_s (__m128 a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfscaleb_s (__m128 a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vfscaleb.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute IEEE754 scaleB of single precision floating point elements in `a` by integer elements in `b`. Currently undocumented.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = __builtin_scalbn(a.fp32[i], b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfscaleb_s (__m128 a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfscaleb.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute IEEE754 scaleB of single precision floating point elements in <code>a</code> by integer elements in <code>b</code>. Currently undocumented.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = __builtin_scalbn(a.fp32[i], b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Undocumented Intrinsics", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfsqrt_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfsqrt_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfsqrt.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute square root of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = sqrt(a.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 27 | 0.17(1/6) |\n| 3A6000 | LA664 | 11 | 0.08(1/12) |\n| 3C6000 | LA664 | 25 | 0.09(1/11.5) |\n| 2K1000LA | LA264 | 16 | 0.03(1/40) |\n| 2K3000 | LA364E | 28 | 0.03(1/40) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfsqrt_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfsqrt.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute square root of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = sqrt(a.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>27</td>\n<td>0.17(1/6)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.08(1/12)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>25</td>\n<td>0.09(1/11.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>16</td>\n<td>0.03(1/40)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>28</td>\n<td>0.03(1/40)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128 __lsx_vfsub_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128 __lsx_vfsub_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfsub.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract single precision floating point elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp32[i] - b.fp32[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128 __lsx_vfsub_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfsub.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract single precision floating point elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp32[i] - b.fp32[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfadd_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfadd_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfadd.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd double precision floating point elements in `a` to elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp64[i] + b.fp64[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfadd_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfadd.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add double precision floating point elements in <code>a</code> to elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp64[i] + b.fp64[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfcvth_d_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfcvth_d_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfcvth.d.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single precision floating point elements in higher half of `a` to double precision.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp32[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = a.fp32[2];\n  dst.fp64[1] = a.fp32[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfcvth_d_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcvth.d.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single precision floating point elements in higher half of <code>a</code> to double precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp32[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = a.fp32[2];\n  dst.fp64[1] = a.fp32[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfcvtl_d_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfcvtl_d_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfcvtl.d.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single precision floating point elements in lower half of `a` to double precision.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp32[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = a.fp32[0];\n  dst.fp64[1] = a.fp32[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfcvtl_d_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcvtl.d.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single precision floating point elements in lower half of <code>a</code> to double precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp32[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = a.fp32[0];\n  dst.fp64[1] = a.fp32[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfdiv_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfdiv_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfdiv.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide double precision floating point elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp64[i] / b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 16.5 | 0.08(1/12.5) |\n| 3A6000 | LA664 | 8, 21.5 | 0.25(1/4) |\n| 3C6000 | LA664 | 8, 16.5 | 0.33(1/3) |\n| 2K1000LA | LA264 | 9, 24 | 0.04(1/24) |\n| 2K3000 | LA364E | 9, 24 | 0.04(1/24) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfdiv_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfdiv.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide double precision floating point elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp64[i] / b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 16.5</td>\n<td>0.08(1/12.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8, 21.5</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8, 16.5</td>\n<td>0.33(1/3)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>9, 24</td>\n<td>0.04(1/24)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>9, 24</td>\n<td>0.04(1/24)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vffint_d_l (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vffint_d_l (__m128i a)\n#include <lsxintrin.h>\nInstruction: vffint.d.l vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert signed 64-bit integer elements in `a` to double-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (f64)(s64)a.dword[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vffint_d_l (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vffint.d.l vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert signed 64-bit integer elements in <code>a</code> to double-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (f64)(s64)a.dword[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vffint_d_lu (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vffint_d_lu (__m128i a)\n#include <lsxintrin.h>\nInstruction: vffint.d.lu vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert unsigned 64-bit integer elements in `a` to double-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (f64)(u64)a.dword[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vffint_d_lu (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vffint.d.lu vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert unsigned 64-bit integer elements in <code>a</code> to double-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (f64)(u64)a.dword[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vffinth_d_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vffinth_d_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vffinth.d.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert 32-bit integer elements in higher part of `a` to double precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i + 2]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vffinth_d_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vffinth.d.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert 32-bit integer elements in higher part of <code>a</code> to double precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i + 2]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vffintl_d_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vffintl_d_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vffintl.d.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert 32-bit integer elements in lower part of `a` to double precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vffintl_d_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vffintl.d.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert 32-bit integer elements in lower part of <code>a</code> to double precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vflogb_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vflogb_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vflogb.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute 2-based logarithm of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = log2(a.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vflogb_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vflogb.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute 2-based logarithm of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = log2(a.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfmadd_d (__m128d a, __m128d b, __m128d c)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfmadd_d (__m128d a, __m128d b, __m128d c)\n#include <lsxintrin.h>\nInstruction: vfmadd.d vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, accumulate to elements in `c` and store the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i] + c.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfmadd_d (__m128d a, __m128d b, __m128d c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmadd.d vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, accumulate to elements in <code>c</code> and store the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i] + c.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfmax_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfmax_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfmax.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute maximum of double precision floating point elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = fmax(a.fp64[i], b.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfmax_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmax.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute maximum of double precision floating point elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = fmax(a.fp64[i], b.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfmaxa_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfmaxa_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfmaxa.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute maximum of double precision floating point elements in `a` and `b` by magnitude.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (abs(a.fp64[i]) > abs(b.fp64[i])) ? a.fp64[i] : b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfmaxa_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmaxa.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute maximum of double precision floating point elements in <code>a</code> and <code>b</code> by magnitude.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (abs(a.fp64[i]) &gt; abs(b.fp64[i])) ? a.fp64[i] : b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfmin_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfmin_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfmin.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute minimum of double precision floating point elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = fmin(a.fp64[i], b.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfmin_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmin.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute minimum of double precision floating point elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = fmin(a.fp64[i], b.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfmina_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfmina_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfmina.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute minimum of double precision floating point elements in `a` and `b` by magnitude.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (abs(a.fp64[i]) < abs(b.fp64[i])) ? a.fp64[i] : b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfmina_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmina.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute minimum of double precision floating point elements in <code>a</code> and <code>b</code> by magnitude.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (abs(a.fp64[i]) &lt; abs(b.fp64[i])) ? a.fp64[i] : b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfmsub_d (__m128d a, __m128d b, __m128d c)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfmsub_d (__m128d a, __m128d b, __m128d c)\n#include <lsxintrin.h>\nInstruction: vfmsub.d vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, subtract elements in `c` and store the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i] - c.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfmsub_d (__m128d a, __m128d b, __m128d c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmsub.d vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, subtract elements in <code>c</code> and store the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i] - c.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfmul_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfmul_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfmul.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply double precision floating point elements in `a` and elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfmul_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfmul.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply double precision floating point elements in <code>a</code> and elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfnmadd_d (__m128d a, __m128d b, __m128d c)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfnmadd_d (__m128d a, __m128d b, __m128d c)\n#include <lsxintrin.h>\nInstruction: vfnmadd.d vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, accumulate to elements in `c` and store the negated result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (a.fp64[i] * b.fp64[i] + c.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfnmadd_d (__m128d a, __m128d b, __m128d c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfnmadd.d vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, accumulate to elements in <code>c</code> and store the negated result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (a.fp64[i] * b.fp64[i] + c.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfnmsub_d (__m128d a, __m128d b, __m128d c)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfnmsub_d (__m128d a, __m128d b, __m128d c)\n#include <lsxintrin.h>\nInstruction: vfnmsub.d vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, subtract elements in `c` and store the negated result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = -(a.fp64[i] * b.fp64[i] - c.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfnmsub_d (__m128d a, __m128d b, __m128d c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfnmsub.d vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, subtract elements in <code>c</code> and store the negated result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = -(a.fp64[i] * b.fp64[i] - c.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrecip_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrecip_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrecip.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute reciprocal of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = 1 / a.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 23 | 0.08(1/12) |\n| 3A6000 | LA664 | 8 | 0.25(1/4) |\n| 3C6000 | LA664 | 23 | 0.1(1/10.5) |\n| 2K1000LA | LA264 | 24 | 0.04(1/24) |\n| 2K3000 | LA364E | 24 | 0.04(1/24) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrecip_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrecip.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute reciprocal of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = 1 / a.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>23</td>\n<td>0.08(1/12)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>23</td>\n<td>0.1(1/10.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>24</td>\n<td>0.04(1/24)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>24</td>\n<td>0.04(1/24)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrecipe_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrecipe_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrecipe.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute estimated reciprocal of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = 1 / a.fp64[i]; // estimated\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrecipe_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrecipe.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute estimated reciprocal of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = 1 / a.fp64[i]; // estimated\n}\n</code></pre>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrint_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrint_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrint.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, using current rounding mode specified in `fscr`, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrint_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrint.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, using current rounding mode specified in <code>fscr</code>, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrintrm_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrintrm_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrintrm.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards negative infinity, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrintrm_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrintrm.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards negative infinity, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrintrne_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrintrne_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrintrne.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards nearest even, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrintrne_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrintrne.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards nearest even, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrintrp_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrintrp_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrintrp.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards positive infinity, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrintrp_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrintrp.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards positive infinity, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrintrz_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrintrz_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrintrz.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards zero, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrintrz_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrintrz.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards zero, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrsqrt_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrsqrt_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrsqrt.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute reciprocal of square root of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = 1.0 / sqrt(a.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 15 | 0.04(1/27.5) |\n| 3A6000 | LA664 | 15 | 0.04(1/26.5) |\n| 3C6000 | LA664 | 15 | 0.04(1/26) |\n| 2K1000LA | LA264 | 16 | 0(1/55) |\n| 2K3000 | LA364E | 16 | 0(1/55) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrsqrt_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrsqrt.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute reciprocal of square root of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = 1.0 / sqrt(a.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>15</td>\n<td>0.04(1/27.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>15</td>\n<td>0.04(1/26.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>15</td>\n<td>0.04(1/26)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>16</td>\n<td>0(1/55)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>16</td>\n<td>0(1/55)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfrsqrte_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfrsqrte_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfrsqrte.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute estimated reciprocal of square root of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = 1.0 / sqrt(a.fp64[i]); // estimated\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfrsqrte_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrsqrte.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute estimated reciprocal of square root of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = 1.0 / sqrt(a.fp64[i]); // estimated\n}\n</code></pre>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfscaleb_d (__m128d a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfscaleb_d (__m128d a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vfscaleb.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute IEEE754 scaleB of double precision floating point elements in `a` by integer elements in `b`. Currently undocumented.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = __builtin_scalbn(a.fp64[i], b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfscaleb_d (__m128d a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfscaleb.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute IEEE754 scaleB of double precision floating point elements in <code>a</code> by integer elements in <code>b</code>. Currently undocumented.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = __builtin_scalbn(a.fp64[i], b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Undocumented Intrinsics", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfsqrt_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfsqrt_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfsqrt.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute square root of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = sqrt(a.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 36 | 0.05(1/18.5) |\n| 3A6000 | LA664 | 36 | 0.06(1/17.5) |\n| 3C6000 | LA664 | 36 | 0.06(1/17) |\n| 2K1000LA | LA264 | 11 | 0.03(1/37) |\n| 2K3000 | LA364E | 11 | 0.03(1/37) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfsqrt_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfsqrt.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute square root of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = sqrt(a.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>36</td>\n<td>0.05(1/18.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>36</td>\n<td>0.06(1/17.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>36</td>\n<td>0.06(1/17)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>11</td>\n<td>0.03(1/37)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>11</td>\n<td>0.03(1/37)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128d __lsx_vfsub_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128d __lsx_vfsub_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfsub.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract double precision floating point elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp64[i] - b.fp64[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128d __lsx_vfsub_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfsub.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract double precision floating point elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp64[i] - b.fp64[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vabsd_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vabsd_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vabsd.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute absolute difference of signed 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] > (s8)b.byte[i]) ? (a.byte[i] - b.byte[i])\n                                                : (b.byte[i] - a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vabsd_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vabsd.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of signed 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &gt; (s8)b.byte[i]) ? (a.byte[i] - b.byte[i])\n                                                : (b.byte[i] - a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vabsd_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vabsd_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vabsd.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute absolute difference of unsigned 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] > (u8)b.byte[i]) ? (a.byte[i] - b.byte[i])\n                                                : (b.byte[i] - a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vabsd_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vabsd.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of unsigned 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &gt; (u8)b.byte[i]) ? (a.byte[i] - b.byte[i])\n                                                : (b.byte[i] - a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vabsd_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vabsd_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vabsd.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute absolute difference of signed 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] > (s64)b.dword[i])\n                     ? (a.dword[i] - b.dword[i])\n                     : (b.dword[i] - a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vabsd_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vabsd.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of signed 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &gt; (s64)b.dword[i])\n                     ? (a.dword[i] - b.dword[i])\n                     : (b.dword[i] - a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vabsd_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vabsd_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vabsd.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute absolute difference of unsigned 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] > (u64)b.dword[i])\n                     ? (a.dword[i] - b.dword[i])\n                     : (b.dword[i] - a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vabsd_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vabsd.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of unsigned 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &gt; (u64)b.dword[i])\n                     ? (a.dword[i] - b.dword[i])\n                     : (b.dword[i] - a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vabsd_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vabsd_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vabsd.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute absolute difference of signed 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i] > (s16)b.half[i]) ? (a.half[i] - b.half[i])\n                                                  : (b.half[i] - a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vabsd_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vabsd.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of signed 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i] &gt; (s16)b.half[i]) ? (a.half[i] - b.half[i])\n                                                  : (b.half[i] - a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vabsd_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vabsd_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vabsd.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute absolute difference of unsigned 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((u16)a.half[i] > (u16)b.half[i]) ? (a.half[i] - b.half[i])\n                                                  : (b.half[i] - a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vabsd_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vabsd.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of unsigned 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((u16)a.half[i] &gt; (u16)b.half[i]) ? (a.half[i] - b.half[i])\n                                                  : (b.half[i] - a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vabsd_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vabsd_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vabsd.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute absolute difference of signed 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i] > (s32)b.word[i]) ? (a.word[i] - b.word[i])\n                                                  : (b.word[i] - a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vabsd_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vabsd.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of signed 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i] &gt; (s32)b.word[i]) ? (a.word[i] - b.word[i])\n                                                  : (b.word[i] - a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vabsd_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vabsd_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vabsd.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute absolute difference of unsigned 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((u32)a.word[i] > (u32)b.word[i]) ? (a.word[i] - b.word[i])\n                                                  : (b.word[i] - a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vabsd_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vabsd.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of unsigned 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((u32)a.word[i] &gt; (u32)b.word[i]) ? (a.word[i] - b.word[i])\n                                                  : (b.word[i] - a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadd_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadd_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadd.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] + b.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadd_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadd.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] + b.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadd_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadd_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadd.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] + b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadd_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadd.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] + b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadd_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadd_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadd.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] + b.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadd_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadd.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] + b.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadd_q (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadd_q (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadd.q vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 128-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst.qword[0] = a.qword[0] + b.qword[0];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadd_q (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadd.q vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 128-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst.qword[0] = a.qword[0] + b.qword[0];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadd_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadd_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadd.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] + b.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadd_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadd.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] + b.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadda_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadda_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadda.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd absolute of 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = abs((s8)a.byte[i]) + abs((s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadda_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadda.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add absolute of 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = abs((s8)a.byte[i]) + abs((s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadda_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadda_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadda.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd absolute of 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = abs((s64)a.dword[i]) + abs((s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadda_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadda.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add absolute of 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = abs((s64)a.dword[i]) + abs((s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadda_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadda_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadda.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd absolute of 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = abs((s16)a.half[i]) + abs((s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadda_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadda.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add absolute of 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = abs((s16)a.half[i]) + abs((s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vadda_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vadda_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vadda.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd absolute of 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = abs((s32)a.word[i]) + abs((s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vadda_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vadda.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add absolute of 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = abs((s32)a.word[i]) + abs((s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddi_bu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddi_bu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vaddi.bu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 8-bit elements in `a` and `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] + imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddi_bu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddi.bu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 8-bit elements in <code>a</code> and <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] + imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddi_du (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddi_du (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vaddi.du vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 64-bit elements in `a` and `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] + imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddi_du (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddi.du vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 64-bit elements in <code>a</code> and <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] + imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddi_hu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddi_hu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vaddi.hu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 16-bit elements in `a` and `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] + imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddi_hu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddi.hu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 16-bit elements in <code>a</code> and <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] + imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddi_wu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddi_wu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vaddi.wu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nAdd 32-bit elements in `a` and `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] + imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddi_wu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddi.wu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 32-bit elements in <code>a</code> and <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] + imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_d_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_d_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) + ((s64)((s32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_d_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) + ((s64)((s32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_d_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_d_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.d.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] + (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) + ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) + ((u64)((u32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_d_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.d.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] + (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) + ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) + ((u64)((u32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_d_wu_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_d_wu_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.d.wu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned unsigned 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) + ((s64)((s32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_d_wu_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.d.wu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) + ((s64)((s32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_h_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_h_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) + ((s16)((s8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_h_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) + ((s16)((s8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_h_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_h_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.h.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] + (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) + ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) + ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) + ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) + ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) + ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) + ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) + ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) + ((u16)((u8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_h_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.h.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] + (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) + ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) + ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) + ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) + ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) + ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) + ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) + ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) + ((u16)((u8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_h_bu_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_h_bu_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.h.bu.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned unsigned 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) + ((s16)((s8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_h_bu_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.h.bu.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) + ((s16)((s8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_q_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_q_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) + ((s128)((s64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_q_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) + ((s128)((s64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_q_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_q_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.q.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] + (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) + ((u128)((u64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_q_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.q.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] + (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) + ((u128)((u64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_q_du_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_q_du_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.q.du.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned unsigned 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) + ((s128)((s64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_q_du_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.q.du.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) + ((s128)((s64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_w_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_w_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) + ((s32)((s16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_w_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) + ((s32)((s16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_w_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_w_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.w.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] + (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) + ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) + ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) + ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) + ((u32)((u16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_w_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.w.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] + (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) + ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) + ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) + ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) + ((u32)((u16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwev_w_hu_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwev_w_hu_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwev.w.hu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd even-positioned unsigned 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) + ((s32)((s16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwev_w_hu_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwev.w.hu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) + ((s32)((s16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_d_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_d_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) + ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) + ((s64)((s32)b.word[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_d_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) + ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) + ((s64)((s32)b.word[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_d_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_d_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.d.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((u64)((u32)b.word[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_d_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.d.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((u64)((u32)b.word[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_d_wu_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_d_wu_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.d.wu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((s64)((s32)b.word[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_d_wu_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.d.wu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((s64)((s32)b.word[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_h_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_h_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) + ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) + ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) + ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) + ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) + ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) + ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) + ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) + ((s16)((s8)b.byte[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_h_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) + ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) + ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) + ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) + ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) + ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) + ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) + ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) + ((s16)((s8)b.byte[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_h_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_h_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.h.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((u16)((u8)b.byte[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_h_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.h.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((u16)((u8)b.byte[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_h_bu_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_h_bu_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.h.bu.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((s16)((s8)b.byte[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_h_bu_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.h.bu.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((s16)((s8)b.byte[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_q_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_q_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) + ((s128)((s64)b.dword[1]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_q_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) + ((s128)((s64)b.dword[1]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_q_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_q_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.q.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((u128)((u64)b.dword[1]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_q_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.q.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((u128)((u64)b.dword[1]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_q_du_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_q_du_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.q.du.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((s128)((s64)b.dword[1]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_q_du_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.q.du.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((s128)((s64)b.dword[1]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_w_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_w_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) + ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) + ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) + ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) + ((s32)((s16)b.half[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_w_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) + ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) + ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) + ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) + ((s32)((s16)b.half[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_w_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_w_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.w.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((u32)((u16)b.half[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_w_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.w.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((u32)((u16)b.half[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vaddwod_w_hu_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vaddwod_w_hu_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vaddwod.w.hu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((s32)((s16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((s32)((s16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((s32)((s16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((s32)((s16)b.half[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vaddwod_w_hu_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vaddwod.w.hu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((s32)((s16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((s32)((s16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((s32)((s16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((s32)((s16)b.half[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vand_v (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vand_v (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vand.v vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise AND between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] & b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vand_v (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vand.v vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise AND between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] &amp; b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vandi_b (__m128i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vandi_b (__m128i a, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vandi.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise AND between elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] & imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vandi_b (__m128i a, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vandi.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise AND between elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] &amp; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vandn_v (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vandn_v (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vandn.v vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise ANDN between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = b.dword[i] & (~a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vandn_v (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vandn.v vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise ANDN between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = b.dword[i] &amp; (~a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavg_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavg_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavg.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of signed 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] >> 1) + ((s8)b.byte[i] >> 1) +\n                ((a.byte[i] & b.byte[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavg_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavg.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of signed 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &gt;&gt; 1) + ((s8)b.byte[i] &gt;&gt; 1) +\n                ((a.byte[i] &amp; b.byte[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavg_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavg_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavg.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of unsigned 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] >> 1) + ((u8)b.byte[i] >> 1) +\n                ((a.byte[i] & b.byte[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavg_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavg.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of unsigned 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &gt;&gt; 1) + ((u8)b.byte[i] &gt;&gt; 1) +\n                ((a.byte[i] &amp; b.byte[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavg_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavg_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavg.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of signed 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] >> 1) + ((s64)b.dword[i] >> 1) +\n                 ((a.dword[i] & b.dword[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavg_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavg.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of signed 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &gt;&gt; 1) + ((s64)b.dword[i] &gt;&gt; 1) +\n                 ((a.dword[i] &amp; b.dword[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavg_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavg_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavg.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of unsigned 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] >> 1) + ((u64)b.dword[i] >> 1) +\n                 ((a.dword[i] & b.dword[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavg_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavg.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of unsigned 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &gt;&gt; 1) + ((u64)b.dword[i] &gt;&gt; 1) +\n                 ((a.dword[i] &amp; b.dword[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavg_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavg_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavg.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of signed 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i] >> 1) + ((s16)b.half[i] >> 1) +\n                ((a.half[i] & b.half[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavg_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavg.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of signed 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i] &gt;&gt; 1) + ((s16)b.half[i] &gt;&gt; 1) +\n                ((a.half[i] &amp; b.half[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavg_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavg_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavg.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of unsigned 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((u16)a.half[i] >> 1) + ((u16)b.half[i] >> 1) +\n                ((a.half[i] & b.half[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavg_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavg.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of unsigned 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((u16)a.half[i] &gt;&gt; 1) + ((u16)b.half[i] &gt;&gt; 1) +\n                ((a.half[i] &amp; b.half[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavg_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavg_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavg.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of signed 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i] >> 1) + ((s32)b.word[i] >> 1) +\n                ((a.word[i] & b.word[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavg_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavg.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of signed 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i] &gt;&gt; 1) + ((s32)b.word[i] &gt;&gt; 1) +\n                ((a.word[i] &amp; b.word[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavg_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavg_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavg.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of unsigned 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((u32)a.word[i] >> 1) + ((u32)b.word[i] >> 1) +\n                ((a.word[i] & b.word[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavg_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavg.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of unsigned 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((u32)a.word[i] &gt;&gt; 1) + ((u32)b.word[i] &gt;&gt; 1) +\n                ((a.word[i] &amp; b.word[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavgr_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavgr_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavgr.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of signed 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] >> 1) + ((s8)b.byte[i] >> 1) +\n                ((a.byte[i] | b.byte[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavgr_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavgr.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of signed 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &gt;&gt; 1) + ((s8)b.byte[i] &gt;&gt; 1) +\n                ((a.byte[i] | b.byte[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavgr_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavgr_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavgr.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of unsigned 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] >> 1) + ((u8)b.byte[i] >> 1) +\n                ((a.byte[i] | b.byte[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavgr_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavgr.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of unsigned 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &gt;&gt; 1) + ((u8)b.byte[i] &gt;&gt; 1) +\n                ((a.byte[i] | b.byte[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavgr_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavgr_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavgr.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of signed 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] >> 1) + ((s64)b.dword[i] >> 1) +\n                 ((a.dword[i] | b.dword[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavgr_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavgr.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of signed 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &gt;&gt; 1) + ((s64)b.dword[i] &gt;&gt; 1) +\n                 ((a.dword[i] | b.dword[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavgr_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavgr_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavgr.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of unsigned 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] >> 1) + ((u64)b.dword[i] >> 1) +\n                 ((a.dword[i] | b.dword[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavgr_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavgr.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of unsigned 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &gt;&gt; 1) + ((u64)b.dword[i] &gt;&gt; 1) +\n                 ((a.dword[i] | b.dword[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavgr_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavgr_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavgr.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of signed 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i] >> 1) + ((s16)b.half[i] >> 1) +\n                ((a.half[i] | b.half[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavgr_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavgr.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of signed 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i] &gt;&gt; 1) + ((s16)b.half[i] &gt;&gt; 1) +\n                ((a.half[i] | b.half[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavgr_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavgr_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavgr.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of unsigned 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((u16)a.half[i] >> 1) + ((u16)b.half[i] >> 1) +\n                ((a.half[i] | b.half[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavgr_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavgr.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of unsigned 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((u16)a.half[i] &gt;&gt; 1) + ((u16)b.half[i] &gt;&gt; 1) +\n                ((a.half[i] | b.half[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavgr_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavgr_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavgr.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of signed 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i] >> 1) + ((s32)b.word[i] >> 1) +\n                ((a.word[i] | b.word[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavgr_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavgr.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of signed 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i] &gt;&gt; 1) + ((s32)b.word[i] &gt;&gt; 1) +\n                ((a.word[i] | b.word[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vavgr_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vavgr_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vavgr.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of unsigned 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((u32)a.word[i] >> 1) + ((u32)b.word[i] >> 1) +\n                ((a.word[i] | b.word[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vavgr_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vavgr.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of unsigned 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((u32)a.word[i] &gt;&gt; 1) + ((u32)b.word[i] &gt;&gt; 1) +\n                ((a.word[i] | b.word[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitclr_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitclr_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitclr.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nClear the bit specified by elements in `b` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitclr_b(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0xf7f7f7f7f7f7f7f7 0x99aabbccd5ecf700\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] & (~((u8)1 << (b.byte[i] % 8)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclr_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitclr.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by elements in <code>b</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclr_b(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0xf7f7f7f7f7f7f7f7 0x99aabbccd5ecf700\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] &amp; (~((u8)1 &lt;&lt; (b.byte[i] % 8)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitclr_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitclr_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitclr.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nClear the bit specified by elements in `b` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitclr_d(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0xfffff7ffffffffff 0x99aabbccddeeff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] & (~((u64)1 << (b.dword[i] % 64)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclr_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitclr.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by elements in <code>b</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclr_d(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0xfffff7ffffffffff 0x99aabbccddeeff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] &amp; (~((u64)1 &lt;&lt; (b.dword[i] % 64)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitclr_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitclr_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitclr.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nClear the bit specified by elements in `b` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitclr_h(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0xf7fff7fff7fff7ff 0x99aabbccddecff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] & (~((u16)1 << (b.half[i] % 16)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclr_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitclr.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by elements in <code>b</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclr_h(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0xf7fff7fff7fff7ff 0x99aabbccddecff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] &amp; (~((u16)1 &lt;&lt; (b.half[i] % 16)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitclr_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitclr_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitclr.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nClear the bit specified by elements in `b` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitclr_w(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0xfffff7fffffff7ff 0x99aabbccddeeff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] & (~((u32)1 << (b.word[i] % 32)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclr_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitclr.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by elements in <code>b</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclr_w(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0xfffff7fffffff7ff 0x99aabbccddeeff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] &amp; (~((u32)1 &lt;&lt; (b.word[i] % 32)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitclri_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitclri_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vbitclri.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClear the bit specified by `imm` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitclri_b(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, 1)\n= 0xfdfdfdfdfdfdfdfd 0x99a8b9ccddecfd00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] & (~((u8)1 << imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclri_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitclri.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by <code>imm</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclri_b(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, 1)\n= 0xfdfdfdfdfdfdfdfd 0x99a8b9ccddecfd00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] &amp; (~((u8)1 &lt;&lt; imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitclri_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitclri_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vbitclri.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClear the bit specified by `imm` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitclri_d(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, 1)\n= 0xfffffffffffffffd 0x99aabbccddeeff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] & (~((u64)1 << imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclri_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitclri.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by <code>imm</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclri_d(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, 1)\n= 0xfffffffffffffffd 0x99aabbccddeeff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] &amp; (~((u64)1 &lt;&lt; imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitclri_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitclri_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vbitclri.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClear the bit specified by `imm` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitclri_h(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, 1)\n= 0xfffdfffdfffdfffd 0x99a8bbccddecff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] & (~((u16)1 << imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclri_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitclri.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by <code>imm</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclri_h(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, 1)\n= 0xfffdfffdfffdfffd 0x99a8bbccddecff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] &amp; (~((u16)1 &lt;&lt; imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitclri_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitclri_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vbitclri.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClear the bit specified by `imm` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitclri_w(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, 1)\n= 0xfffffffdfffffffd 0x99aabbccddeeff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] & (~((u32)1 << imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclri_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitclri.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by <code>imm</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitclri_w(__m128i{0xffffffffffffffff, 0x99aabbccddeeff00}, 1)\n= 0xfffffffdfffffffd 0x99aabbccddeeff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] &amp; (~((u32)1 &lt;&lt; imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitrev_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitrev_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitrev.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nToggle the bit specified by elements in `b` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitrev_b(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0707070707070707 0x9dbabfdcd5ecf702\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] ^ ((u8)1 << (b.byte[i] % 8));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrev_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitrev.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by elements in <code>b</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrev_b(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0707070707070707 0x9dbabfdcd5ecf702\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] ^ ((u8)1 &lt;&lt; (b.byte[i] % 8));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitrev_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitrev_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitrev.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nToggle the bit specified by elements in `b` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitrev_d(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0f0f070f0f0f0f0f 0x99aabbceddeeff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] ^ ((u64)1 << (b.dword[i] % 64));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrev_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitrev.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by elements in <code>b</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrev_d(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0f0f070f0f0f0f0f 0x99aabbceddeeff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] ^ ((u64)1 &lt;&lt; (b.dword[i] % 64));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitrev_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitrev_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitrev.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nToggle the bit specified by elements in `b` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitrev_h(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x070f070f070f070f 0x99babbdcddecff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] ^ ((u16)1 << (b.half[i] % 16));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrev_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitrev.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by elements in <code>b</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrev_h(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x070f070f070f070f 0x99babbdcddecff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] ^ ((u16)1 &lt;&lt; (b.half[i] % 16));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitrev_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitrev_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitrev.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nToggle the bit specified by elements in `b` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitrev_w(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0f0f070f0f0f070f 0x99babbccddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] ^ ((u32)1 << (b.word[i] % 32));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrev_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitrev.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by elements in <code>b</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrev_w(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0f0f070f0f0f070f 0x99babbccddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] ^ ((u32)1 &lt;&lt; (b.word[i] % 32));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitrevi_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitrevi_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vbitrevi.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nToggle the bit specified by `imm` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitrevi_b(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, 1)\n= 0x0d0d0d0d0d0d0d0d 0x9ba8b9cedfecfd02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] ^ ((u8)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrevi_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitrevi.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by <code>imm</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrevi_b(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, 1)\n= 0x0d0d0d0d0d0d0d0d 0x9ba8b9cedfecfd02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] ^ ((u8)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitrevi_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitrevi_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vbitrevi.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nToggle the bit specified by `imm` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitrevi_d(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, 1)\n= 0x0f0f0f0f0f0f0f0d 0x99aabbccddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] ^ ((u64)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrevi_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitrevi.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by <code>imm</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrevi_d(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, 1)\n= 0x0f0f0f0f0f0f0f0d 0x99aabbccddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] ^ ((u64)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitrevi_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitrevi_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vbitrevi.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nToggle the bit specified by `imm` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitrevi_h(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, 1)\n= 0x0f0d0f0d0f0d0f0d 0x99a8bbceddecff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] ^ ((u16)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrevi_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitrevi.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by <code>imm</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrevi_h(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, 1)\n= 0x0f0d0f0d0f0d0f0d 0x99a8bbceddecff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] ^ ((u16)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitrevi_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitrevi_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vbitrevi.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nToggle the bit specified by `imm` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitrevi_w(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, 1)\n= 0x0f0f0f0d0f0f0f0d 0x99aabbceddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] ^ ((u32)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrevi_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitrevi.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by <code>imm</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitrevi_w(__m128i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00}, 1)\n= 0x0f0f0f0d0f0f0f0d 0x99aabbceddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] ^ ((u32)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitsel_v (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitsel_v (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vbitsel.v vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise selection: for each bit position, if the bit in `c` equals to one, copy the bit from `b` to `dst`, otherwise copy from `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitsel_v(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321}, __m128i{0xffff0000aaaabbbb, 0x1111222233334444})\n= 0xabab3344ffeeefab 0x98ba9beccfedfb00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (c.dword[i] & b.dword[i]) | (~c.dword[i] & a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitsel_v (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitsel.v vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise selection: for each bit position, if the bit in <code>c</code> equals to one, copy the bit from <code>b</code> to <code>dst</code>, otherwise copy from <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitsel_v(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321}, __m128i{0xffff0000aaaabbbb, 0x1111222233334444})\n= 0xabab3344ffeeefab 0x98ba9beccfedfb00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (c.dword[i] &amp; b.dword[i]) | (~c.dword[i] &amp; a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitseli_b (__m128i a, __m128i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitseli_b (__m128i a, __m128i b, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vbitseli.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise selection: for each bit position, if the bit in `a` equals to one, copy the bit from `imm` to `dst`, otherwise copy from `b`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitseli_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321}, 0x12)\n= 0xba8b9aabba8b9a23 0x1216123012031221\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (~a.byte[i] & b.byte[i]) | (a.byte[i] & (u8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseli_b (__m128i a, __m128i b, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitseli.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise selection: for each bit position, if the bit in <code>a</code> equals to one, copy the bit from <code>imm</code> to <code>dst</code>, otherwise copy from <code>b</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseli_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321}, 0x12)\n= 0xba8b9aabba8b9a23 0x1216123012031221\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (~a.byte[i] &amp; b.byte[i]) | (a.byte[i] &amp; (u8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitset_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitset_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitset.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSet the bit specified by elements in `b` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitset_b(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0808080808080808 0x9dbabfdcddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] | ((u8)1 << (b.byte[i] % 8));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitset_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitset.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by elements in <code>b</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitset_b(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0808080808080808 0x9dbabfdcddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] | ((u8)1 &lt;&lt; (b.byte[i] % 8));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitset_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitset_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitset.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSet the bit specified by elements in `b` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitset_d(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0000080000000000 0x99aabbceddeeff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] | ((u64)1 << (b.dword[i] % 64));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitset_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitset.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by elements in <code>b</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitset_d(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0000080000000000 0x99aabbceddeeff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] | ((u64)1 &lt;&lt; (b.dword[i] % 64));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitset_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitset_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitset.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSet the bit specified by elements in `b` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitset_h(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0800080008000800 0x99babbdcddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] | ((u16)1 << (b.half[i] % 16));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitset_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitset.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by elements in <code>b</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitset_h(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0800080008000800 0x99babbdcddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] | ((u16)1 &lt;&lt; (b.half[i] % 16));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitset_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitset_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vbitset.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSet the bit specified by elements in `b` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitset_w(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0000080000000800 0x99babbccddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] | ((u32)1 << (b.word[i] % 32));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitset_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitset.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by elements in <code>b</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitset_w(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, __m128i{0xabababababababab, 0x1234123443214321})\n= 0x0000080000000800 0x99babbccddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] | ((u32)1 &lt;&lt; (b.word[i] % 32));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitseti_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitseti_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vbitseti.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nSet the bit specified by `imm` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitseti_b(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, 1)\n= 0x0202020202020202 0x9baabbcedfeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] | ((u8)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseti_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitseti.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by <code>imm</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseti_b(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, 1)\n= 0x0202020202020202 0x9baabbcedfeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] | ((u8)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitseti_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitseti_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vbitseti.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nSet the bit specified by `imm` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitseti_d(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, 1)\n= 0x0000000000000002 0x99aabbccddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] | ((u64)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseti_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitseti.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by <code>imm</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseti_d(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, 1)\n= 0x0000000000000002 0x99aabbccddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] | ((u64)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitseti_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitseti_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vbitseti.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nSet the bit specified by `imm` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitseti_h(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, 1)\n= 0x0002000200020002 0x99aabbceddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] | ((u16)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseti_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitseti.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by <code>imm</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseti_h(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, 1)\n= 0x0002000200020002 0x99aabbceddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] | ((u16)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbitseti_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbitseti_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vbitseti.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nSet the bit specified by `imm` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vbitseti_w(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, 1)\n= 0x0000000200000002 0x99aabbceddeeff02\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] | ((u32)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseti_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbitseti.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by <code>imm</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbitseti_w(__m128i{0x0000000000000000, 0x99aabbccddeeff00}, 1)\n= 0x0000000200000002 0x99aabbceddeeff02\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] | ((u32)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbsll_v (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbsll_v (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vbsll.v vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute whole vector `a` shifted left by `imm * 8` bits.\n\n\n\n\n\n### Operation\n\n```c++\nint shift = (imm * 8) % 128;\ndst.qword[0] = (u128)a.qword[0] << shift;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbsll_v (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbsll.v vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute whole vector <code>a</code> shifted left by <code>imm * 8</code> bits.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int shift = (imm * 8) % 128;\ndst.qword[0] = (u128)a.qword[0] &lt;&lt; shift;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vbsrl_v (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vbsrl_v (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vbsrl.v vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute whole vector `a` shifted right by `imm * 8` bits.\n\n\n\n\n\n### Operation\n\n```c++\nint shift = (imm * 8) % 128;\ndst.qword[0] = (u128)a.qword[0] >> shift;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vbsrl_v (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vbsrl.v vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute whole vector <code>a</code> shifted right by <code>imm * 8</code> bits.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int shift = (imm * 8) % 128;\ndst.qword[0] = (u128)a.qword[0] &gt;&gt; shift;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vclo_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vclo_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vclo.b vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount leading ones of 8-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vclo_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000001 0x0101010202030800\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = clo(a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclo_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vclo.b vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading ones of 8-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclo_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000001 0x0101010202030800\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = clo(a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vclo_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vclo_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vclo.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount leading ones of 64-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vclo_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000000 0x0000000000000001\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = clo(a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclo_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vclo.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading ones of 64-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclo_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000000 0x0000000000000001\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = clo(a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vclo_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vclo_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vclo.h vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount leading ones of 16-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vclo_h(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000000 0x0001000100020008\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = clo(a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclo_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vclo.h vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading ones of 16-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclo_h(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000000 0x0001000100020008\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = clo(a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vclo_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vclo_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vclo.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount leading ones of 32-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vclo_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000000 0x0000000100000002\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = clo(a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclo_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vclo.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading ones of 32-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclo_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000000 0x0000000100000002\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = clo(a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vclz_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vclz_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vclz.b vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount leading zeros of 8-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vclz_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0302020101010100 0x0000000000000008\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = clz(a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclz_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vclz.b vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading zeros of 8-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclz_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0302020101010100 0x0000000000000008\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = clz(a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vclz_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vclz_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vclz.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount leading zeros of 64-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vclz_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000003 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = clz(a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclz_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vclz.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading zeros of 64-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclz_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000003 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = clz(a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vclz_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vclz_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vclz.h vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount leading zeros of 16-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vclz_h(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0003000200010001 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = clz(a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclz_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vclz.h vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading zeros of 16-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclz_h(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0003000200010001 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = clz(a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vclz_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vclz_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vclz.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount leading zeros of 32-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vclz_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000300000001 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = clz(a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclz_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vclz.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading zeros of 32-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vclz_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000300000001 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = clz(a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vdiv_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vdiv_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vdiv.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide signed 8-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((s8)a.byte[i] / (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 29, 32 | 0.06(1/17) |\n| 3A6000 | LA664 | 29, 32 | 0.06(1/15.5) |\n| 3C6000 | LA664 | 29, 32 | 0.07(1/13.5) |\n| 2K1000LA | LA264 | 30, 58 | 0(1/55) |\n| 2K3000 | LA364E | 30 | 0(1/55) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vdiv_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vdiv.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide signed 8-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((s8)a.byte[i] / (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>29, 32</td>\n<td>0.06(1/17)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>29, 32</td>\n<td>0.06(1/15.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>29, 32</td>\n<td>0.07(1/13.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>30, 58</td>\n<td>0(1/55)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>30</td>\n<td>0(1/55)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vdiv_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vdiv_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vdiv.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide unsigned 8-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((u8)a.byte[i] / (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 29, 36 | 0.06(1/18) |\n| 3A6000 | LA664 | 29, 33 | 0.06(1/16.5) |\n| 3C6000 | LA664 | 29, 36 | 0.07(1/13.5) |\n| 2K1000LA | LA264 | 30, 44 | 0(1/55) |\n| 2K3000 | LA364E | 30 | 0(1/55) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vdiv_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vdiv.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((u8)a.byte[i] / (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>29, 36</td>\n<td>0.06(1/18)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>29, 33</td>\n<td>0.06(1/16.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>29, 36</td>\n<td>0.07(1/13.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>30, 44</td>\n<td>0(1/55)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>30</td>\n<td>0(1/55)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vdiv_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vdiv_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vdiv.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide signed 64-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((s64)a.dword[i] / (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 18.5 | 0.11(1/9) |\n| 3A6000 | LA664 | 8 | 0.25(1/4) |\n| 3C6000 | LA664 | 8, 18.5 | 0.33(1/3) |\n| 2K1000LA | LA264 | 9, 19.5 | 0.08(1/12) |\n| 2K3000 | LA364E | 9 | 0.08(1/12) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vdiv_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vdiv.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide signed 64-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((s64)a.dword[i] / (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 18.5</td>\n<td>0.11(1/9)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8, 18.5</td>\n<td>0.33(1/3)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>9, 19.5</td>\n<td>0.08(1/12)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>9</td>\n<td>0.08(1/12)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vdiv_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vdiv_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vdiv.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide unsigned 64-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((u64)a.dword[i] / (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 18.5 | 0.11(1/9) |\n| 3A6000 | LA664 | 8 | 0.25(1/4) |\n| 3C6000 | LA664 | 8, 18.5 | 0.33(1/3) |\n| 2K1000LA | LA264 | 9 | 0.08(1/12) |\n| 2K3000 | LA364E | 9 | 0.08(1/12) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vdiv_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vdiv.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((u64)a.dword[i] / (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 18.5</td>\n<td>0.11(1/9)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8, 18.5</td>\n<td>0.33(1/3)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>9</td>\n<td>0.08(1/12)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>9</td>\n<td>0.08(1/12)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vdiv_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vdiv_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vdiv.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide signed 16-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((s16)a.half[i] / (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 17, 21.5 | 0.09(1/11) |\n| 3A6000 | LA664 | 17 | 0.12(1/8.5) |\n| 3C6000 | LA664 | 17, 21.5 | 0.13(1/7.5) |\n| 2K1000LA | LA264 | 18, 36 | 0.03(1/31) |\n| 2K3000 | LA364E | 18, 27 | 0.03(1/31) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vdiv_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vdiv.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide signed 16-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((s16)a.half[i] / (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>17, 21.5</td>\n<td>0.09(1/11)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17</td>\n<td>0.12(1/8.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>17, 21.5</td>\n<td>0.13(1/7.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>18, 36</td>\n<td>0.03(1/31)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>18, 27</td>\n<td>0.03(1/31)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vdiv_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vdiv_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vdiv.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide unsigned 16-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((u16)a.half[i] / (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 17, 21.5 | 0.07(1/14) |\n| 3A6000 | LA664 | 17, 22 | 0.11(1/9) |\n| 3C6000 | LA664 | 17, 21.5 | 0.13(1/7.5) |\n| 2K1000LA | LA264 | 18, 27 | 0.03(1/31) |\n| 2K3000 | LA364E | 18, 27 | 0.03(1/31) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vdiv_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vdiv.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((u16)a.half[i] / (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>17, 21.5</td>\n<td>0.07(1/14)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17, 22</td>\n<td>0.11(1/9)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>17, 21.5</td>\n<td>0.13(1/7.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>18, 27</td>\n<td>0.03(1/31)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>18, 27</td>\n<td>0.03(1/31)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vdiv_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vdiv_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vdiv.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide signed 32-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((s32)a.word[i] / (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 17.5 | 0.09(1/11.5) |\n| 3A6000 | LA664 | 11 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11, 17.5 | 0.22(1/4.5) |\n| 2K1000LA | LA264 | 12, 25 | 0.06(1/18) |\n| 2K3000 | LA364E | 12, 18.5 | 0.06(1/18) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vdiv_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vdiv.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide signed 32-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((s32)a.word[i] / (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 17.5</td>\n<td>0.09(1/11.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11, 17.5</td>\n<td>0.22(1/4.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>12, 25</td>\n<td>0.06(1/18)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>12, 18.5</td>\n<td>0.06(1/18)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vdiv_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vdiv_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vdiv.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nDivide unsigned 32-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((u32)a.word[i] / (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 17.5 | 0.07(1/15) |\n| 3A6000 | LA664 | 11 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11, 17.5 | 0.22(1/4.5) |\n| 2K1000LA | LA264 | 12 | 0.06(1/18) |\n| 2K3000 | LA364E | 12, 18.5 | 0.06(1/18) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vdiv_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vdiv.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((u32)a.word[i] / (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 17.5</td>\n<td>0.07(1/15)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11, 17.5</td>\n<td>0.22(1/4.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>12</td>\n<td>0.06(1/18)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>12, 18.5</td>\n<td>0.06(1/18)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vexth_d_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vexth_d_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vexth.d.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 32-bit elements in the higher half of `a` to 64-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)((s32)a.word[2]);\n  dst.dword[1] = (s64)((s32)a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vexth_d_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vexth.d.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 32-bit elements in the higher half of <code>a</code> to 64-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)((s32)a.word[2]);\n  dst.dword[1] = (s64)((s32)a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vexth_du_wu (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vexth_du_wu (__m128i a)\n#include <lsxintrin.h>\nInstruction: vexth.du.wu vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 32-bit elements in the higher half of `a` to 64-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (u64)((u32)a.word[2]);\n  dst.dword[1] = (u64)((u32)a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vexth_du_wu (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vexth.du.wu vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 32-bit elements in the higher half of <code>a</code> to 64-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (u64)((u32)a.word[2]);\n  dst.dword[1] = (u64)((u32)a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vexth_h_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vexth_h_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vexth.h.b vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 8-bit elements in the higher half of `a` to 16-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (s16)((s8)a.byte[8]);\n  dst.half[1] = (s16)((s8)a.byte[9]);\n  dst.half[2] = (s16)((s8)a.byte[10]);\n  dst.half[3] = (s16)((s8)a.byte[11]);\n  dst.half[4] = (s16)((s8)a.byte[12]);\n  dst.half[5] = (s16)((s8)a.byte[13]);\n  dst.half[6] = (s16)((s8)a.byte[14]);\n  dst.half[7] = (s16)((s8)a.byte[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vexth_h_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vexth.h.b vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 8-bit elements in the higher half of <code>a</code> to 16-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (s16)((s8)a.byte[8]);\n  dst.half[1] = (s16)((s8)a.byte[9]);\n  dst.half[2] = (s16)((s8)a.byte[10]);\n  dst.half[3] = (s16)((s8)a.byte[11]);\n  dst.half[4] = (s16)((s8)a.byte[12]);\n  dst.half[5] = (s16)((s8)a.byte[13]);\n  dst.half[6] = (s16)((s8)a.byte[14]);\n  dst.half[7] = (s16)((s8)a.byte[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vexth_hu_bu (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vexth_hu_bu (__m128i a)\n#include <lsxintrin.h>\nInstruction: vexth.hu.bu vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 8-bit elements in the higher half of `a` to 16-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (u16)((u8)a.byte[8]);\n  dst.half[1] = (u16)((u8)a.byte[9]);\n  dst.half[2] = (u16)((u8)a.byte[10]);\n  dst.half[3] = (u16)((u8)a.byte[11]);\n  dst.half[4] = (u16)((u8)a.byte[12]);\n  dst.half[5] = (u16)((u8)a.byte[13]);\n  dst.half[6] = (u16)((u8)a.byte[14]);\n  dst.half[7] = (u16)((u8)a.byte[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vexth_hu_bu (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vexth.hu.bu vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 8-bit elements in the higher half of <code>a</code> to 16-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (u16)((u8)a.byte[8]);\n  dst.half[1] = (u16)((u8)a.byte[9]);\n  dst.half[2] = (u16)((u8)a.byte[10]);\n  dst.half[3] = (u16)((u8)a.byte[11]);\n  dst.half[4] = (u16)((u8)a.byte[12]);\n  dst.half[5] = (u16)((u8)a.byte[13]);\n  dst.half[6] = (u16)((u8)a.byte[14]);\n  dst.half[7] = (u16)((u8)a.byte[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vexth_q_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vexth_q_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vexth.q.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 64-bit elements in the higher half of `a` to 128-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (s128)((s64)a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vexth_q_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vexth.q.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 64-bit elements in the higher half of <code>a</code> to 128-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (s128)((s64)a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vexth_qu_du (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vexth_qu_du (__m128i a)\n#include <lsxintrin.h>\nInstruction: vexth.qu.du vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 64-bit elements in the higher half of `a` to 128-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (u128)((u64)a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vexth_qu_du (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vexth.qu.du vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 64-bit elements in the higher half of <code>a</code> to 128-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (u128)((u64)a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vexth_w_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vexth_w_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vexth.w.h vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 16-bit elements in the higher half of `a` to 32-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)((s16)a.half[4]);\n  dst.word[1] = (s32)((s16)a.half[5]);\n  dst.word[2] = (s32)((s16)a.half[6]);\n  dst.word[3] = (s32)((s16)a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vexth_w_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vexth.w.h vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 16-bit elements in the higher half of <code>a</code> to 32-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)((s16)a.half[4]);\n  dst.word[1] = (s32)((s16)a.half[5]);\n  dst.word[2] = (s32)((s16)a.half[6]);\n  dst.word[3] = (s32)((s16)a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vexth_wu_hu (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vexth_wu_hu (__m128i a)\n#include <lsxintrin.h>\nInstruction: vexth.wu.hu vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 16-bit elements in the higher half of `a` to 32-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (u32)((u16)a.half[4]);\n  dst.word[1] = (u32)((u16)a.half[5]);\n  dst.word[2] = (u32)((u16)a.half[6]);\n  dst.word[3] = (u32)((u16)a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vexth_wu_hu (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vexth.wu.hu vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 16-bit elements in the higher half of <code>a</code> to 32-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (u32)((u16)a.half[4]);\n  dst.word[1] = (u32)((u16)a.half[5]);\n  dst.word[2] = (u32)((u16)a.half[6]);\n  dst.word[3] = (u32)((u16)a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vextl_q_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vextl_q_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vextl.q.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 64-bit elements in the lower half of `a` to 128-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (s128)((s64)a.dword[0]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vextl_q_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vextl.q.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 64-bit elements in the lower half of <code>a</code> to 128-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (s128)((s64)a.dword[0]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vextl_qu_du (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vextl_qu_du (__m128i a)\n#include <lsxintrin.h>\nInstruction: vextl.qu.du vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 64-bit elements in the lower half of `a` to 128-bit.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (u128)((u64)a.dword[0]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vextl_qu_du (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vextl.qu.du vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 64-bit elements in the lower half of <code>a</code> to 128-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (u128)((u64)a.dword[0]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vextrins_b (__m128i a, __m128i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vextrins_b (__m128i a, __m128i b, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vextrins.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtract one 8-bit element in `b` and insert it to `a` according to `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i == ((imm >> 4) & 15)) ? b.byte[imm & 15] : a.byte[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = (0 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[0]);\n  dst.byte[1] = (1 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[1]);\n  dst.byte[2] = (2 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[2]);\n  dst.byte[3] = (3 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[3]);\n  dst.byte[4] = (4 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[4]);\n  dst.byte[5] = (5 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[5]);\n  dst.byte[6] = (6 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[6]);\n  dst.byte[7] = (7 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[7]);\n  dst.byte[8] = (8 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[8]);\n  dst.byte[9] = (9 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[9]);\n  dst.byte[10] = (10 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[10]);\n  dst.byte[11] = (11 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[11]);\n  dst.byte[12] = (12 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[12]);\n  dst.byte[13] = (13 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[13]);\n  dst.byte[14] = (14 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[14]);\n  dst.byte[15] = (15 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vextrins_b (__m128i a, __m128i b, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vextrins.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extract one 8-bit element in <code>b</code> and insert it to <code>a</code> according to <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i == ((imm &gt;&gt; 4) &amp; 15)) ? b.byte[imm &amp; 15] : a.byte[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = (0 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[0]);\n  dst.byte[1] = (1 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[1]);\n  dst.byte[2] = (2 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[2]);\n  dst.byte[3] = (3 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[3]);\n  dst.byte[4] = (4 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[4]);\n  dst.byte[5] = (5 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[5]);\n  dst.byte[6] = (6 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[6]);\n  dst.byte[7] = (7 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[7]);\n  dst.byte[8] = (8 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[8]);\n  dst.byte[9] = (9 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[9]);\n  dst.byte[10] = (10 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[10]);\n  dst.byte[11] = (11 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[11]);\n  dst.byte[12] = (12 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[12]);\n  dst.byte[13] = (13 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[13]);\n  dst.byte[14] = (14 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[14]);\n  dst.byte[15] = (15 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vextrins_d (__m128i a, __m128i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vextrins_d (__m128i a, __m128i b, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vextrins.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtract one 64-bit element in `b` and insert it to `a` according to `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i == ((imm >> 4) & 1)) ? b.dword[imm & 1] : a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (0 == ((imm >> 4) & 1)) ? (b.dword[imm & 1]) : (a.dword[0]);\n  dst.dword[1] = (1 == ((imm >> 4) & 1)) ? (b.dword[imm & 1]) : (a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vextrins_d (__m128i a, __m128i b, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vextrins.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extract one 64-bit element in <code>b</code> and insert it to <code>a</code> according to <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i == ((imm &gt;&gt; 4) &amp; 1)) ? b.dword[imm &amp; 1] : a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (0 == ((imm &gt;&gt; 4) &amp; 1)) ? (b.dword[imm &amp; 1]) : (a.dword[0]);\n  dst.dword[1] = (1 == ((imm &gt;&gt; 4) &amp; 1)) ? (b.dword[imm &amp; 1]) : (a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vextrins_h (__m128i a, __m128i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vextrins_h (__m128i a, __m128i b, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vextrins.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtract one 16-bit element in `b` and insert it to `a` according to `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i == ((imm >> 4) & 7)) ? b.half[imm & 7] : a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (0 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[0]);\n  dst.half[1] = (1 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[1]);\n  dst.half[2] = (2 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[2]);\n  dst.half[3] = (3 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[3]);\n  dst.half[4] = (4 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[4]);\n  dst.half[5] = (5 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[5]);\n  dst.half[6] = (6 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[6]);\n  dst.half[7] = (7 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vextrins_h (__m128i a, __m128i b, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vextrins.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extract one 16-bit element in <code>b</code> and insert it to <code>a</code> according to <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i == ((imm &gt;&gt; 4) &amp; 7)) ? b.half[imm &amp; 7] : a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (0 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[0]);\n  dst.half[1] = (1 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[1]);\n  dst.half[2] = (2 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[2]);\n  dst.half[3] = (3 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[3]);\n  dst.half[4] = (4 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[4]);\n  dst.half[5] = (5 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[5]);\n  dst.half[6] = (6 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[6]);\n  dst.half[7] = (7 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vextrins_w (__m128i a, __m128i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vextrins_w (__m128i a, __m128i b, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vextrins.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtract one 32-bit element in `b` and insert it to `a` according to `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i == ((imm >> 4) & 3)) ? b.word[imm & 3] : a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (0 == ((imm >> 4) & 3)) ? (b.word[imm & 3]) : (a.word[0]);\n  dst.word[1] = (1 == ((imm >> 4) & 3)) ? (b.word[imm & 3]) : (a.word[1]);\n  dst.word[2] = (2 == ((imm >> 4) & 3)) ? (b.word[imm & 3]) : (a.word[2]);\n  dst.word[3] = (3 == ((imm >> 4) & 3)) ? (b.word[imm & 3]) : (a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vextrins_w (__m128i a, __m128i b, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vextrins.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extract one 32-bit element in <code>b</code> and insert it to <code>a</code> according to <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i == ((imm &gt;&gt; 4) &amp; 3)) ? b.word[imm &amp; 3] : a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (0 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[imm &amp; 3]) : (a.word[0]);\n  dst.word[1] = (1 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[imm &amp; 3]) : (a.word[1]);\n  dst.word[2] = (2 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[imm &amp; 3]) : (a.word[2]);\n  dst.word[3] = (3 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[imm &amp; 3]) : (a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfclass_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfclass_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vfclass.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nClassifiy each double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = fp_classify(a.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfclass_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfclass.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Classifiy each double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = fp_classify(a.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfclass_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfclass_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vfclass.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nClassifiy each single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = fp_classify(a.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfclass_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfclass.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Classifiy each single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = fp_classify(a.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_caf_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_caf_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.caf.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if AF(Always False), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_caf(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_caf_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.caf.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if AF(Always False), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_caf(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_caf_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_caf_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.caf.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if AF(Always False), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_caf(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_caf_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.caf.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if AF(Always False), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_caf(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_ceq_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_ceq_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.ceq.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_ceq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_ceq_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.ceq.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_ceq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_ceq_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_ceq_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.ceq.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_ceq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_ceq_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.ceq.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_ceq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cle_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cle_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cle.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_cle(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cle_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cle.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_cle(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cle_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cle_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cle.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cle(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cle_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cle.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cle(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_clt_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_clt_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.clt.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if LT(Less than), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_clt(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_clt_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.clt.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LT(Less than), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_clt(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_clt_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_clt_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.clt.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if LT(Less than), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_clt(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_clt_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.clt.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LT(Less than), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_clt(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cne_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cne_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cne.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_cne(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cne_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cne.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_cne(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cne_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cne_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cne.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cne(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cne_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cne.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cne(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cor_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cor_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cor.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_cor(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cor_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cor.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_cor(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cor_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cor_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cor.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cor(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cor_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cor.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cor(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cueq_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cueq_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cueq.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_cueq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cueq_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cueq.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_cueq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cueq_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cueq_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cueq.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cueq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cueq_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cueq.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cueq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cule_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cule_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cule.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_cule(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cule_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cule.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_cule(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cule_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cule_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cule.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cule(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cule_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cule.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cule(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cult_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cult_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cult.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_cult(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cult_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cult.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_cult(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cult_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cult_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cult.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cult(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cult_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cult.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cult(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cun_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cun_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cun.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_cun(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cun_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cun.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_cun(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cun_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cun_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cun.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cun(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cun_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cun.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cun(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cune_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cune_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cune.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_cune(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cune_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cune.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_cune(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_cune_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_cune_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.cune.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cune(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_cune_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.cune.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cune(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_saf_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_saf_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.saf.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if AF(Always False), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_saf(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_saf_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.saf.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if AF(Always False), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_saf(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_saf_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_saf_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.saf.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if AF(Always False), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_saf(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_saf_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.saf.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if AF(Always False), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_saf(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_seq_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_seq_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.seq.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_seq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_seq_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.seq.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_seq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_seq_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_seq_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.seq.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_seq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_seq_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.seq.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_seq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sle_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sle_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sle.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_sle(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sle_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sle.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_sle(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sle_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sle_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sle.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sle(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sle_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sle.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sle(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_slt_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_slt_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.slt.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if LT(Less than), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_slt(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_slt_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.slt.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LT(Less than), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_slt(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_slt_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_slt_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.slt.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if LT(Less than), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_slt(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_slt_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.slt.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LT(Less than), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_slt(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sne_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sne_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sne.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_sne(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sne_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sne.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_sne(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sne_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sne_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sne.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sne(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sne_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sne.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sne(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sor_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sor_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sor.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_sor(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sor_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sor.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_sor(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sor_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sor_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sor.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sor(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sor_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sor.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sor(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sueq_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sueq_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sueq.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_sueq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sueq_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sueq.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_sueq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sueq_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sueq_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sueq.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sueq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sueq_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sueq.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sueq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sule_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sule_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sule.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_sule(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sule_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sule.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_sule(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sule_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sule_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sule.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sule(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sule_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sule.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sule(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sult_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sult_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sult.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_sult(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sult_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sult.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_sult(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sult_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sult_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sult.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sult(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sult_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sult.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sult(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sun_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sun_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sun.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_sun(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sun_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sun.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_sun(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sun_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sun_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sun.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sun(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sun_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sun.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sun(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sune_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sune_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sune.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (fp_compare_sune(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sune_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sune.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (fp_compare_sune(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcmp_sune_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcmp_sune_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcmp.sune.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sune(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcmp_sune_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcmp.sune.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sune(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfcvt_h_s (__m128 a, __m128 b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfcvt_h_s (__m128 a, __m128 b)\n#include <lsxintrin.h>\nInstruction: vfcvt.h.s vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single precision floating point elements in `a` and `b` to half precision.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.fp16[i] = b.fp32[i];\n}\nfor (; i < 8; i++) {\n  dst.fp16[i] = a.fp32[i - 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp16[0] = b.fp32[0];\n  dst.fp16[1] = b.fp32[1];\n  dst.fp16[2] = b.fp32[2];\n  dst.fp16[3] = b.fp32[3];\n  dst.fp16[4] = a.fp32[0];\n  dst.fp16[5] = a.fp32[1];\n  dst.fp16[6] = a.fp32[2];\n  dst.fp16[7] = a.fp32[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfcvt_h_s (__m128 a, __m128 b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfcvt.h.s vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single precision floating point elements in <code>a</code> and <code>b</code> to half precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.fp16[i] = b.fp32[i];\n}\nfor (; i &lt; 8; i++) {\n  dst.fp16[i] = a.fp32[i - 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp16[0] = b.fp32[0];\n  dst.fp16[1] = b.fp32[1];\n  dst.fp16[2] = b.fp32[2];\n  dst.fp16[3] = b.fp32[3];\n  dst.fp16[4] = a.fp32[0];\n  dst.fp16[5] = a.fp32[1];\n  dst.fp16[6] = a.fp32[2];\n  dst.fp16[7] = a.fp32[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfrstp_b (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfrstp_b (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vfrstp.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nFind the first negative 8-bit element in `b`, set the index of the element to the lane of `a` specified by `c`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i];\n}\nint i;\nfor (i = 0; i < 16; i++) {\n  if ((s8)b.byte[i] < 0) {\n    break;\n  }\n}\ndst.byte[c.byte[0] % 16] = i;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfrstp_b (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrstp.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Find the first negative 8-bit element in <code>b</code>, set the index of the element to the lane of <code>a</code> specified by <code>c</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i];\n}\nint i;\nfor (i = 0; i &lt; 16; i++) {\n  if ((s8)b.byte[i] &lt; 0) {\n    break;\n  }\n}\ndst.byte[c.byte[0] % 16] = i;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfrstp_h (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfrstp_h (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vfrstp.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nFind the first negative 16-bit element in `b`, set the index of the element to the lane of `a` specified by `c`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i];\n}\nint i;\nfor (i = 0; i < 8; i++) {\n  if ((s16)b.half[i] < 0) {\n    break;\n  }\n}\ndst.half[c.half[0] % 8] = i;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfrstp_h (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrstp.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Find the first negative 16-bit element in <code>b</code>, set the index of the element to the lane of <code>a</code> specified by <code>c</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i];\n}\nint i;\nfor (i = 0; i &lt; 8; i++) {\n  if ((s16)b.half[i] &lt; 0) {\n    break;\n  }\n}\ndst.half[c.half[0] % 8] = i;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfrstpi_b (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfrstpi_b (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vfrstpi.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nFind the first negative 8-bit element in `b`, set the index of the element to the lane of `a` specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i];\n}\nint i;\nfor (i = 0; i < 16; i++) {\n  if ((s8)b.byte[i] < 0) {\n    break;\n  }\n}\ndst.byte[imm % 16] = i;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfrstpi_b (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrstpi.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Find the first negative 8-bit element in <code>b</code>, set the index of the element to the lane of <code>a</code> specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i];\n}\nint i;\nfor (i = 0; i &lt; 16; i++) {\n  if ((s8)b.byte[i] &lt; 0) {\n    break;\n  }\n}\ndst.byte[imm % 16] = i;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vfrstpi_h (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vfrstpi_h (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vfrstpi.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nFind the first negative 16-bit element in `b`, set the index of the element to the lane of `a` specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i];\n}\nint i;\nfor (i = 0; i < 8; i++) {\n  if ((s16)b.half[i] < 0) {\n    break;\n  }\n}\ndst.half[imm % 8] = i;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vfrstpi_h (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vfrstpi.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Find the first negative 16-bit element in <code>b</code>, set the index of the element to the lane of <code>a</code> specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i];\n}\nint i;\nfor (i = 0; i &lt; 8; i++) {\n  if ((s16)b.half[i] &lt; 0) {\n    break;\n  }\n}\ndst.half[imm % 8] = i;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftint_l_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftint_l_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vftint.l.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftint_l_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftint.l.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftint_lu_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftint_lu_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vftint.lu.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to unsigned 64-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftint_lu_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftint.lu.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to unsigned 64-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftint_w_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftint_w_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vftint.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftint_w_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftint.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftint_w_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftint_w_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftint.w.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftint_w_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftint.w.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftint_wu_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftint_wu_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftint.wu.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to unsigned 32-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftint_wu_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftint.wu.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to unsigned 32-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftinth_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftinth_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftinth.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftinth_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftinth.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintl_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintl_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintl.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintl_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintl.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrm_l_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrm_l_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vftintrm.l.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrm_l_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrm.l.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrm_w_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrm_w_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vftintrm.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrm_w_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrm.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrm_w_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrm_w_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrm.w.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrm_w_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrm.w.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrmh_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrmh_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrmh.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrmh_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrmh.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrml_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrml_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrml.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrml_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrml.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrne_l_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrne_l_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vftintrne.l.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrne_l_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrne.l.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrne_w_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrne_w_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vftintrne.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrne_w_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrne.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrne_w_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrne_w_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrne.w.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrne_w_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrne.w.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrneh_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrneh_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrneh.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrneh_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrneh.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrnel_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrnel_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrnel.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrnel_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrnel.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrp_l_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrp_l_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vftintrp.l.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrp_l_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrp.l.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrp_w_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrp_w_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vftintrp.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrp_w_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrp.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrp_w_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrp_w_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrp.w.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrp_w_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrp.w.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrph_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrph_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrph.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrph_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrph.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrpl_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrpl_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrpl.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrpl_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrpl.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrz_l_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrz_l_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vftintrz.l.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrz_l_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrz.l.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrz_lu_d (__m128d a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrz_lu_d (__m128d a)\n#include <lsxintrin.h>\nInstruction: vftintrz.lu.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to unsigned 64-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrz_lu_d (__m128d a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrz.lu.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to unsigned 64-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrz_w_d (__m128d a, __m128d b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrz_w_d (__m128d a, __m128d b)\n#include <lsxintrin.h>\nInstruction: vftintrz.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrz_w_d (__m128d a, __m128d b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrz.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrz_w_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrz_w_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrz.w.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrz_w_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrz.w.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrz_wu_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrz_wu_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrz.wu.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to unsigned 32-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrz_wu_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrz.wu.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to unsigned 32-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrzh_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrzh_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrzh.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrzh_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrzh.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vftintrzl_l_s (__m128 a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vftintrzl_l_s (__m128 a)\n#include <lsxintrin.h>\nInstruction: vftintrzl.l.s vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |\n| 2K1000LA | LA264 | 5 | 0.5(1/2) |\n| 2K3000 | LA364E | 5 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vftintrzl_l_s (__m128 a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vftintrzl.l.s vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>5</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhaddw_d_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhaddw_d_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhaddw.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned signed 32-bit elements in `a` to even-positioned signed 32-bit elements in `b` to get 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) + ((s64)((s32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhaddw_d_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhaddw.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 32-bit elements in <code>a</code> to even-positioned signed 32-bit elements in <code>b</code> to get 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) + ((s64)((s32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhaddw_du_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhaddw_du_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhaddw.du.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 32-bit elements in `a` to even-positioned unsigned 32-bit elements in `b` to get 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((u64)((u32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhaddw_du_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhaddw.du.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 32-bit elements in <code>a</code> to even-positioned unsigned 32-bit elements in <code>b</code> to get 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((u64)((u32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhaddw_h_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhaddw_h_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhaddw.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned signed 8-bit elements in `a` to even-positioned signed 8-bit elements in `b` to get 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) + ((s16)((s8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhaddw_h_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhaddw.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 8-bit elements in <code>a</code> to even-positioned signed 8-bit elements in <code>b</code> to get 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) + ((s16)((s8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhaddw_hu_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhaddw_hu_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhaddw.hu.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 8-bit elements in `a` to even-positioned unsigned 8-bit elements in `b` to get 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((u16)((u8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhaddw_hu_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhaddw.hu.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 8-bit elements in <code>a</code> to even-positioned unsigned 8-bit elements in <code>b</code> to get 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((u16)((u8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhaddw_q_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhaddw_q_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhaddw.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned signed 64-bit elements in `a` to even-positioned signed 64-bit elements in `b` to get 128-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) + ((s128)((s64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhaddw_q_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhaddw.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 64-bit elements in <code>a</code> to even-positioned signed 64-bit elements in <code>b</code> to get 128-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) + ((s128)((s64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhaddw_qu_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhaddw_qu_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhaddw.qu.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 64-bit elements in `a` to even-positioned unsigned 64-bit elements in `b` to get 128-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((u128)((u64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhaddw_qu_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhaddw.qu.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 64-bit elements in <code>a</code> to even-positioned unsigned 64-bit elements in <code>b</code> to get 128-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((u128)((u64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhaddw_w_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhaddw_w_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhaddw.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned signed 16-bit elements in `a` to even-positioned signed 16-bit elements in `b` to get 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[3])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[5])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[7])) + ((s32)((s16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhaddw_w_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhaddw.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 16-bit elements in <code>a</code> to even-positioned signed 16-bit elements in <code>b</code> to get 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[3])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[5])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[7])) + ((s32)((s16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhaddw_wu_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhaddw_wu_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhaddw.wu.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nAdd odd-positioned unsigned 16-bit elements in `a` to even-positioned unsigned 16-bit elements in `b` to get 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((u32)((u16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhaddw_wu_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhaddw.wu.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 16-bit elements in <code>a</code> to even-positioned unsigned 16-bit elements in <code>b</code> to get 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((u32)((u16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhsubw_d_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhsubw_d_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhsubw.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned signed 32-bit elements in `a` by even-positioned signed 32-bit elements in `b` to get 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] - (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) - ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) - ((s64)((s32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhsubw_d_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhsubw.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 32-bit elements in <code>a</code> by even-positioned signed 32-bit elements in <code>b</code> to get 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] - (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) - ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) - ((s64)((s32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhsubw_du_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhsubw_du_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhsubw.du.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 32-bit elements in `a` by even-positioned unsigned 32-bit elements in `b` to get 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] - (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) - ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) - ((u64)((u32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhsubw_du_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhsubw.du.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 32-bit elements in <code>a</code> by even-positioned unsigned 32-bit elements in <code>b</code> to get 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] - (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) - ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) - ((u64)((u32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhsubw_h_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhsubw_h_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhsubw.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned signed 8-bit elements in `a` by even-positioned signed 8-bit elements in `b` to get 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] - (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) - ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) - ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) - ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) - ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) - ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) - ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) - ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) - ((s16)((s8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhsubw_h_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhsubw.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 8-bit elements in <code>a</code> by even-positioned signed 8-bit elements in <code>b</code> to get 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] - (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) - ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) - ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) - ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) - ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) - ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) - ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) - ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) - ((s16)((s8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhsubw_hu_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhsubw_hu_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhsubw.hu.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 8-bit elements in `a` by even-positioned unsigned 8-bit elements in `b` to get 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] - (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) - ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) - ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) - ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) - ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) - ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) - ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) - ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) - ((u16)((u8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhsubw_hu_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhsubw.hu.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 8-bit elements in <code>a</code> by even-positioned unsigned 8-bit elements in <code>b</code> to get 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] - (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) - ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) - ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) - ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) - ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) - ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) - ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) - ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) - ((u16)((u8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhsubw_q_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhsubw_q_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhsubw.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned signed 64-bit elements in `a` by even-positioned signed 64-bit elements in `b` to get 128-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] - (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) - ((s128)((s64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhsubw_q_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhsubw.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 64-bit elements in <code>a</code> by even-positioned signed 64-bit elements in <code>b</code> to get 128-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] - (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) - ((s128)((s64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhsubw_qu_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhsubw_qu_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhsubw.qu.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 64-bit elements in `a` by even-positioned unsigned 64-bit elements in `b` to get 128-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] - (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) - ((u128)((u64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhsubw_qu_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhsubw.qu.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 64-bit elements in <code>a</code> by even-positioned unsigned 64-bit elements in <code>b</code> to get 128-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] - (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) - ((u128)((u64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhsubw_w_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhsubw_w_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhsubw.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned signed 16-bit elements in `a` by even-positioned signed 16-bit elements in `b` to get 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] - (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) - ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[3])) - ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[5])) - ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[7])) - ((s32)((s16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhsubw_w_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhsubw.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 16-bit elements in <code>a</code> by even-positioned signed 16-bit elements in <code>b</code> to get 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] - (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) - ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[3])) - ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[5])) - ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[7])) - ((s32)((s16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vhsubw_wu_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vhsubw_wu_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vhsubw.wu.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 16-bit elements in `a` by even-positioned unsigned 16-bit elements in `b` to get 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] - (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) - ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[3])) - ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[5])) - ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[7])) - ((u32)((u16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vhsubw_wu_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vhsubw.wu.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 16-bit elements in <code>a</code> by even-positioned unsigned 16-bit elements in <code>b</code> to get 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] - (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) - ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[3])) - ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[5])) - ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[7])) - ((u32)((u16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vilvh_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vilvh_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vilvh.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nInterleave 8-bit elements in higher half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2 + 8] : b.byte[i / 2 + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[8];\n  dst.byte[1] = a.byte[8];\n  dst.byte[2] = b.byte[9];\n  dst.byte[3] = a.byte[9];\n  dst.byte[4] = b.byte[10];\n  dst.byte[5] = a.byte[10];\n  dst.byte[6] = b.byte[11];\n  dst.byte[7] = a.byte[11];\n  dst.byte[8] = b.byte[12];\n  dst.byte[9] = a.byte[12];\n  dst.byte[10] = b.byte[13];\n  dst.byte[11] = a.byte[13];\n  dst.byte[12] = b.byte[14];\n  dst.byte[13] = a.byte[14];\n  dst.byte[14] = b.byte[15];\n  dst.byte[15] = a.byte[15];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vilvh_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vilvh.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 8-bit elements in higher half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2 + 8] : b.byte[i / 2 + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[8];\n  dst.byte[1] = a.byte[8];\n  dst.byte[2] = b.byte[9];\n  dst.byte[3] = a.byte[9];\n  dst.byte[4] = b.byte[10];\n  dst.byte[5] = a.byte[10];\n  dst.byte[6] = b.byte[11];\n  dst.byte[7] = a.byte[11];\n  dst.byte[8] = b.byte[12];\n  dst.byte[9] = a.byte[12];\n  dst.byte[10] = b.byte[13];\n  dst.byte[11] = a.byte[13];\n  dst.byte[12] = b.byte[14];\n  dst.byte[13] = a.byte[14];\n  dst.byte[14] = b.byte[15];\n  dst.byte[15] = a.byte[15];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vilvh_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vilvh_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vilvh.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nInterleave 64-bit elements in higher half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2 + 1] : b.dword[i / 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vilvh_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vilvh.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 64-bit elements in higher half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2 + 1] : b.dword[i / 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vilvh_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vilvh_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vilvh.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nInterleave 16-bit elements in higher half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2 + 4] : b.half[i / 2 + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[4];\n  dst.half[1] = a.half[4];\n  dst.half[2] = b.half[5];\n  dst.half[3] = a.half[5];\n  dst.half[4] = b.half[6];\n  dst.half[5] = a.half[6];\n  dst.half[6] = b.half[7];\n  dst.half[7] = a.half[7];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vilvh_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vilvh.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 16-bit elements in higher half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2 + 4] : b.half[i / 2 + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[4];\n  dst.half[1] = a.half[4];\n  dst.half[2] = b.half[5];\n  dst.half[3] = a.half[5];\n  dst.half[4] = b.half[6];\n  dst.half[5] = a.half[6];\n  dst.half[6] = b.half[7];\n  dst.half[7] = a.half[7];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vilvh_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vilvh_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vilvh.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nInterleave 32-bit elements in higher half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2 + 2] : b.word[i / 2 + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[2];\n  dst.word[1] = a.word[2];\n  dst.word[2] = b.word[3];\n  dst.word[3] = a.word[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vilvh_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vilvh.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 32-bit elements in higher half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2 + 2] : b.word[i / 2 + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[2];\n  dst.word[1] = a.word[2];\n  dst.word[2] = b.word[3];\n  dst.word[3] = a.word[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vilvl_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vilvl_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vilvl.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nInterleave 8-bit elements in lower half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2] : b.byte[i / 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = a.byte[0];\n  dst.byte[2] = b.byte[1];\n  dst.byte[3] = a.byte[1];\n  dst.byte[4] = b.byte[2];\n  dst.byte[5] = a.byte[2];\n  dst.byte[6] = b.byte[3];\n  dst.byte[7] = a.byte[3];\n  dst.byte[8] = b.byte[4];\n  dst.byte[9] = a.byte[4];\n  dst.byte[10] = b.byte[5];\n  dst.byte[11] = a.byte[5];\n  dst.byte[12] = b.byte[6];\n  dst.byte[13] = a.byte[6];\n  dst.byte[14] = b.byte[7];\n  dst.byte[15] = a.byte[7];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vilvl_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vilvl.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 8-bit elements in lower half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2] : b.byte[i / 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = a.byte[0];\n  dst.byte[2] = b.byte[1];\n  dst.byte[3] = a.byte[1];\n  dst.byte[4] = b.byte[2];\n  dst.byte[5] = a.byte[2];\n  dst.byte[6] = b.byte[3];\n  dst.byte[7] = a.byte[3];\n  dst.byte[8] = b.byte[4];\n  dst.byte[9] = a.byte[4];\n  dst.byte[10] = b.byte[5];\n  dst.byte[11] = a.byte[5];\n  dst.byte[12] = b.byte[6];\n  dst.byte[13] = a.byte[6];\n  dst.byte[14] = b.byte[7];\n  dst.byte[15] = a.byte[7];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vilvl_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vilvl_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vilvl.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nInterleave 64-bit elements in lower half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2] : b.dword[i / 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vilvl_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vilvl.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 64-bit elements in lower half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2] : b.dword[i / 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vilvl_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vilvl_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vilvl.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nInterleave 16-bit elements in lower half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2] : b.half[i / 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = a.half[0];\n  dst.half[2] = b.half[1];\n  dst.half[3] = a.half[1];\n  dst.half[4] = b.half[2];\n  dst.half[5] = a.half[2];\n  dst.half[6] = b.half[3];\n  dst.half[7] = a.half[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vilvl_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vilvl.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 16-bit elements in lower half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2] : b.half[i / 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = a.half[0];\n  dst.half[2] = b.half[1];\n  dst.half[3] = a.half[1];\n  dst.half[4] = b.half[2];\n  dst.half[5] = a.half[2];\n  dst.half[6] = b.half[3];\n  dst.half[7] = a.half[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vilvl_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vilvl_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vilvl.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nInterleave 32-bit elements in lower half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2] : b.word[i / 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = a.word[0];\n  dst.word[2] = b.word[1];\n  dst.word[3] = a.word[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vilvl_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vilvl.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 32-bit elements in lower half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2] : b.word[i / 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = a.word[0];\n  dst.word[2] = b.word[1];\n  dst.word[3] = a.word[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vinsgr2vr_b (__m128i a, int b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vinsgr2vr_b (__m128i a, int b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vinsgr2vr.b vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nInsert 8-bit element into lane indexed `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i == imm) ? b : a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vinsgr2vr_b (__m128i a, int b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vinsgr2vr.b vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Insert 8-bit element into lane indexed <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i == imm) ? b : a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vinsgr2vr_d (__m128i a, long int b, imm0_1 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vinsgr2vr_d (__m128i a, long int b, imm0_1 imm)\n#include <lsxintrin.h>\nInstruction: vinsgr2vr.d vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nInsert 64-bit element into lane indexed `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i == imm) ? b : a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vinsgr2vr_d (__m128i a, long int b, imm0_1 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vinsgr2vr.d vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Insert 64-bit element into lane indexed <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i == imm) ? b : a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vinsgr2vr_h (__m128i a, int b, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vinsgr2vr_h (__m128i a, int b, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vinsgr2vr.h vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nInsert 16-bit element into lane indexed `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i == imm) ? b : a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vinsgr2vr_h (__m128i a, int b, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vinsgr2vr.h vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Insert 16-bit element into lane indexed <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i == imm) ? b : a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vinsgr2vr_w (__m128i a, int b, imm0_3 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vinsgr2vr_w (__m128i a, int b, imm0_3 imm)\n#include <lsxintrin.h>\nInstruction: vinsgr2vr.w vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nInsert 32-bit element into lane indexed `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i == imm) ? b : a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vinsgr2vr_w (__m128i a, int b, imm0_3 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vinsgr2vr.w vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Insert 32-bit element into lane indexed <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i == imm) ? b : a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vld (void * addr, imm_n2048_2047 offset)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vld (void * addr, imm_n2048_2047 offset)\n#include <lsxintrin.h>\nInstruction: vld vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRead whole vector from memory address `addr + offset`, save the data into `dst`. Note that you can use this intrinsic to load floating point vectors, even though the return type represents integer vectors.\n\n\n\n\n\n### Operation\n\n```c++\ndst = memory_load(128, addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vld (void * addr, imm_n2048_2047 offset)\n#include &lt;lsxintrin.h&gt;\nInstruction: vld vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read whole vector from memory address <code>addr + offset</code>, save the data into <code>dst</code>. Note that you can use this intrinsic to load floating point vectors, even though the return type represents integer vectors.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = memory_load(128, addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vldi (imm_n1024_1023 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vldi (imm_n1024_1023 imm)\n#include <lsxintrin.h>\nInstruction: vldi vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\n\nInitialize `dst` using predefined patterns:\n\n- `imm[12:10]=0b000`: broadcast `imm[7:0]` as 8-bit elements to all lanes\n- `imm[12:10]=0b001`: broadcast sign-extended `imm[9:0]` as 16-bit elements to all lanes\n- `imm[12:10]=0b010`: broadcast sign-extended `imm[9:0]` as 32-bit elements to all lanes\n- `imm[12:10]=0b011`: broadcast sign-extended `imm[9:0]` as 64-bit elements to all lanes\n- `imm[12:8]=0b10000`: broadcast `imm[7:0]` as 32-bit elements to all lanes\n- `imm[12:8]=0b10001`: broadcast `imm[7:0] << 8` as 32-bit elements to all lanes\n- `imm[12:8]=0b10010`: broadcast `imm[7:0] << 16` as 32-bit elements to all lanes\n- `imm[12:8]=0b10011`: broadcast `imm[7:0] << 24` as 32-bit elements to all lanes\n- `imm[12:8]=0b10100`: broadcast `imm[7:0]` as 16-bit elements to all lanes\n- `imm[12:8]=0b10101`: broadcast `imm[7:0] << 8` as 16-bit elements to all lanes\n- `imm[12:8]=0b10110`: broadcast `(imm[7:0] << 8) | 0xFF` as 32-bit elements to all lanes\n- `imm[12:8]=0b10111`: broadcast `(imm[7:0] << 16) | 0xFFFF` as 32-bit elements to all lanes\n- `imm[12:8]=0b11000`: broadcast `imm[7:0]` as 8-bit elements to all lanes\n- `imm[12:8]=0b11001`: repeat each bit of `imm[7:0]` eight times, and broadcast the result as 64-bit elements to all lanes\n- `imm[12:8]=0b11010`: broadcast `(imm[7] << 31) | ((1-imm[6]) << 30) | ((imm[6] * 0x1F) << 25) | (imm[5:0] << 19)` as 32-bit elements to all lanes\n- `imm[12:8]=0b11011`: broadcast `(imm[7] << 31) | ((1-imm[6]) << 30) | ((imm[6] * 0x1F) << 25) | (imm[5:0] << 19)` as 64-bit elements to all lanes\n- `imm[12:8]=0b11100`: broadcast `(imm[7] << 63) | ((1-imm[6]) << 62) | ((imm[6] * 0xFF) << 54) | (imm[5:0] << 48)` as 64-bit elements to all lanes\n\n\n\n\n\n\n### Operation\n\n```c++\nu64 imm12_10 = (imm >> 10) & 0b111;\nu64 imm12_8 = (imm >> 8) & 0b11111;\nu64 imm9_0 = imm & 0x3FF;\ns64 simm9_0 = ((s64)imm9_0 << 54) >> 54;\nu64 imm7_0 = imm & 0xFF;\nu64 imm7 = (imm >> 7) & 0x1;\nu64 imm6 = (imm >> 6) & 0x1;\nu64 imm5 = (imm >> 5) & 0x1;\nu64 imm5_0 = imm & 0x3F;\nu64 imm4 = (imm >> 4) & 0x1;\nu64 imm3 = (imm >> 3) & 0x1;\nu64 imm2 = (imm >> 2) & 0x1;\nu64 imm1 = (imm >> 1) & 0x1;\nu64 imm0 = imm & 0x1;\n\nu64 broadcast_value;\nu64 broadcast_width;\nif (imm12_10 == 0b000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 8;\n} else if (imm12_10 == 0b001) {\n  broadcast_value = simm9_0;\n  broadcast_width = 16;\n} else if (imm12_10 == 0b010) {\n  broadcast_value = simm9_0;\n  broadcast_width = 32;\n} else if (imm12_10 == 0b011) {\n  broadcast_value = simm9_0;\n  broadcast_width = 64;\n} else if (imm12_8 == 0b10000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10001) {\n  broadcast_value = imm7_0 << 8;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10010) {\n  broadcast_value = imm7_0 << 16;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10011) {\n  broadcast_value = imm7_0 << 24;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10100) {\n  broadcast_value = imm7_0;\n  broadcast_width = 16;\n} else if (imm12_8 == 0b10101) {\n  broadcast_value = imm7_0 << 8;\n  broadcast_width = 16;\n} else if (imm12_8 == 0b10110) {\n  broadcast_value = (imm7_0 << 8) | 0xFF;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10111) {\n  broadcast_value = (imm7_0 << 16) | 0xFFFF;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b11000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 8;\n} else if (imm12_8 == 0b11001) {\n  broadcast_value = imm0 * 0xFF + imm1 * 0xFF00 + imm2 * 0xFF0000 +\n                    imm3 * 0xFF000000 + imm4 * 0xFF00000000 +\n                    imm5 * 0xFF0000000000 + imm6 * 0xFF000000000000 +\n                    imm7 * 0xFF00000000000000;\n  broadcast_width = 64;\n} else if (imm12_8 == 0b11010) {\n  broadcast_value = (imm7 << 31) | ((1 - imm6) << 30) | ((imm6 * 0x1F) << 25) |\n                    (imm5_0 << 19);\n  broadcast_width = 32;\n} else if (imm12_8 == 0b11011) {\n  broadcast_value = (imm7 << 31) | ((1 - imm6) << 30) | ((imm6 * 0x1F) << 25) |\n                    (imm5_0 << 19);\n  broadcast_width = 64;\n} else if (imm12_8 == 0b11100) {\n  broadcast_value = (imm7 << 63) | ((1 - imm6) << 62) | ((imm6 * 0xFF) << 54) |\n                    (imm5_0 << 48);\n  broadcast_width = 64;\n}\n\nif (broadcast_width == 8) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i] = broadcast_value;\n  }\n} else if (broadcast_width == 16) {\n  for (int i = 0; i < 8; i++) {\n    dst.half[i] = broadcast_value;\n  }\n} else if (broadcast_width == 32) {\n  for (int i = 0; i < 4; i++) {\n    dst.word[i] = broadcast_value;\n  }\n} else if (broadcast_width == 64) {\n  for (int i = 0; i < 2; i++) {\n    dst.dword[i] = broadcast_value;\n  }\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vldi (imm_n1024_1023 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldi vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Initialize <code>dst</code> using predefined patterns:</p>\n<ul>\n<li><code>imm[12:10]=0b000</code>: broadcast <code>imm[7:0]</code> as 8-bit elements to all lanes</li>\n<li><code>imm[12:10]=0b001</code>: broadcast sign-extended <code>imm[9:0]</code> as 16-bit elements to all lanes</li>\n<li><code>imm[12:10]=0b010</code>: broadcast sign-extended <code>imm[9:0]</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:10]=0b011</code>: broadcast sign-extended <code>imm[9:0]</code> as 64-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10000</code>: broadcast <code>imm[7:0]</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10001</code>: broadcast <code>imm[7:0] &lt;&lt; 8</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10010</code>: broadcast <code>imm[7:0] &lt;&lt; 16</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10011</code>: broadcast <code>imm[7:0] &lt;&lt; 24</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10100</code>: broadcast <code>imm[7:0]</code> as 16-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10101</code>: broadcast <code>imm[7:0] &lt;&lt; 8</code> as 16-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10110</code>: broadcast <code>(imm[7:0] &lt;&lt; 8) | 0xFF</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10111</code>: broadcast <code>(imm[7:0] &lt;&lt; 16) | 0xFFFF</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11000</code>: broadcast <code>imm[7:0]</code> as 8-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11001</code>: repeat each bit of <code>imm[7:0]</code> eight times, and broadcast the result as 64-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11010</code>: broadcast <code>(imm[7] &lt;&lt; 31) | ((1-imm[6]) &lt;&lt; 30) | ((imm[6] * 0x1F) &lt;&lt; 25) | (imm[5:0] &lt;&lt; 19)</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11011</code>: broadcast <code>(imm[7] &lt;&lt; 31) | ((1-imm[6]) &lt;&lt; 30) | ((imm[6] * 0x1F) &lt;&lt; 25) | (imm[5:0] &lt;&lt; 19)</code> as 64-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11100</code>: broadcast <code>(imm[7] &lt;&lt; 63) | ((1-imm[6]) &lt;&lt; 62) | ((imm[6] * 0xFF) &lt;&lt; 54) | (imm[5:0] &lt;&lt; 48)</code> as 64-bit elements to all lanes</li>\n</ul>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 imm12_10 = (imm &gt;&gt; 10) &amp; 0b111;\nu64 imm12_8 = (imm &gt;&gt; 8) &amp; 0b11111;\nu64 imm9_0 = imm &amp; 0x3FF;\ns64 simm9_0 = ((s64)imm9_0 &lt;&lt; 54) &gt;&gt; 54;\nu64 imm7_0 = imm &amp; 0xFF;\nu64 imm7 = (imm &gt;&gt; 7) &amp; 0x1;\nu64 imm6 = (imm &gt;&gt; 6) &amp; 0x1;\nu64 imm5 = (imm &gt;&gt; 5) &amp; 0x1;\nu64 imm5_0 = imm &amp; 0x3F;\nu64 imm4 = (imm &gt;&gt; 4) &amp; 0x1;\nu64 imm3 = (imm &gt;&gt; 3) &amp; 0x1;\nu64 imm2 = (imm &gt;&gt; 2) &amp; 0x1;\nu64 imm1 = (imm &gt;&gt; 1) &amp; 0x1;\nu64 imm0 = imm &amp; 0x1;\n\nu64 broadcast_value;\nu64 broadcast_width;\nif (imm12_10 == 0b000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 8;\n} else if (imm12_10 == 0b001) {\n  broadcast_value = simm9_0;\n  broadcast_width = 16;\n} else if (imm12_10 == 0b010) {\n  broadcast_value = simm9_0;\n  broadcast_width = 32;\n} else if (imm12_10 == 0b011) {\n  broadcast_value = simm9_0;\n  broadcast_width = 64;\n} else if (imm12_8 == 0b10000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10001) {\n  broadcast_value = imm7_0 &lt;&lt; 8;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10010) {\n  broadcast_value = imm7_0 &lt;&lt; 16;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10011) {\n  broadcast_value = imm7_0 &lt;&lt; 24;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10100) {\n  broadcast_value = imm7_0;\n  broadcast_width = 16;\n} else if (imm12_8 == 0b10101) {\n  broadcast_value = imm7_0 &lt;&lt; 8;\n  broadcast_width = 16;\n} else if (imm12_8 == 0b10110) {\n  broadcast_value = (imm7_0 &lt;&lt; 8) | 0xFF;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10111) {\n  broadcast_value = (imm7_0 &lt;&lt; 16) | 0xFFFF;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b11000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 8;\n} else if (imm12_8 == 0b11001) {\n  broadcast_value = imm0 * 0xFF + imm1 * 0xFF00 + imm2 * 0xFF0000 +\n                    imm3 * 0xFF000000 + imm4 * 0xFF00000000 +\n                    imm5 * 0xFF0000000000 + imm6 * 0xFF000000000000 +\n                    imm7 * 0xFF00000000000000;\n  broadcast_width = 64;\n} else if (imm12_8 == 0b11010) {\n  broadcast_value = (imm7 &lt;&lt; 31) | ((1 - imm6) &lt;&lt; 30) | ((imm6 * 0x1F) &lt;&lt; 25) |\n                    (imm5_0 &lt;&lt; 19);\n  broadcast_width = 32;\n} else if (imm12_8 == 0b11011) {\n  broadcast_value = (imm7 &lt;&lt; 31) | ((1 - imm6) &lt;&lt; 30) | ((imm6 * 0x1F) &lt;&lt; 25) |\n                    (imm5_0 &lt;&lt; 19);\n  broadcast_width = 64;\n} else if (imm12_8 == 0b11100) {\n  broadcast_value = (imm7 &lt;&lt; 63) | ((1 - imm6) &lt;&lt; 62) | ((imm6 * 0xFF) &lt;&lt; 54) |\n                    (imm5_0 &lt;&lt; 48);\n  broadcast_width = 64;\n}\n\nif (broadcast_width == 8) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i] = broadcast_value;\n  }\n} else if (broadcast_width == 16) {\n  for (int i = 0; i &lt; 8; i++) {\n    dst.half[i] = broadcast_value;\n  }\n} else if (broadcast_width == 32) {\n  for (int i = 0; i &lt; 4; i++) {\n    dst.word[i] = broadcast_value;\n  }\n} else if (broadcast_width == 64) {\n  for (int i = 0; i &lt; 2; i++) {\n    dst.dword[i] = broadcast_value;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vldrepl_b (void * addr, imm_n2048_2047 offset)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vldrepl_b (void * addr, imm_n2048_2047 offset)\n#include <lsxintrin.h>\nInstruction: vldrepl.b vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRead 8-bit data from memory address `addr + (offset << 0)`, replicate the data to all vector lanes and save into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nu8 data = memory_load(8, addr + offset);\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = data;\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vldrepl_b (void * addr, imm_n2048_2047 offset)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldrepl.b vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read 8-bit data from memory address <code>addr + (offset &lt;&lt; 0)</code>, replicate the data to all vector lanes and save into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u8 data = memory_load(8, addr + offset);\nfor (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = data;\n}\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vldrepl_d (void * addr, imm_n256_255 offset)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vldrepl_d (void * addr, imm_n256_255 offset)\n#include <lsxintrin.h>\nInstruction: vldrepl.d vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRead 64-bit data from memory address `addr + (offset << 3)`, replicate the data to all vector lanes and save into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nu64 data = memory_load(64, addr + (offset << 3));\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = data;\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vldrepl_d (void * addr, imm_n256_255 offset)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldrepl.d vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read 64-bit data from memory address <code>addr + (offset &lt;&lt; 3)</code>, replicate the data to all vector lanes and save into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 data = memory_load(64, addr + (offset &lt;&lt; 3));\nfor (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = data;\n}\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vldrepl_h (void * addr, imm_n1024_1023 offset)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vldrepl_h (void * addr, imm_n1024_1023 offset)\n#include <lsxintrin.h>\nInstruction: vldrepl.h vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRead 16-bit data from memory address `addr + (offset << 1)`, replicate the data to all vector lanes and save into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nu16 data = memory_load(16, addr + (offset << 1));\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = data;\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vldrepl_h (void * addr, imm_n1024_1023 offset)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldrepl.h vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read 16-bit data from memory address <code>addr + (offset &lt;&lt; 1)</code>, replicate the data to all vector lanes and save into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u16 data = memory_load(16, addr + (offset &lt;&lt; 1));\nfor (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = data;\n}\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vldrepl_w (void * addr, imm_n512_511 offset)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vldrepl_w (void * addr, imm_n512_511 offset)\n#include <lsxintrin.h>\nInstruction: vldrepl.w vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRead 32-bit data from memory address `addr + (offset << 2)`, replicate the data to all vector lanes and save into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nu32 data = memory_load(32, addr + (offset << 2));\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = data;\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vldrepl_w (void * addr, imm_n512_511 offset)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldrepl.w vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read 32-bit data from memory address <code>addr + (offset &lt;&lt; 2)</code>, replicate the data to all vector lanes and save into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u32 data = memory_load(32, addr + (offset &lt;&lt; 2));\nfor (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = data;\n}\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vldx (void * addr, long int offset)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vldx (void * addr, long int offset)\n#include <lsxintrin.h>\nInstruction: vldx vr, r, r\nCPU Flags: LSX\n```\n\n### Description\n\nRead whole vector from memory address `addr + offset`, save the data into `dst`.  Note that you can use this intrinsic to load floating point vectors, even though the return type represents integer vectors.\n\n\n\n\n\n### Operation\n\n```c++\ndst = memory_load(128, addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vldx (void * addr, long int offset)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldx vr, r, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read whole vector from memory address <code>addr + offset</code>, save the data into <code>dst</code>.  Note that you can use this intrinsic to load floating point vectors, even though the return type represents integer vectors.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = memory_load(128, addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmadd_b (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmadd_b (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmadd.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 8-bit elements in `b` and `c`, add to elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = b.byte[i] * c.byte[i] + a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmadd_b (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmadd.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 8-bit elements in <code>b</code> and <code>c</code>, add to elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = b.byte[i] * c.byte[i] + a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmadd_d (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmadd_d (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmadd.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 64-bit elements in `b` and `c`, add to elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = b.dword[i] * c.dword[i] + a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmadd_d (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmadd.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 64-bit elements in <code>b</code> and <code>c</code>, add to elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = b.dword[i] * c.dword[i] + a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmadd_h (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmadd_h (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmadd.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 16-bit elements in `b` and `c`, add to elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = b.half[i] * c.half[i] + a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmadd_h (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmadd.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 16-bit elements in <code>b</code> and <code>c</code>, add to elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = b.half[i] * c.half[i] + a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmadd_w (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmadd_w (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmadd.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 32-bit elements in `b` and `c`, add to elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = b.word[i] * c.word[i] + a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmadd_w (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmadd.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 32-bit elements in <code>b</code> and <code>c</code>, add to elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = b.word[i] * c.word[i] + a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_d_w (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_d_w (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned signed 32-bit elements in `b` and signed elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] =\n      (s64)(s32)b.word[2 * i] * (s64)(s32)c.word[2 * i] + (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((s64)((s32)b.word[0])) * ((s64)((s32)c.word[0]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((s64)((s32)b.word[2])) * ((s64)((s32)c.word[2]))) + ((s64)a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_d_w (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 32-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] =\n      (s64)(s32)b.word[2 * i] * (s64)(s32)c.word[2 * i] + (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((s64)((s32)b.word[0])) * ((s64)((s32)c.word[0]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((s64)((s32)b.word[2])) * ((s64)((s32)c.word[2]))) + ((s64)a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_d_wu (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_d_wu (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.d.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 32-bit elements in `b` and unsigned elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] =\n      (u64)(u32)b.word[2 * i] * (u64)(u32)c.word[2 * i] + (u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[0])) * ((u64)((u32)c.word[0]))) + ((u64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[2])) * ((u64)((u32)c.word[2]))) + ((u64)a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_d_wu (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.d.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 32-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] =\n      (u64)(u32)b.word[2 * i] * (u64)(u32)c.word[2 * i] + (u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[0])) * ((u64)((u32)c.word[0]))) + ((u64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[2])) * ((u64)((u32)c.word[2]))) + ((u64)a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_d_wu_w (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_d_wu_w (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.d.wu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 32-bit elements in `b` and signed elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] =\n      (u64)(u32)b.word[2 * i] * (s64)(s32)c.word[2 * i] + (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[0])) * ((s64)((s32)c.word[0]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[2])) * ((s64)((s32)c.word[2]))) + ((s64)a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_d_wu_w (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.d.wu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 32-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] =\n      (u64)(u32)b.word[2 * i] * (s64)(s32)c.word[2 * i] + (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[0])) * ((s64)((s32)c.word[0]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[2])) * ((s64)((s32)c.word[2]))) + ((s64)a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_h_b (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_h_b (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned signed 8-bit elements in `b` and signed elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (s16)(s8)b.byte[2 * i] * (s16)(s8)c.byte[2 * i] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((s16)((s8)b.byte[0])) * ((s16)((s8)c.byte[0]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((s16)((s8)b.byte[2])) * ((s16)((s8)c.byte[2]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((s16)((s8)b.byte[4])) * ((s16)((s8)c.byte[4]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((s16)((s8)b.byte[6])) * ((s16)((s8)c.byte[6]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((s16)((s8)b.byte[8])) * ((s16)((s8)c.byte[8]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((s16)((s8)b.byte[10])) * ((s16)((s8)c.byte[10]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((s16)((s8)b.byte[12])) * ((s16)((s8)c.byte[12]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((s16)((s8)b.byte[14])) * ((s16)((s8)c.byte[14]))) + ((s16)a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_h_b (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 8-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (s16)(s8)b.byte[2 * i] * (s16)(s8)c.byte[2 * i] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((s16)((s8)b.byte[0])) * ((s16)((s8)c.byte[0]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((s16)((s8)b.byte[2])) * ((s16)((s8)c.byte[2]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((s16)((s8)b.byte[4])) * ((s16)((s8)c.byte[4]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((s16)((s8)b.byte[6])) * ((s16)((s8)c.byte[6]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((s16)((s8)b.byte[8])) * ((s16)((s8)c.byte[8]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((s16)((s8)b.byte[10])) * ((s16)((s8)c.byte[10]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((s16)((s8)b.byte[12])) * ((s16)((s8)c.byte[12]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((s16)((s8)b.byte[14])) * ((s16)((s8)c.byte[14]))) + ((s16)a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_h_bu (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_h_bu (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.h.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 8-bit elements in `b` and unsigned elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i] * (u16)(u8)c.byte[2 * i] + (u16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[0])) * ((u16)((u8)c.byte[0]))) + ((u16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[2])) * ((u16)((u8)c.byte[2]))) + ((u16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[4])) * ((u16)((u8)c.byte[4]))) + ((u16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[6])) * ((u16)((u8)c.byte[6]))) + ((u16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[8])) * ((u16)((u8)c.byte[8]))) + ((u16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[10])) * ((u16)((u8)c.byte[10]))) + ((u16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[12])) * ((u16)((u8)c.byte[12]))) + ((u16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[14])) * ((u16)((u8)c.byte[14]))) + ((u16)a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_h_bu (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.h.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 8-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i] * (u16)(u8)c.byte[2 * i] + (u16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[0])) * ((u16)((u8)c.byte[0]))) + ((u16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[2])) * ((u16)((u8)c.byte[2]))) + ((u16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[4])) * ((u16)((u8)c.byte[4]))) + ((u16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[6])) * ((u16)((u8)c.byte[6]))) + ((u16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[8])) * ((u16)((u8)c.byte[8]))) + ((u16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[10])) * ((u16)((u8)c.byte[10]))) + ((u16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[12])) * ((u16)((u8)c.byte[12]))) + ((u16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[14])) * ((u16)((u8)c.byte[14]))) + ((u16)a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_h_bu_b (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_h_bu_b (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.h.bu.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 8-bit elements in `b` and signed elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i] * (s16)(s8)c.byte[2 * i] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[0])) * ((s16)((s8)c.byte[0]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[2])) * ((s16)((s8)c.byte[2]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[4])) * ((s16)((s8)c.byte[4]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[6])) * ((s16)((s8)c.byte[6]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[8])) * ((s16)((s8)c.byte[8]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[10])) * ((s16)((s8)c.byte[10]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[12])) * ((s16)((s8)c.byte[12]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[14])) * ((s16)((s8)c.byte[14]))) + ((s16)a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_h_bu_b (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.h.bu.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 8-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i] * (s16)(s8)c.byte[2 * i] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[0])) * ((s16)((s8)c.byte[0]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[2])) * ((s16)((s8)c.byte[2]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[4])) * ((s16)((s8)c.byte[4]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[6])) * ((s16)((s8)c.byte[6]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[8])) * ((s16)((s8)c.byte[8]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[10])) * ((s16)((s8)c.byte[10]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[12])) * ((s16)((s8)c.byte[12]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[14])) * ((s16)((s8)c.byte[14]))) + ((s16)a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_q_d (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_q_d (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned signed 64-bit elements in `b` and signed elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] =\n      (s128)(s64)b.dword[2 * i] * (s128)(s64)c.dword[2 * i] + (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((s128)((s64)b.dword[0])) * ((s128)((s64)c.dword[0]))) +\n                 ((s128)a.qword[0]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_q_d (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 64-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] =\n      (s128)(s64)b.dword[2 * i] * (s128)(s64)c.dword[2 * i] + (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((s128)((s64)b.dword[0])) * ((s128)((s64)c.dword[0]))) +\n                 ((s128)a.qword[0]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_q_du (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_q_du (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.q.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 64-bit elements in `b` and unsigned elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] =\n      (u128)(u64)b.dword[2 * i] * (u128)(u64)c.dword[2 * i] + (u128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[0])) * ((u128)((u64)c.dword[0]))) +\n                 ((u128)a.qword[0]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_q_du (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.q.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 64-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] =\n      (u128)(u64)b.dword[2 * i] * (u128)(u64)c.dword[2 * i] + (u128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[0])) * ((u128)((u64)c.dword[0]))) +\n                 ((u128)a.qword[0]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_q_du_d (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_q_du_d (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.q.du.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 64-bit elements in `b` and signed elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] =\n      (u128)(u64)b.dword[2 * i] * (s128)(s64)c.dword[2 * i] + (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[0])) * ((s128)((s64)c.dword[0]))) +\n                 ((s128)a.qword[0]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_q_du_d (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.q.du.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 64-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] =\n      (u128)(u64)b.dword[2 * i] * (s128)(s64)c.dword[2 * i] + (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[0])) * ((s128)((s64)c.dword[0]))) +\n                 ((s128)a.qword[0]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_w_h (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_w_h (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned signed 16-bit elements in `b` and signed elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] =\n      (s32)(s16)b.half[2 * i] * (s32)(s16)c.half[2 * i] + (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((s32)((s16)b.half[0])) * ((s32)((s16)c.half[0]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((s32)((s16)b.half[2])) * ((s32)((s16)c.half[2]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((s32)((s16)b.half[4])) * ((s32)((s16)c.half[4]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((s32)((s16)b.half[6])) * ((s32)((s16)c.half[6]))) + ((s32)a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_w_h (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 16-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] =\n      (s32)(s16)b.half[2 * i] * (s32)(s16)c.half[2 * i] + (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((s32)((s16)b.half[0])) * ((s32)((s16)c.half[0]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((s32)((s16)b.half[2])) * ((s32)((s16)c.half[2]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((s32)((s16)b.half[4])) * ((s32)((s16)c.half[4]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((s32)((s16)b.half[6])) * ((s32)((s16)c.half[6]))) + ((s32)a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_w_hu (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_w_hu (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.w.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 16-bit elements in `b` and unsigned elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] =\n      (u32)(u16)b.half[2 * i] * (u32)(u16)c.half[2 * i] + (u32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[0])) * ((u32)((u16)c.half[0]))) + ((u32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[2])) * ((u32)((u16)c.half[2]))) + ((u32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[4])) * ((u32)((u16)c.half[4]))) + ((u32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[6])) * ((u32)((u16)c.half[6]))) + ((u32)a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_w_hu (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.w.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 16-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] =\n      (u32)(u16)b.half[2 * i] * (u32)(u16)c.half[2 * i] + (u32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[0])) * ((u32)((u16)c.half[0]))) + ((u32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[2])) * ((u32)((u16)c.half[2]))) + ((u32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[4])) * ((u32)((u16)c.half[4]))) + ((u32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[6])) * ((u32)((u16)c.half[6]))) + ((u32)a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwev_w_hu_h (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwev_w_hu_h (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwev.w.hu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 16-bit elements in `b` and signed elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] =\n      (u32)(u16)b.half[2 * i] * (s32)(s16)c.half[2 * i] + (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[0])) * ((s32)((s16)c.half[0]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[2])) * ((s32)((s16)c.half[2]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[4])) * ((s32)((s16)c.half[4]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[6])) * ((s32)((s16)c.half[6]))) + ((s32)a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwev_w_hu_h (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwev.w.hu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 16-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] =\n      (u32)(u16)b.half[2 * i] * (s32)(s16)c.half[2 * i] + (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[0])) * ((s32)((s16)c.half[0]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[2])) * ((s32)((s16)c.half[2]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[4])) * ((s32)((s16)c.half[4]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[6])) * ((s32)((s16)c.half[6]))) + ((s32)a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_d_w (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_d_w (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned signed 32-bit elements in `b` and signed elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)b.word[2 * i + 1] * (s64)(s32)c.word[2 * i + 1] +\n                 (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((s64)((s32)b.word[1])) * ((s64)((s32)c.word[1]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((s64)((s32)b.word[3])) * ((s64)((s32)c.word[3]))) + ((s64)a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_d_w (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 32-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)b.word[2 * i + 1] * (s64)(s32)c.word[2 * i + 1] +\n                 (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((s64)((s32)b.word[1])) * ((s64)((s32)c.word[1]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((s64)((s32)b.word[3])) * ((s64)((s32)c.word[3]))) + ((s64)a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_d_wu (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_d_wu (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.d.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 32-bit elements in `b` and unsigned elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)b.word[2 * i + 1] * (u64)(u32)c.word[2 * i + 1] +\n                 (u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[1])) * ((u64)((u32)c.word[1]))) + ((u64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[3])) * ((u64)((u32)c.word[3]))) + ((u64)a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_d_wu (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.d.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 32-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)b.word[2 * i + 1] * (u64)(u32)c.word[2 * i + 1] +\n                 (u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[1])) * ((u64)((u32)c.word[1]))) + ((u64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[3])) * ((u64)((u32)c.word[3]))) + ((u64)a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_d_wu_w (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_d_wu_w (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.d.wu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 32-bit elements in `b` and signed elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)b.word[2 * i + 1] * (s64)(s32)c.word[2 * i + 1] +\n                 (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[1])) * ((s64)((s32)c.word[1]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[3])) * ((s64)((s32)c.word[3]))) + ((s64)a.dword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_d_wu_w (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.d.wu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 32-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)b.word[2 * i + 1] * (s64)(s32)c.word[2 * i + 1] +\n                 (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[1])) * ((s64)((s32)c.word[1]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[3])) * ((s64)((s32)c.word[3]))) + ((s64)a.dword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_h_b (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_h_b (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned signed 8-bit elements in `b` and signed elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (s16)(s8)b.byte[2 * i + 1] * (s16)(s8)c.byte[2 * i + 1] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((s16)((s8)b.byte[1])) * ((s16)((s8)c.byte[1]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((s16)((s8)b.byte[3])) * ((s16)((s8)c.byte[3]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((s16)((s8)b.byte[5])) * ((s16)((s8)c.byte[5]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((s16)((s8)b.byte[7])) * ((s16)((s8)c.byte[7]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((s16)((s8)b.byte[9])) * ((s16)((s8)c.byte[9]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((s16)((s8)b.byte[11])) * ((s16)((s8)c.byte[11]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((s16)((s8)b.byte[13])) * ((s16)((s8)c.byte[13]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((s16)((s8)b.byte[15])) * ((s16)((s8)c.byte[15]))) + ((s16)a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_h_b (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 8-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (s16)(s8)b.byte[2 * i + 1] * (s16)(s8)c.byte[2 * i + 1] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((s16)((s8)b.byte[1])) * ((s16)((s8)c.byte[1]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((s16)((s8)b.byte[3])) * ((s16)((s8)c.byte[3]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((s16)((s8)b.byte[5])) * ((s16)((s8)c.byte[5]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((s16)((s8)b.byte[7])) * ((s16)((s8)c.byte[7]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((s16)((s8)b.byte[9])) * ((s16)((s8)c.byte[9]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((s16)((s8)b.byte[11])) * ((s16)((s8)c.byte[11]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((s16)((s8)b.byte[13])) * ((s16)((s8)c.byte[13]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((s16)((s8)b.byte[15])) * ((s16)((s8)c.byte[15]))) + ((s16)a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_h_bu (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_h_bu (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.h.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 8-bit elements in `b` and unsigned elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i + 1] * (u16)(u8)c.byte[2 * i + 1] + (u16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[1])) * ((u16)((u8)c.byte[1]))) + ((u16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[3])) * ((u16)((u8)c.byte[3]))) + ((u16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[5])) * ((u16)((u8)c.byte[5]))) + ((u16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[7])) * ((u16)((u8)c.byte[7]))) + ((u16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[9])) * ((u16)((u8)c.byte[9]))) + ((u16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[11])) * ((u16)((u8)c.byte[11]))) + ((u16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[13])) * ((u16)((u8)c.byte[13]))) + ((u16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[15])) * ((u16)((u8)c.byte[15]))) + ((u16)a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_h_bu (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.h.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 8-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i + 1] * (u16)(u8)c.byte[2 * i + 1] + (u16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[1])) * ((u16)((u8)c.byte[1]))) + ((u16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[3])) * ((u16)((u8)c.byte[3]))) + ((u16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[5])) * ((u16)((u8)c.byte[5]))) + ((u16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[7])) * ((u16)((u8)c.byte[7]))) + ((u16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[9])) * ((u16)((u8)c.byte[9]))) + ((u16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[11])) * ((u16)((u8)c.byte[11]))) + ((u16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[13])) * ((u16)((u8)c.byte[13]))) + ((u16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[15])) * ((u16)((u8)c.byte[15]))) + ((u16)a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_h_bu_b (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_h_bu_b (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.h.bu.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 8-bit elements in `b` and signed elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i + 1] * (s16)(s8)c.byte[2 * i + 1] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[1])) * ((s16)((s8)c.byte[1]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[3])) * ((s16)((s8)c.byte[3]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[5])) * ((s16)((s8)c.byte[5]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[7])) * ((s16)((s8)c.byte[7]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[9])) * ((s16)((s8)c.byte[9]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[11])) * ((s16)((s8)c.byte[11]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[13])) * ((s16)((s8)c.byte[13]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[15])) * ((s16)((s8)c.byte[15]))) + ((s16)a.half[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_h_bu_b (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.h.bu.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 8-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i + 1] * (s16)(s8)c.byte[2 * i + 1] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[1])) * ((s16)((s8)c.byte[1]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[3])) * ((s16)((s8)c.byte[3]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[5])) * ((s16)((s8)c.byte[5]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[7])) * ((s16)((s8)c.byte[7]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[9])) * ((s16)((s8)c.byte[9]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[11])) * ((s16)((s8)c.byte[11]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[13])) * ((s16)((s8)c.byte[13]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[15])) * ((s16)((s8)c.byte[15]))) + ((s16)a.half[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_q_d (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_q_d (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned signed 64-bit elements in `b` and signed elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)b.dword[2 * i + 1] * (s128)(s64)c.dword[2 * i + 1] +\n                 (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((s128)((s64)b.dword[1])) * ((s128)((s64)c.dword[1]))) +\n                 ((s128)a.qword[0]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_q_d (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 64-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)b.dword[2 * i + 1] * (s128)(s64)c.dword[2 * i + 1] +\n                 (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((s128)((s64)b.dword[1])) * ((s128)((s64)c.dword[1]))) +\n                 ((s128)a.qword[0]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_q_du (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_q_du (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.q.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 64-bit elements in `b` and unsigned elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)b.dword[2 * i + 1] * (u128)(u64)c.dword[2 * i + 1] +\n                 (u128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[1])) * ((u128)((u64)c.dword[1]))) +\n                 ((u128)a.qword[0]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_q_du (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.q.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 64-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)b.dword[2 * i + 1] * (u128)(u64)c.dword[2 * i + 1] +\n                 (u128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[1])) * ((u128)((u64)c.dword[1]))) +\n                 ((u128)a.qword[0]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_q_du_d (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_q_du_d (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.q.du.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 64-bit elements in `b` and signed elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)b.dword[2 * i + 1] * (s128)(s64)c.dword[2 * i + 1] +\n                 (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[1])) * ((s128)((s64)c.dword[1]))) +\n                 ((s128)a.qword[0]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_q_du_d (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.q.du.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 64-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)b.dword[2 * i + 1] * (s128)(s64)c.dword[2 * i + 1] +\n                 (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[1])) * ((s128)((s64)c.dword[1]))) +\n                 ((s128)a.qword[0]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_w_h (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_w_h (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned signed 16-bit elements in `b` and signed elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)b.half[2 * i + 1] * (s32)(s16)c.half[2 * i + 1] +\n                (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((s32)((s16)b.half[1])) * ((s32)((s16)c.half[1]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((s32)((s16)b.half[3])) * ((s32)((s16)c.half[3]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((s32)((s16)b.half[5])) * ((s32)((s16)c.half[5]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((s32)((s16)b.half[7])) * ((s32)((s16)c.half[7]))) + ((s32)a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_w_h (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 16-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)b.half[2 * i + 1] * (s32)(s16)c.half[2 * i + 1] +\n                (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((s32)((s16)b.half[1])) * ((s32)((s16)c.half[1]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((s32)((s16)b.half[3])) * ((s32)((s16)c.half[3]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((s32)((s16)b.half[5])) * ((s32)((s16)c.half[5]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((s32)((s16)b.half[7])) * ((s32)((s16)c.half[7]))) + ((s32)a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_w_hu (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_w_hu (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.w.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 16-bit elements in `b` and unsigned elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)b.half[2 * i + 1] * (u32)(u16)c.half[2 * i + 1] +\n                (u32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[1])) * ((u32)((u16)c.half[1]))) + ((u32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[3])) * ((u32)((u16)c.half[3]))) + ((u32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[5])) * ((u32)((u16)c.half[5]))) + ((u32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[7])) * ((u32)((u16)c.half[7]))) + ((u32)a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_w_hu (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.w.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 16-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)b.half[2 * i + 1] * (u32)(u16)c.half[2 * i + 1] +\n                (u32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[1])) * ((u32)((u16)c.half[1]))) + ((u32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[3])) * ((u32)((u16)c.half[3]))) + ((u32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[5])) * ((u32)((u16)c.half[5]))) + ((u32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[7])) * ((u32)((u16)c.half[7]))) + ((u32)a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaddwod_w_hu_h (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaddwod_w_hu_h (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmaddwod.w.hu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 16-bit elements in `b` and signed elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)b.half[2 * i + 1] * (s32)(s16)c.half[2 * i + 1] +\n                (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[1])) * ((s32)((s16)c.half[1]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[3])) * ((s32)((s16)c.half[3]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[5])) * ((s32)((s16)c.half[5]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[7])) * ((s32)((s16)c.half[7]))) + ((s32)a.word[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaddwod_w_hu_h (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaddwod.w.hu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 16-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)b.half[2 * i + 1] * (s32)(s16)c.half[2 * i + 1] +\n                (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[1])) * ((s32)((s16)c.half[1]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[3])) * ((s32)((s16)c.half[3]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[5])) * ((s32)((s16)c.half[5]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[7])) * ((s32)((s16)c.half[7]))) + ((s32)a.word[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmax_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmax_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmax.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for signed 8-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = max((s8)a.byte[i], (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmax_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmax.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 8-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = max((s8)a.byte[i], (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmax_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmax_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmax.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 8-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = max((u8)a.byte[i], (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmax_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmax.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 8-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = max((u8)a.byte[i], (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmax_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmax_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmax.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for signed 64-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = max((s64)a.dword[i], (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmax_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmax.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 64-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = max((s64)a.dword[i], (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmax_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmax_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmax.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 64-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = max((u64)a.dword[i], (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmax_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmax.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 64-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = max((u64)a.dword[i], (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmax_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmax_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmax.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for signed 16-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = max((s16)a.half[i], (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmax_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmax.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 16-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = max((s16)a.half[i], (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmax_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmax_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmax.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 16-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = max((u16)a.half[i], (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmax_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmax.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 16-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = max((u16)a.half[i], (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmax_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmax_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmax.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for signed 32-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = max((s32)a.word[i], (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmax_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmax.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 32-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = max((s32)a.word[i], (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmax_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmax_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmax.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 32-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = max((u32)a.word[i], (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmax_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmax.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 32-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = max((u32)a.word[i], (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaxi_b (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaxi_b (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vmaxi.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for signed 8-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = max((s8)a.byte[i], (s8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaxi_b (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaxi.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 8-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = max((s8)a.byte[i], (s8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaxi_bu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaxi_bu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vmaxi.bu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 8-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = max((u8)a.byte[i], (u8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaxi_bu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaxi.bu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 8-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = max((u8)a.byte[i], (u8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaxi_d (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaxi_d (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vmaxi.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for signed 64-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = max((s64)a.dword[i], (s64)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaxi_d (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaxi.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 64-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = max((s64)a.dword[i], (s64)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaxi_du (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaxi_du (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vmaxi.du vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 64-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = max((u64)a.dword[i], (u64)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaxi_du (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaxi.du vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 64-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = max((u64)a.dword[i], (u64)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaxi_h (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaxi_h (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vmaxi.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for signed 16-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = max((s16)a.half[i], (s16)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaxi_h (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaxi.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 16-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = max((s16)a.half[i], (s16)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaxi_hu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaxi_hu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vmaxi.hu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 16-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = max((u16)a.half[i], (u16)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaxi_hu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaxi.hu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 16-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = max((u16)a.half[i], (u16)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaxi_w (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaxi_w (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vmaxi.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for signed 32-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = max((s32)a.word[i], (s32)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaxi_w (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaxi.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 32-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = max((s32)a.word[i], (s32)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmaxi_wu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmaxi_wu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vmaxi.wu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 32-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = max((u32)a.word[i], (u32)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmaxi_wu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmaxi.wu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 32-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = max((u32)a.word[i], (u32)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmepatmsk_v (int mode, int uimm5)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmepatmsk_v (int mode, int uimm5)\n#include <lsxintrin.h>\nInstruction: vmepatmsk.v vr, mode, uimm5\nCPU Flags: LSX\n```\n\n### Description\n\nCompute pattern according to `mode`, then add `uimm5` to each element.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vmepatmsk_v(3, 1)\n= 0x0807060504030201 0x100f0e0d0c0b0a09\n```\n\n\n### Operation\n\n```c++\nif (mode == 0b00) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i] = uimm5 + (i % 4); // [0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3]\n  }\n} else if (mode == 0b01) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i] =\n        uimm5 + (i / 4) + (i % 4); // [0 1 2 3 1 2 3 4 2 3 4 5 3 4 5 6]\n  }\n} else if (mode == 0b10) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i] =\n        uimm5 + (i / 4) + (i % 4) + 4; // [4 5 6 7 5 6 7 8 6 7 8 9 7 8 9 10]\n  }\n} else if (mode == 0b11) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i] = uimm5 + i; // [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]\n  }\n} else {\n  // illegal instruction\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C6000 | LA664 | N/A | 4 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmepatmsk_v (int mode, int uimm5)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmepatmsk.v vr, mode, uimm5\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute pattern according to <code>mode</code>, then add <code>uimm5</code> to each element.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmepatmsk_v(3, 1)\n= 0x0807060504030201 0x100f0e0d0c0b0a09\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">if (mode == 0b00) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i] = uimm5 + (i % 4); // [0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3]\n  }\n} else if (mode == 0b01) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i] =\n        uimm5 + (i / 4) + (i % 4); // [0 1 2 3 1 2 3 4 2 3 4 5 3 4 5 6]\n  }\n} else if (mode == 0b10) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i] =\n        uimm5 + (i / 4) + (i % 4) + 4; // [4 5 6 7 5 6 7 8 6 7 8 9 7 8 9 10]\n  }\n} else if (mode == 0b11) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i] = uimm5 + i; // [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]\n  }\n} else {\n  // illegal instruction\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Undocumented Intrinsics", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmin_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmin_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmin.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for signed 8-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = min((s8)a.byte[i], (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmin_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmin.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 8-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = min((s8)a.byte[i], (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmin_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmin_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmin.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 8-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = min((u8)a.byte[i], (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmin_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmin.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 8-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = min((u8)a.byte[i], (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmin_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmin_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmin.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for signed 64-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = min((s64)a.dword[i], (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmin_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmin.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 64-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = min((s64)a.dword[i], (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmin_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmin_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmin.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 64-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = min((u64)a.dword[i], (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmin_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmin.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 64-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = min((u64)a.dword[i], (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmin_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmin_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmin.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for signed 16-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = min((s16)a.half[i], (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmin_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmin.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 16-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = min((s16)a.half[i], (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmin_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmin_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmin.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 16-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = min((u16)a.half[i], (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmin_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmin.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 16-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = min((u16)a.half[i], (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmin_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmin_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmin.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for signed 32-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = min((s32)a.word[i], (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmin_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmin.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 32-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = min((s32)a.word[i], (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmin_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmin_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmin.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 32-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = min((u32)a.word[i], (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmin_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmin.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 32-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = min((u32)a.word[i], (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmini_b (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmini_b (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vmini.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for signed 8-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = min((s8)a.byte[i], (s8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmini_b (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmini.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 8-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = min((s8)a.byte[i], (s8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmini_bu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmini_bu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vmini.bu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 8-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = min((u8)a.byte[i], (u8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmini_bu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmini.bu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 8-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = min((u8)a.byte[i], (u8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmini_d (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmini_d (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vmini.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for signed 64-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = min((s64)a.dword[i], (s64)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmini_d (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmini.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 64-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = min((s64)a.dword[i], (s64)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmini_du (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmini_du (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vmini.du vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 64-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = min((u64)a.dword[i], (u64)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmini_du (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmini.du vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 64-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = min((u64)a.dword[i], (u64)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmini_h (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmini_h (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vmini.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for signed 16-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = min((s16)a.half[i], (s16)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmini_h (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmini.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 16-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = min((s16)a.half[i], (s16)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmini_hu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmini_hu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vmini.hu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 16-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = min((u16)a.half[i], (u16)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmini_hu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmini.hu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 16-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = min((u16)a.half[i], (u16)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmini_w (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmini_w (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vmini.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for signed 32-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = min((s32)a.word[i], (s32)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmini_w (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmini.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 32-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = min((s32)a.word[i], (s32)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmini_wu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmini_wu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vmini.wu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 32-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = min((u32)a.word[i], (u32)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmini_wu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmini.wu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 32-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = min((u32)a.word[i], (u32)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmod_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmod_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmod.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nModulo residual signed 8-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((s8)a.byte[i] % (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 29, 33 | 0.06(1/17) |\n| 3A6000 | LA664 | 29, 35 | 0.06(1/15.5) |\n| 3C6000 | LA664 | 29 | 0.07(1/13.5) |\n| 2K1000LA | LA264 | 30, 46 | 0(1/63) |\n| 2K3000 | LA364E | 30, 46 | 0(1/63) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmod_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmod.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual signed 8-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((s8)a.byte[i] % (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>29, 33</td>\n<td>0.06(1/17)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>29, 35</td>\n<td>0.06(1/15.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>29</td>\n<td>0.07(1/13.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>30, 46</td>\n<td>0(1/63)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>30, 46</td>\n<td>0(1/63)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmod_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmod_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmod.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nModulo residual unsigned 8-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((u8)a.byte[i] % (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 29, 33 | 0.05(1/19) |\n| 3A6000 | LA664 | 29, 37 | 0.06(1/17.5) |\n| 3C6000 | LA664 | 29 | 0.07(1/13.5) |\n| 2K1000LA | LA264 | 30, 46 | 0(1/62) |\n| 2K3000 | LA364E | 30, 46 | 0(1/63) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmod_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmod.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((u8)a.byte[i] % (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>29, 33</td>\n<td>0.05(1/19)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>29, 37</td>\n<td>0.06(1/17.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>29</td>\n<td>0.07(1/13.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>30, 46</td>\n<td>0(1/62)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>30, 46</td>\n<td>0(1/63)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmod_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmod_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmod.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nModulo residual signed 64-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((s64)a.dword[i] % (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 10 | 0.11(1/9.5) |\n| 3A6000 | LA664 | 8, 10 | 0.25(1/4) |\n| 3C6000 | LA664 | 8 | 0.33(1/3) |\n| 2K1000LA | LA264 | 9, 11 | 0.08(1/13) |\n| 2K3000 | LA364E | 9, 11 | 0.08(1/13) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmod_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmod.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual signed 64-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((s64)a.dword[i] % (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 10</td>\n<td>0.11(1/9.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8, 10</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.33(1/3)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>9, 11</td>\n<td>0.08(1/13)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>9, 11</td>\n<td>0.08(1/13)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmod_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmod_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmod.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nModulo residual unsigned 64-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((u64)a.dword[i] % (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 10 | 0.11(1/9.5) |\n| 3A6000 | LA664 | 8, 10 | 0.25(1/4) |\n| 3C6000 | LA664 | 8 | 0.33(1/3) |\n| 2K1000LA | LA264 | 9, 11 | 0.08(1/13) |\n| 2K3000 | LA364E | 9, 11 | 0.08(1/13) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmod_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmod.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((u64)a.dword[i] % (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 10</td>\n<td>0.11(1/9.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8, 10</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.33(1/3)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>9, 11</td>\n<td>0.08(1/13)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>9, 11</td>\n<td>0.08(1/13)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmod_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmod_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmod.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nModulo residual signed 16-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((s16)a.half[i] % (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 17, 21 | 0.09(1/11) |\n| 3A6000 | LA664 | 17, 21 | 0.12(1/8.5) |\n| 3C6000 | LA664 | 17 | 0.13(1/7.5) |\n| 2K1000LA | LA264 | 18, 26 | 0.03(1/35) |\n| 2K3000 | LA364E | 18, 26 | 0.03(1/35) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmod_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmod.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual signed 16-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((s16)a.half[i] % (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>17, 21</td>\n<td>0.09(1/11)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17, 21</td>\n<td>0.12(1/8.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>17</td>\n<td>0.13(1/7.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>18, 26</td>\n<td>0.03(1/35)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>18, 26</td>\n<td>0.03(1/35)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmod_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmod_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmod.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nModulo residual unsigned 16-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((u16)a.half[i] % (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 17, 21 | 0.07(1/15) |\n| 3A6000 | LA664 | 17, 21 | 0.11(1/9.5) |\n| 3C6000 | LA664 | 17 | 0.13(1/7.5) |\n| 2K1000LA | LA264 | 18, 26 | 0.03(1/35) |\n| 2K3000 | LA364E | 18, 26 | 0.03(1/35) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmod_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmod.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((u16)a.half[i] % (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>17, 21</td>\n<td>0.07(1/15)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17, 21</td>\n<td>0.11(1/9.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>17</td>\n<td>0.13(1/7.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>18, 26</td>\n<td>0.03(1/35)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>18, 26</td>\n<td>0.03(1/35)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmod_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmod_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmod.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nModulo residual signed 32-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((s32)a.word[i] % (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 15 | 0.08(1/12) |\n| 3A6000 | LA664 | 11, 13 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11 | 0.22(1/4.5) |\n| 2K1000LA | LA264 | 12, 16 | 0.05(1/20) |\n| 2K3000 | LA364E | 12, 16 | 0.05(1/20) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmod_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmod.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual signed 32-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((s32)a.word[i] % (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 15</td>\n<td>0.08(1/12)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11, 13</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.22(1/4.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>12, 16</td>\n<td>0.05(1/20)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>12, 16</td>\n<td>0.05(1/20)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmod_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmod_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmod.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nModulo residual unsigned 32-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((u32)a.word[i] % (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 15 | 0.06(1/16) |\n| 3A6000 | LA664 | 11, 13 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11 | 0.22(1/4.5) |\n| 2K1000LA | LA264 | 12, 16 | 0.05(1/20) |\n| 2K3000 | LA364E | 12, 16 | 0.05(1/20) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmod_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmod.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((u32)a.word[i] % (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 15</td>\n<td>0.06(1/16)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11, 13</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.22(1/4.5)</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>12, 16</td>\n<td>0.05(1/20)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>12, 16</td>\n<td>0.05(1/20)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmskgez_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmskgez_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vmskgez.b vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nFor each 8-bit element in `a`, if the element is greater than or equal to zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vmskgez_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x00000000000001fe 0x0000000000000000\n__m128i __lsx_vmskgez_b(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x000000000000b7cf 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8080808080808080;\nu64 c = m & a.dword[0];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] |= c << 8;\ndst.dword[0] = (u16)~dst.dword[0];\ndst.dword[1] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskgez_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmskgez.b vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 8-bit element in <code>a</code>, if the element is greater than or equal to zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskgez_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x00000000000001fe 0x0000000000000000\n__m128i __lsx_vmskgez_b(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x000000000000b7cf 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8080808080808080;\nu64 c = m &amp; a.dword[0];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] |= c &lt;&lt; 8;\ndst.dword[0] = (u16)~dst.dword[0];\ndst.dword[1] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmskltz_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmskltz_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vmskltz.b vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nFor each 8-bit element in `a`, if the element is less than zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vmskltz_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x000000000000fe01 0x0000000000000000\n__m128i __lsx_vmskltz_b(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x0000000000004830 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8080808080808080;\nu64 c = m & a.dword[0];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] |= c << 8;\ndst.dword[1] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskltz_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmskltz.b vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 8-bit element in <code>a</code>, if the element is less than zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskltz_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x000000000000fe01 0x0000000000000000\n__m128i __lsx_vmskltz_b(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x0000000000004830 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8080808080808080;\nu64 c = m &amp; a.dword[0];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] |= c &lt;&lt; 8;\ndst.dword[1] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmskltz_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmskltz_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vmskltz.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nFor each 64-bit element in `a`, if the element is less than zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vmskltz_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000002 0x0000000000000000\n__m128i __lsx_vmskltz_d(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x0000000000000000 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8000000000000000;\nu64 c = m & a.dword[0];\nc >>= 63;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc >>= 63;\ndst.dword[0] |= c << 1;\ndst.dword[1] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskltz_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmskltz.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 64-bit element in <code>a</code>, if the element is less than zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskltz_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000000000002 0x0000000000000000\n__m128i __lsx_vmskltz_d(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x0000000000000000 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8000000000000000;\nu64 c = m &amp; a.dword[0];\nc &gt;&gt;= 63;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc &gt;&gt;= 63;\ndst.dword[0] |= c &lt;&lt; 1;\ndst.dword[1] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmskltz_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmskltz_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vmskltz.h vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nFor each 16-bit element in `a`, if the element is less than zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vmskltz_h(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x00000000000000f0 0x0000000000000000\n__m128i __lsx_vmskltz_h(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x0000000000000024 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8000800080008000;\nu64 c = m & a.dword[0];\nc |= c << 15;\nc |= c << 30;\nc >>= 60;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc |= c << 15;\nc |= c << 30;\nc >>= 60;\ndst.dword[0] |= c << 4;\ndst.dword[1] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskltz_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmskltz.h vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 16-bit element in <code>a</code>, if the element is less than zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskltz_h(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x00000000000000f0 0x0000000000000000\n__m128i __lsx_vmskltz_h(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x0000000000000024 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8000800080008000;\nu64 c = m &amp; a.dword[0];\nc |= c &lt;&lt; 15;\nc |= c &lt;&lt; 30;\nc &gt;&gt;= 60;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc |= c &lt;&lt; 15;\nc |= c &lt;&lt; 30;\nc &gt;&gt;= 60;\ndst.dword[0] |= c &lt;&lt; 4;\ndst.dword[1] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmskltz_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmskltz_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vmskltz.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nFor each 32-bit element in `a`, if the element is less than zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vmskltz_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x000000000000000c 0x0000000000000000\n__m128i __lsx_vmskltz_w(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x0000000000000004 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8000000080000000;\nu64 c = m & a.dword[0];\nc |= c << 31;\nc >>= 62;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc |= c << 31;\nc >>= 62;\ndst.dword[0] |= c << 2;\ndst.dword[1] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskltz_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmskltz.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 32-bit element in <code>a</code>, if the element is less than zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmskltz_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x000000000000000c 0x0000000000000000\n__m128i __lsx_vmskltz_w(__m128i{0x0000808000000000, 0x0081000081716151})\n= 0x0000000000000004 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8000000080000000;\nu64 c = m &amp; a.dword[0];\nc |= c &lt;&lt; 31;\nc &gt;&gt;= 62;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc |= c &lt;&lt; 31;\nc &gt;&gt;= 62;\ndst.dword[0] |= c &lt;&lt; 2;\ndst.dword[1] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmsknz_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmsknz_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vmsknz.b vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nFor each 8-bit element in `a`, if the element is non-zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vmsknz_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x000000000000feff 0x0000000000000000\n__m128i __lsx_vmsknz_b(__m128i{0x0000111100000000, 0x0011000011111111})\n= 0x0000000000004f30 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x7F7F7F7F7F7F7F7F;\nu64 c = ~(((a.dword[0] & m) + m) | a.dword[0] | m);\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] = c;\nc = ~(((a.dword[1] & m) + m) | a.dword[1] | m);\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] |= c << 8;\ndst.dword[0] = (u16)~dst.dword[0];\ndst.dword[1] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmsknz_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmsknz.b vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 8-bit element in <code>a</code>, if the element is non-zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmsknz_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x000000000000feff 0x0000000000000000\n__m128i __lsx_vmsknz_b(__m128i{0x0000111100000000, 0x0011000011111111})\n= 0x0000000000004f30 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x7F7F7F7F7F7F7F7F;\nu64 c = ~(((a.dword[0] &amp; m) + m) | a.dword[0] | m);\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] = c;\nc = ~(((a.dword[1] &amp; m) + m) | a.dword[1] | m);\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] |= c &lt;&lt; 8;\ndst.dword[0] = (u16)~dst.dword[0];\ndst.dword[1] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmsub_b (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmsub_b (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmsub.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 8-bit elements in `b` and `c`, negate and add elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = -b.byte[i] * c.byte[i] + a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmsub_b (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmsub.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 8-bit elements in <code>b</code> and <code>c</code>, negate and add elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = -b.byte[i] * c.byte[i] + a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmsub_d (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmsub_d (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmsub.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 64-bit elements in `b` and `c`, negate and add elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = -b.dword[i] * c.dword[i] + a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmsub_d (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmsub.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 64-bit elements in <code>b</code> and <code>c</code>, negate and add elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = -b.dword[i] * c.dword[i] + a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmsub_h (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmsub_h (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmsub.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 16-bit elements in `b` and `c`, negate and add elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = -b.half[i] * c.half[i] + a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmsub_h (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmsub.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 16-bit elements in <code>b</code> and <code>c</code>, negate and add elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = -b.half[i] * c.half[i] + a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmsub_w (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmsub_w (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vmsub.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 32-bit elements in `b` and `c`, negate and add elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = -b.word[i] * c.word[i] + a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmsub_w (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmsub.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 32-bit elements in <code>b</code> and <code>c</code>, negate and add elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = -b.word[i] * c.word[i] + a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmuh_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmuh_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmuh.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply signed 8-bit elements in `a` and `b`, save the high 8-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (((s16)(s8)a.byte[i] * (s16)(s8)b.byte[i])) >> 8;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmuh_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmuh.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply signed 8-bit elements in <code>a</code> and <code>b</code>, save the high 8-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (((s16)(s8)a.byte[i] * (s16)(s8)b.byte[i])) &gt;&gt; 8;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmuh_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmuh_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmuh.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply unsigned 8-bit elements in `a` and `b`, save the high 8-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (((u16)(u8)a.byte[i] * (u16)(u8)b.byte[i])) >> 8;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmuh_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmuh.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply unsigned 8-bit elements in <code>a</code> and <code>b</code>, save the high 8-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (((u16)(u8)a.byte[i] * (u16)(u8)b.byte[i])) &gt;&gt; 8;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmuh_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmuh_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmuh.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply signed 64-bit elements in `a` and `b`, save the high 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (((s128)(s64)a.dword[i] * (s128)(s64)b.dword[i])) >> 64;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmuh_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmuh.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply signed 64-bit elements in <code>a</code> and <code>b</code>, save the high 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (((s128)(s64)a.dword[i] * (s128)(s64)b.dword[i])) &gt;&gt; 64;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmuh_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmuh_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmuh.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply unsigned 64-bit elements in `a` and `b`, save the high 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (((u128)(u64)a.dword[i] * (u128)(u64)b.dword[i])) >> 64;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmuh_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmuh.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply unsigned 64-bit elements in <code>a</code> and <code>b</code>, save the high 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (((u128)(u64)a.dword[i] * (u128)(u64)b.dword[i])) &gt;&gt; 64;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmuh_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmuh_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmuh.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply signed 16-bit elements in `a` and `b`, save the high 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (((s32)(s16)a.half[i] * (s32)(s16)b.half[i])) >> 16;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmuh_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmuh.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply signed 16-bit elements in <code>a</code> and <code>b</code>, save the high 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (((s32)(s16)a.half[i] * (s32)(s16)b.half[i])) &gt;&gt; 16;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmuh_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmuh_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmuh.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply unsigned 16-bit elements in `a` and `b`, save the high 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (((u32)(u16)a.half[i] * (u32)(u16)b.half[i])) >> 16;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmuh_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmuh.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply unsigned 16-bit elements in <code>a</code> and <code>b</code>, save the high 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (((u32)(u16)a.half[i] * (u32)(u16)b.half[i])) &gt;&gt; 16;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmuh_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmuh_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmuh.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply signed 32-bit elements in `a` and `b`, save the high 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (((s64)(s32)a.word[i] * (s64)(s32)b.word[i])) >> 32;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmuh_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmuh.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply signed 32-bit elements in <code>a</code> and <code>b</code>, save the high 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (((s64)(s32)a.word[i] * (s64)(s32)b.word[i])) &gt;&gt; 32;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmuh_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmuh_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmuh.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply unsigned 32-bit elements in `a` and `b`, save the high 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (((u64)(u32)a.word[i] * (u64)(u32)b.word[i])) >> 32;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmuh_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmuh.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply unsigned 32-bit elements in <code>a</code> and <code>b</code>, save the high 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (((u64)(u32)a.word[i] * (u64)(u32)b.word[i])) &gt;&gt; 32;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmul_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmul_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmul.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] * b.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmul_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmul.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] * b.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmul_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmul_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmul.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] * b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmul_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmul.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] * b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmul_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmul_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmul.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] * b.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmul_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmul.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] * b.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmul_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmul_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmul.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] * b.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmul_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmul.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] * b.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_d_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_d_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] * (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) * ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) * ((s64)((s32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_d_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] * (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) * ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) * ((s64)((s32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_d_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_d_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.d.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] * (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) * ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) * ((u64)((u32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_d_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.d.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] * (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) * ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) * ((u64)((u32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_d_wu_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_d_wu_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.d.wu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] * (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) * ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) * ((s64)((s32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_d_wu_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.d.wu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] * (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) * ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) * ((s64)((s32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_h_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_h_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] * (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) * ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) * ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) * ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) * ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) * ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) * ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) * ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) * ((s16)((s8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_h_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] * (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) * ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) * ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) * ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) * ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) * ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) * ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) * ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) * ((s16)((s8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_h_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_h_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.h.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] * (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) * ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) * ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) * ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) * ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) * ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) * ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) * ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) * ((u16)((u8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_h_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.h.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] * (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) * ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) * ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) * ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) * ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) * ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) * ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) * ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) * ((u16)((u8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_h_bu_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_h_bu_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.h.bu.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] * (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) * ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) * ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) * ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) * ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) * ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) * ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) * ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) * ((s16)((s8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_h_bu_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.h.bu.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] * (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) * ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) * ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) * ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) * ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) * ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) * ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) * ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) * ((s16)((s8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_q_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_q_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] * (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) * ((s128)((s64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_q_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] * (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) * ((s128)((s64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_q_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_q_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.q.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] * (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) * ((u128)((u64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_q_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.q.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] * (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) * ((u128)((u64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_q_du_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_q_du_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.q.du.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] * (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) * ((s128)((s64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_q_du_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.q.du.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] * (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) * ((s128)((s64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_w_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_w_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] * (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) * ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) * ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) * ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) * ((s32)((s16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_w_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] * (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) * ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) * ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) * ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) * ((s32)((s16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_w_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_w_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.w.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] * (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) * ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) * ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) * ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) * ((u32)((u16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_w_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.w.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] * (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) * ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) * ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) * ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) * ((u32)((u16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwev_w_hu_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwev_w_hu_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwev.w.hu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply even-positioned unsigned 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] * (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) * ((s32)((s16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) * ((s32)((s16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) * ((s32)((s16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) * ((s32)((s16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwev_w_hu_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwev.w.hu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] * (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) * ((s32)((s16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) * ((s32)((s16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) * ((s32)((s16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) * ((s32)((s16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_d_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_d_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] * (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) * ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) * ((s64)((s32)b.word[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_d_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] * (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) * ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) * ((s64)((s32)b.word[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_d_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_d_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.d.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] * (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) * ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) * ((u64)((u32)b.word[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_d_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.d.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] * (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) * ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) * ((u64)((u32)b.word[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_d_wu_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_d_wu_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.d.wu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] * (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) * ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) * ((s64)((s32)b.word[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_d_wu_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.d.wu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] * (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) * ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) * ((s64)((s32)b.word[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_h_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_h_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] * (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) * ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) * ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) * ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) * ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) * ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) * ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) * ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) * ((s16)((s8)b.byte[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_h_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] * (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) * ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) * ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) * ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) * ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) * ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) * ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) * ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) * ((s16)((s8)b.byte[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_h_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_h_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.h.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] * (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) * ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) * ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) * ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) * ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) * ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) * ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) * ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) * ((u16)((u8)b.byte[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_h_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.h.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] * (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) * ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) * ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) * ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) * ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) * ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) * ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) * ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) * ((u16)((u8)b.byte[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_h_bu_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_h_bu_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.h.bu.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] * (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) * ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) * ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) * ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) * ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) * ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) * ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) * ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) * ((s16)((s8)b.byte[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_h_bu_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.h.bu.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] * (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) * ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) * ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) * ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) * ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) * ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) * ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) * ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) * ((s16)((s8)b.byte[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_q_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_q_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] * (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) * ((s128)((s64)b.dword[1]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_q_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] * (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) * ((s128)((s64)b.dword[1]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_q_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_q_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.q.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] * (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) * ((u128)((u64)b.dword[1]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_q_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.q.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] * (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) * ((u128)((u64)b.dword[1]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_q_du_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_q_du_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.q.du.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] * (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) * ((s128)((s64)b.dword[1]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |\n| 2K1000LA | LA264 | 6 | 1 |\n| 2K3000 | LA364E | 6 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_q_du_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.q.du.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] * (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) * ((s128)((s64)b.dword[1]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>6</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_w_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_w_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] * (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) * ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) * ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) * ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) * ((s32)((s16)b.half[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_w_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] * (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) * ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) * ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) * ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) * ((s32)((s16)b.half[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_w_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_w_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.w.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] * (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) * ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) * ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) * ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) * ((u32)((u16)b.half[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_w_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.w.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] * (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) * ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) * ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) * ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) * ((u32)((u16)b.half[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vmulwod_w_hu_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vmulwod_w_hu_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vmulwod.w.hu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] * (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) * ((s32)((s16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) * ((s32)((s16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) * ((s32)((s16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) * ((s32)((s16)b.half[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 4 | 1 |\n| 2K3000 | LA364E | 4 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vmulwod_w_hu_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vmulwod.w.hu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] * (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) * ((s32)((s16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) * ((s32)((s16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) * ((s32)((s16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) * ((s32)((s16)b.half[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vneg_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vneg_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vneg.b vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nNegate 8-bit elements in `a` and save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = -a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vneg_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vneg.b vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Negate 8-bit elements in <code>a</code> and save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = -a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vneg_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vneg_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vneg.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nNegate 64-bit elements in `a` and save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = -a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vneg_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vneg.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Negate 64-bit elements in <code>a</code> and save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = -a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vneg_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vneg_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vneg.h vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nNegate 16-bit elements in `a` and save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = -a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vneg_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vneg.h vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Negate 16-bit elements in <code>a</code> and save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = -a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vneg_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vneg_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vneg.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nNegate 32-bit elements in `a` and save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = -a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vneg_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vneg.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Negate 32-bit elements in <code>a</code> and save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = -a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vnor_v (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vnor_v (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vnor.v vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise NOR between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ~(a.dword[i] | b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vnor_v (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vnor.v vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise NOR between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ~(a.dword[i] | b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vnori_b (__m128i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vnori_b (__m128i a, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vnori.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise NOR between elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ~(a.byte[i] | imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vnori_b (__m128i a, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vnori.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise NOR between elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ~(a.byte[i] | imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vor_v (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vor_v (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vor.v vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise OR between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] | b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vor_v (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vor.v vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise OR between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] | b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vori_b (__m128i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vori_b (__m128i a, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vori.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise OR between elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] | imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 3 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vori_b (__m128i a, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vori.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise OR between elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] | imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vorn_v (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vorn_v (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vorn.v vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise ORN between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] | (~b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vorn_v (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vorn.v vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise ORN between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] | (~b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpackev_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpackev_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpackev.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCollect and pack even-positioned 8-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i - 1] : b.byte[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = a.byte[0];\n  dst.byte[2] = b.byte[2];\n  dst.byte[3] = a.byte[2];\n  dst.byte[4] = b.byte[4];\n  dst.byte[5] = a.byte[4];\n  dst.byte[6] = b.byte[6];\n  dst.byte[7] = a.byte[6];\n  dst.byte[8] = b.byte[8];\n  dst.byte[9] = a.byte[8];\n  dst.byte[10] = b.byte[10];\n  dst.byte[11] = a.byte[10];\n  dst.byte[12] = b.byte[12];\n  dst.byte[13] = a.byte[12];\n  dst.byte[14] = b.byte[14];\n  dst.byte[15] = a.byte[14];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpackev_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpackev.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack even-positioned 8-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i - 1] : b.byte[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = a.byte[0];\n  dst.byte[2] = b.byte[2];\n  dst.byte[3] = a.byte[2];\n  dst.byte[4] = b.byte[4];\n  dst.byte[5] = a.byte[4];\n  dst.byte[6] = b.byte[6];\n  dst.byte[7] = a.byte[6];\n  dst.byte[8] = b.byte[8];\n  dst.byte[9] = a.byte[8];\n  dst.byte[10] = b.byte[10];\n  dst.byte[11] = a.byte[10];\n  dst.byte[12] = b.byte[12];\n  dst.byte[13] = a.byte[12];\n  dst.byte[14] = b.byte[14];\n  dst.byte[15] = a.byte[14];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpackev_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpackev_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpackev.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCollect and pack even-positioned 64-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i - 1] : b.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpackev_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpackev.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack even-positioned 64-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i - 1] : b.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpackev_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpackev_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpackev.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCollect and pack even-positioned 16-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i - 1] : b.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = a.half[0];\n  dst.half[2] = b.half[2];\n  dst.half[3] = a.half[2];\n  dst.half[4] = b.half[4];\n  dst.half[5] = a.half[4];\n  dst.half[6] = b.half[6];\n  dst.half[7] = a.half[6];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpackev_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpackev.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack even-positioned 16-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i - 1] : b.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = a.half[0];\n  dst.half[2] = b.half[2];\n  dst.half[3] = a.half[2];\n  dst.half[4] = b.half[4];\n  dst.half[5] = a.half[4];\n  dst.half[6] = b.half[6];\n  dst.half[7] = a.half[6];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpackev_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpackev_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpackev.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCollect and pack even-positioned 32-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i - 1] : b.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = a.word[0];\n  dst.word[2] = b.word[2];\n  dst.word[3] = a.word[2];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpackev_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpackev.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack even-positioned 32-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i - 1] : b.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = a.word[0];\n  dst.word[2] = b.word[2];\n  dst.word[3] = a.word[2];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpackod_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpackod_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpackod.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCollect and pack odd-positioned 8-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i] : b.byte[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[1];\n  dst.byte[1] = a.byte[1];\n  dst.byte[2] = b.byte[3];\n  dst.byte[3] = a.byte[3];\n  dst.byte[4] = b.byte[5];\n  dst.byte[5] = a.byte[5];\n  dst.byte[6] = b.byte[7];\n  dst.byte[7] = a.byte[7];\n  dst.byte[8] = b.byte[9];\n  dst.byte[9] = a.byte[9];\n  dst.byte[10] = b.byte[11];\n  dst.byte[11] = a.byte[11];\n  dst.byte[12] = b.byte[13];\n  dst.byte[13] = a.byte[13];\n  dst.byte[14] = b.byte[15];\n  dst.byte[15] = a.byte[15];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpackod_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpackod.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack odd-positioned 8-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i] : b.byte[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[1];\n  dst.byte[1] = a.byte[1];\n  dst.byte[2] = b.byte[3];\n  dst.byte[3] = a.byte[3];\n  dst.byte[4] = b.byte[5];\n  dst.byte[5] = a.byte[5];\n  dst.byte[6] = b.byte[7];\n  dst.byte[7] = a.byte[7];\n  dst.byte[8] = b.byte[9];\n  dst.byte[9] = a.byte[9];\n  dst.byte[10] = b.byte[11];\n  dst.byte[11] = a.byte[11];\n  dst.byte[12] = b.byte[13];\n  dst.byte[13] = a.byte[13];\n  dst.byte[14] = b.byte[15];\n  dst.byte[15] = a.byte[15];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpackod_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpackod_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpackod.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCollect and pack odd-positioned 64-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i] : b.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpackod_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpackod.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack odd-positioned 64-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i] : b.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpackod_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpackod_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpackod.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCollect and pack odd-positioned 16-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i] : b.half[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[1];\n  dst.half[1] = a.half[1];\n  dst.half[2] = b.half[3];\n  dst.half[3] = a.half[3];\n  dst.half[4] = b.half[5];\n  dst.half[5] = a.half[5];\n  dst.half[6] = b.half[7];\n  dst.half[7] = a.half[7];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpackod_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpackod.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack odd-positioned 16-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i] : b.half[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[1];\n  dst.half[1] = a.half[1];\n  dst.half[2] = b.half[3];\n  dst.half[3] = a.half[3];\n  dst.half[4] = b.half[5];\n  dst.half[5] = a.half[5];\n  dst.half[6] = b.half[7];\n  dst.half[7] = a.half[7];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpackod_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpackod_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpackod.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCollect and pack odd-positioned 32-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i] : b.word[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[1];\n  dst.word[1] = a.word[1];\n  dst.word[2] = b.word[3];\n  dst.word[3] = a.word[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpackod_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpackod.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack odd-positioned 32-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i] : b.word[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[1];\n  dst.word[1] = a.word[1];\n  dst.word[2] = b.word[3];\n  dst.word[3] = a.word[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpcnt_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpcnt_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vpcnt.b vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount the number of ones (population, popcount) in 8-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vpcnt_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0202040204040602 0x0404060406060800\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = popcount(a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpcnt_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpcnt.b vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count the number of ones (population, popcount) in 8-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpcnt_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0202040204040602 0x0404060406060800\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = popcount(a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpcnt_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpcnt_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vpcnt.d vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount the number of ones (population, popcount) in 64-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vpcnt_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x000000000000001a 0x0000000000000026\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = popcount(a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpcnt_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpcnt.d vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count the number of ones (population, popcount) in 64-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpcnt_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x000000000000001a 0x0000000000000026\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = popcount(a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpcnt_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpcnt_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vpcnt.h vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount the number of ones (population, popcount) in 16-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vpcnt_h(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0004000600080008 0x0008000a000c0008\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = popcount(a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpcnt_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpcnt.h vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count the number of ones (population, popcount) in 16-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpcnt_h(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0004000600080008 0x0008000a000c0008\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = popcount(a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpcnt_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpcnt_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vpcnt.w vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCount the number of ones (population, popcount) in 32-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vpcnt_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000a00000010 0x0000001200000014\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = popcount(a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpcnt_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpcnt.w vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count the number of ones (population, popcount) in 32-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpcnt_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00})\n= 0x0000000a00000010 0x0000001200000014\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = popcount(a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpermi_w (__m128i a, __m128i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpermi_w (__m128i a, __m128i b, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vpermi.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPermute words from `a` and `b` with indices recorded in `imm` and store into `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m128i __lsx_vpermi_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xababababbbbbbbbb, 0x1234123443214321}, 0x12)\n= 0xbbbbbbbb43214321 0x5566778811223344\n```\n\n\n### Operation\n\n```c++\ndst.word[0] = b.word[imm & 0x3];\ndst.word[1] = b.word[(imm >> 2) & 0x3];\ndst.word[2] = a.word[(imm >> 4) & 0x3];\ndst.word[3] = a.word[(imm >> 6) & 0x3];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpermi_w (__m128i a, __m128i b, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpermi.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Permute words from <code>a</code> and <code>b</code> with indices recorded in <code>imm</code> and store into <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpermi_w(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xababababbbbbbbbb, 0x1234123443214321}, 0x12)\n= 0xbbbbbbbb43214321 0x5566778811223344\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst.word[0] = b.word[imm &amp; 0x3];\ndst.word[1] = b.word[(imm &gt;&gt; 2) &amp; 0x3];\ndst.word[2] = a.word[(imm &gt;&gt; 4) &amp; 0x3];\ndst.word[3] = a.word[(imm &gt;&gt; 6) &amp; 0x3];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Permutation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpickev_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpickev_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpickev.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nPick even-positioned 8-bit elements in `b` first, then pick even-positioned 8-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i < 8) ? b.byte[i * 2] : a.byte[(i - 8) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = b.byte[2];\n  dst.byte[2] = b.byte[4];\n  dst.byte[3] = b.byte[6];\n  dst.byte[4] = b.byte[8];\n  dst.byte[5] = b.byte[10];\n  dst.byte[6] = b.byte[12];\n  dst.byte[7] = b.byte[14];\n  dst.byte[8] = a.byte[0];\n  dst.byte[9] = a.byte[2];\n  dst.byte[10] = a.byte[4];\n  dst.byte[11] = a.byte[6];\n  dst.byte[12] = a.byte[8];\n  dst.byte[13] = a.byte[10];\n  dst.byte[14] = a.byte[12];\n  dst.byte[15] = a.byte[14];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpickev_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickev.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick even-positioned 8-bit elements in <code>b</code> first, then pick even-positioned 8-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i &lt; 8) ? b.byte[i * 2] : a.byte[(i - 8) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = b.byte[2];\n  dst.byte[2] = b.byte[4];\n  dst.byte[3] = b.byte[6];\n  dst.byte[4] = b.byte[8];\n  dst.byte[5] = b.byte[10];\n  dst.byte[6] = b.byte[12];\n  dst.byte[7] = b.byte[14];\n  dst.byte[8] = a.byte[0];\n  dst.byte[9] = a.byte[2];\n  dst.byte[10] = a.byte[4];\n  dst.byte[11] = a.byte[6];\n  dst.byte[12] = a.byte[8];\n  dst.byte[13] = a.byte[10];\n  dst.byte[14] = a.byte[12];\n  dst.byte[15] = a.byte[14];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpickev_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpickev_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpickev.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nPick even-positioned 64-bit elements in `b` first, then pick even-positioned 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i < 1) ? b.dword[i * 2] : a.dword[(i - 1) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpickev_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickev.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick even-positioned 64-bit elements in <code>b</code> first, then pick even-positioned 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i &lt; 1) ? b.dword[i * 2] : a.dword[(i - 1) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpickev_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpickev_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpickev.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nPick even-positioned 16-bit elements in `b` first, then pick even-positioned 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i < 4) ? b.half[i * 2] : a.half[(i - 4) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = b.half[2];\n  dst.half[2] = b.half[4];\n  dst.half[3] = b.half[6];\n  dst.half[4] = a.half[0];\n  dst.half[5] = a.half[2];\n  dst.half[6] = a.half[4];\n  dst.half[7] = a.half[6];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpickev_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickev.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick even-positioned 16-bit elements in <code>b</code> first, then pick even-positioned 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i &lt; 4) ? b.half[i * 2] : a.half[(i - 4) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = b.half[2];\n  dst.half[2] = b.half[4];\n  dst.half[3] = b.half[6];\n  dst.half[4] = a.half[0];\n  dst.half[5] = a.half[2];\n  dst.half[6] = a.half[4];\n  dst.half[7] = a.half[6];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpickev_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpickev_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpickev.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nPick even-positioned 32-bit elements in `b` first, then pick even-positioned 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? b.word[i * 2] : a.word[(i - 2) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = b.word[2];\n  dst.word[2] = a.word[0];\n  dst.word[3] = a.word[2];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpickev_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickev.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick even-positioned 32-bit elements in <code>b</code> first, then pick even-positioned 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? b.word[i * 2] : a.word[(i - 2) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = b.word[2];\n  dst.word[2] = a.word[0];\n  dst.word[3] = a.word[2];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpickod_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpickod_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpickod.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nPick odd-positioned 8-bit elements in `b` first, then pick odd-positioned 8-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i < 8) ? b.byte[i * 2 + 1] : a.byte[(i - 8) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[1];\n  dst.byte[1] = b.byte[3];\n  dst.byte[2] = b.byte[5];\n  dst.byte[3] = b.byte[7];\n  dst.byte[4] = b.byte[9];\n  dst.byte[5] = b.byte[11];\n  dst.byte[6] = b.byte[13];\n  dst.byte[7] = b.byte[15];\n  dst.byte[8] = a.byte[1];\n  dst.byte[9] = a.byte[3];\n  dst.byte[10] = a.byte[5];\n  dst.byte[11] = a.byte[7];\n  dst.byte[12] = a.byte[9];\n  dst.byte[13] = a.byte[11];\n  dst.byte[14] = a.byte[13];\n  dst.byte[15] = a.byte[15];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpickod_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickod.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick odd-positioned 8-bit elements in <code>b</code> first, then pick odd-positioned 8-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i &lt; 8) ? b.byte[i * 2 + 1] : a.byte[(i - 8) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[1];\n  dst.byte[1] = b.byte[3];\n  dst.byte[2] = b.byte[5];\n  dst.byte[3] = b.byte[7];\n  dst.byte[4] = b.byte[9];\n  dst.byte[5] = b.byte[11];\n  dst.byte[6] = b.byte[13];\n  dst.byte[7] = b.byte[15];\n  dst.byte[8] = a.byte[1];\n  dst.byte[9] = a.byte[3];\n  dst.byte[10] = a.byte[5];\n  dst.byte[11] = a.byte[7];\n  dst.byte[12] = a.byte[9];\n  dst.byte[13] = a.byte[11];\n  dst.byte[14] = a.byte[13];\n  dst.byte[15] = a.byte[15];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpickod_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpickod_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpickod.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nPick odd-positioned 64-bit elements in `b` first, then pick odd-positioned 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i < 1) ? b.dword[i * 2 + 1] : a.dword[(i - 1) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpickod_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickod.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick odd-positioned 64-bit elements in <code>b</code> first, then pick odd-positioned 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i &lt; 1) ? b.dword[i * 2 + 1] : a.dword[(i - 1) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpickod_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpickod_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpickod.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nPick odd-positioned 16-bit elements in `b` first, then pick odd-positioned 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i < 4) ? b.half[i * 2 + 1] : a.half[(i - 4) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[1];\n  dst.half[1] = b.half[3];\n  dst.half[2] = b.half[5];\n  dst.half[3] = b.half[7];\n  dst.half[4] = a.half[1];\n  dst.half[5] = a.half[3];\n  dst.half[6] = a.half[5];\n  dst.half[7] = a.half[7];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpickod_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickod.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick odd-positioned 16-bit elements in <code>b</code> first, then pick odd-positioned 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i &lt; 4) ? b.half[i * 2 + 1] : a.half[(i - 4) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[1];\n  dst.half[1] = b.half[3];\n  dst.half[2] = b.half[5];\n  dst.half[3] = b.half[7];\n  dst.half[4] = a.half[1];\n  dst.half[5] = a.half[3];\n  dst.half[6] = a.half[5];\n  dst.half[7] = a.half[7];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vpickod_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vpickod_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vpickod.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nPick odd-positioned 32-bit elements in `b` first, then pick odd-positioned 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? b.word[i * 2 + 1] : a.word[(i - 2) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[1];\n  dst.word[1] = b.word[3];\n  dst.word[2] = a.word[1];\n  dst.word[3] = a.word[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vpickod_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickod.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick odd-positioned 32-bit elements in <code>b</code> first, then pick odd-positioned 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? b.word[i * 2 + 1] : a.word[(i - 2) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[1];\n  dst.word[1] = b.word[3];\n  dst.word[2] = a.word[1];\n  dst.word[3] = a.word[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplgr2vr_b (int val)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplgr2vr_b (int val)\n#include <lsxintrin.h>\nInstruction: vreplgr2vr.b vr, r\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat `val` to whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = val;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 1 |\n| 3A6000 | LA664 | N/A | 1 |\n| 3C6000 | LA664 | N/A | 1 |\n| 2K1000LA | LA264 | N/A | 0.5(1/2) |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplgr2vr_b (int val)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplgr2vr.b vr, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>val</code> to whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = val;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplgr2vr_d (long int val)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplgr2vr_d (long int val)\n#include <lsxintrin.h>\nInstruction: vreplgr2vr.d vr, r\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat `val` to whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = val;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 1 |\n| 3A6000 | LA664 | N/A | 1 |\n| 3C6000 | LA664 | N/A | 1 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplgr2vr_d (long int val)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplgr2vr.d vr, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>val</code> to whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = val;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplgr2vr_h (int val)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplgr2vr_h (int val)\n#include <lsxintrin.h>\nInstruction: vreplgr2vr.h vr, r\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat `val` to whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = val;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 1 |\n| 3A6000 | LA664 | N/A | 1 |\n| 3C6000 | LA664 | N/A | 1 |\n| 2K1000LA | LA264 | N/A | 0.5(1/2) |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplgr2vr_h (int val)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplgr2vr.h vr, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>val</code> to whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = val;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplgr2vr_w (int val)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplgr2vr_w (int val)\n#include <lsxintrin.h>\nInstruction: vreplgr2vr.w vr, r\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat `val` to whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = val;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 1 |\n| 3A6000 | LA664 | N/A | 1 |\n| 3C6000 | LA664 | N/A | 1 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplgr2vr_w (int val)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplgr2vr.w vr, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>val</code> to whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = val;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrepli_b (imm_n512_511 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrepli_b (imm_n512_511 imm)\n#include <lsxintrin.h>\nInstruction: vldi vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat `imm` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = imm;\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrepli_b (imm_n512_511 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldi vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>imm</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrepli_d (imm_n512_511 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrepli_d (imm_n512_511 imm)\n#include <lsxintrin.h>\nInstruction: vldi vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat `imm` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = imm;\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrepli_d (imm_n512_511 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldi vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>imm</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrepli_h (imm_n512_511 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrepli_h (imm_n512_511 imm)\n#include <lsxintrin.h>\nInstruction: vldi vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat `imm` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = imm;\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrepli_h (imm_n512_511 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldi vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>imm</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrepli_w (imm_n512_511 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrepli_w (imm_n512_511 imm)\n#include <lsxintrin.h>\nInstruction: vldi vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat `imm` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = imm;\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrepli_w (imm_n512_511 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vldi vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>imm</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplve_b (__m128i a, int idx)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplve_b (__m128i a, int idx)\n#include <lsxintrin.h>\nInstruction: vreplve.b vr, vr, r\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[idx % 16];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplve_b (__m128i a, int idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplve.b vr, vr, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[idx % 16];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplve_d (__m128i a, int idx)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplve_d (__m128i a, int idx)\n#include <lsxintrin.h>\nInstruction: vreplve.d vr, vr, r\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[idx % 2];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplve_d (__m128i a, int idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplve.d vr, vr, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[idx % 2];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplve_h (__m128i a, int idx)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplve_h (__m128i a, int idx)\n#include <lsxintrin.h>\nInstruction: vreplve.h vr, vr, r\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[idx % 8];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplve_h (__m128i a, int idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplve.h vr, vr, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[idx % 8];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplve_w (__m128i a, int idx)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplve_w (__m128i a, int idx)\n#include <lsxintrin.h>\nInstruction: vreplve.w vr, vr, r\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[idx % 4];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplve_w (__m128i a, int idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplve.w vr, vr, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[idx % 4];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplvei_b (__m128i a, imm0_15 idx)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplvei_b (__m128i a, imm0_15 idx)\n#include <lsxintrin.h>\nInstruction: vreplvei.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[idx];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplvei_b (__m128i a, imm0_15 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplvei.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[idx];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplvei_d (__m128i a, imm0_1 idx)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplvei_d (__m128i a, imm0_1 idx)\n#include <lsxintrin.h>\nInstruction: vreplvei.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[idx];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplvei_d (__m128i a, imm0_1 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplvei.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[idx];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplvei_h (__m128i a, imm0_7 idx)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplvei_h (__m128i a, imm0_7 idx)\n#include <lsxintrin.h>\nInstruction: vreplvei.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[idx];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplvei_h (__m128i a, imm0_7 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplvei.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[idx];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vreplvei_w (__m128i a, imm0_3 idx)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vreplvei_w (__m128i a, imm0_3 idx)\n#include <lsxintrin.h>\nInstruction: vreplvei.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[idx];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vreplvei_w (__m128i a, imm0_3 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vreplvei.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[idx];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrotr_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrotr_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vrotr.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRotate right the unsigned 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] =\n      (a.byte[i] >> (b.byte[i] & 0x7)) | (a.byte[i] << (8 - (b.byte[i] & 0x7)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrotr_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vrotr.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] =\n      (a.byte[i] &gt;&gt; (b.byte[i] &amp; 0x7)) | (a.byte[i] &lt;&lt; (8 - (b.byte[i] &amp; 0x7)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrotr_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrotr_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vrotr.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRotate right the unsigned 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (a.dword[i] >> (b.dword[i] & 0x3f)) |\n                 (a.dword[i] << (64 - (b.dword[i] & 0x3f)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrotr_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vrotr.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (a.dword[i] &gt;&gt; (b.dword[i] &amp; 0x3f)) |\n                 (a.dword[i] &lt;&lt; (64 - (b.dword[i] &amp; 0x3f)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrotr_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrotr_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vrotr.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRotate right the unsigned 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (a.half[i] >> (b.half[i] & 0xf)) |\n                (a.half[i] << (16 - (b.half[i] & 0xf)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrotr_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vrotr.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (a.half[i] &gt;&gt; (b.half[i] &amp; 0xf)) |\n                (a.half[i] &lt;&lt; (16 - (b.half[i] &amp; 0xf)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrotr_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrotr_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vrotr.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nRotate right the unsigned 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (a.word[i] >> (b.word[i] & 0x1f)) |\n                (a.word[i] << (32 - (b.word[i] & 0x1f)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrotr_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vrotr.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (a.word[i] &gt;&gt; (b.word[i] &amp; 0x1f)) |\n                (a.word[i] &lt;&lt; (32 - (b.word[i] &amp; 0x1f)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrotri_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrotri_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vrotri.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRotate right the unsigned 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (a.byte[i] >> imm) | (a.byte[i] << (8 - imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrotri_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vrotri.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (a.byte[i] &gt;&gt; imm) | (a.byte[i] &lt;&lt; (8 - imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrotri_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrotri_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vrotri.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRotate right the unsigned 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (a.dword[i] >> imm) | (a.dword[i] << (64 - imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrotri_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vrotri.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (a.dword[i] &gt;&gt; imm) | (a.dword[i] &lt;&lt; (64 - imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrotri_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrotri_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vrotri.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRotate right the unsigned 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (a.half[i] >> imm) | (a.half[i] << (16 - imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrotri_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vrotri.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (a.half[i] &gt;&gt; imm) | (a.half[i] &lt;&lt; (16 - imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vrotri_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vrotri_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vrotri.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nRotate right the unsigned 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (a.word[i] >> imm) | (a.word[i] << (32 - imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vrotri_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vrotri.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (a.word[i] &gt;&gt; imm) | (a.word[i] &lt;&lt; (32 - imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsadd_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsadd_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsadd.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating add the signed 8-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (s8)sadd((s8)a.byte[i], (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsadd_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsadd.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the signed 8-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (s8)sadd((s8)a.byte[i], (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsadd_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsadd_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsadd.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating add the unsigned 8-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (u8)sadd((u8)a.byte[i], (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsadd_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsadd.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the unsigned 8-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (u8)sadd((u8)a.byte[i], (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsadd_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsadd_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsadd.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating add the signed 64-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)sadd((s64)a.dword[i], (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsadd_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsadd.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the signed 64-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)sadd((s64)a.dword[i], (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsadd_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsadd_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsadd.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating add the unsigned 64-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)sadd((u64)a.dword[i], (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsadd_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsadd.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the unsigned 64-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)sadd((u64)a.dword[i], (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsadd_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsadd_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsadd.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating add the signed 16-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)sadd((s16)a.half[i], (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsadd_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsadd.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the signed 16-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)sadd((s16)a.half[i], (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsadd_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsadd_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsadd.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating add the unsigned 16-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)sadd((u16)a.half[i], (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsadd_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsadd.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the unsigned 16-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)sadd((u16)a.half[i], (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsadd_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsadd_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsadd.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating add the signed 32-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)sadd((s32)a.word[i], (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsadd_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsadd.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the signed 32-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)sadd((s32)a.word[i], (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsadd_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsadd_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsadd.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating add the unsigned 32-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)sadd((u32)a.word[i], (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsadd_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsadd.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the unsigned 32-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)sadd((u32)a.word[i], (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsat_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsat_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vsat.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClamp signed 8-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = clamp<s8>(a.byte[i], -(1 << imm), (1 << imm) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsat_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsat.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp signed 8-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = clamp&lt;s8&gt;(a.byte[i], -(1 &lt;&lt; imm), (1 &lt;&lt; imm) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsat_bu (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsat_bu (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vsat.bu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClamp unsigned 8-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = clamp<u8>(a.byte[i], 0, (1 << (imm + 1)) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsat_bu (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsat.bu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp unsigned 8-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = clamp&lt;u8&gt;(a.byte[i], 0, (1 &lt;&lt; (imm + 1)) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsat_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsat_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsat.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClamp signed 64-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = clamp<s64>(a.dword[i], -(1 << imm), (1 << imm) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsat_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsat.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp signed 64-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = clamp&lt;s64&gt;(a.dword[i], -(1 &lt;&lt; imm), (1 &lt;&lt; imm) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsat_du (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsat_du (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsat.du vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClamp unsigned 64-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = clamp<u64>(a.dword[i], 0, (1 << (imm + 1)) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsat_du (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsat.du vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp unsigned 64-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = clamp&lt;u64&gt;(a.dword[i], 0, (1 &lt;&lt; (imm + 1)) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsat_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsat_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsat.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClamp signed 16-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = clamp<s16>(a.half[i], -(1 << imm), (1 << imm) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsat_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsat.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp signed 16-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = clamp&lt;s16&gt;(a.half[i], -(1 &lt;&lt; imm), (1 &lt;&lt; imm) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsat_hu (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsat_hu (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsat.hu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClamp unsigned 16-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = clamp<u16>(a.half[i], 0, (1 << (imm + 1)) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsat_hu (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsat.hu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp unsigned 16-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = clamp&lt;u16&gt;(a.half[i], 0, (1 &lt;&lt; (imm + 1)) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsat_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsat_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsat.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClamp signed 32-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = clamp<s32>(a.word[i], -(1 << imm), (1 << imm) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsat_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsat.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp signed 32-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = clamp&lt;s32&gt;(a.word[i], -(1 &lt;&lt; imm), (1 &lt;&lt; imm) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsat_wu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsat_wu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsat.wu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nClamp unsigned 32-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = clamp<u32>(a.word[i], 0, (1 << (imm + 1)) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsat_wu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsat.wu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp unsigned 32-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = clamp&lt;u32&gt;(a.word[i], 0, (1 &lt;&lt; (imm + 1)) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vseq_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vseq_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vseq.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the 8-bit elements in `a` and `b`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (a.byte[i] == b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vseq_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseq.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (a.byte[i] == b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vseq_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vseq_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vseq.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the 64-bit elements in `a` and `b`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (a.dword[i] == b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vseq_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseq.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (a.dword[i] == b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vseq_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vseq_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vseq.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the 16-bit elements in `a` and `b`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (a.half[i] == b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vseq_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseq.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (a.half[i] == b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vseq_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vseq_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vseq.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the 32-bit elements in `a` and `b`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (a.word[i] == b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vseq_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseq.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (a.word[i] == b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vseqi_b (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vseqi_b (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vseqi.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the 8-bit elements in `a` and `imm`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] == imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vseqi_b (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseqi.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] == imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vseqi_d (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vseqi_d (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vseqi.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the 64-bit elements in `a` and `imm`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] == imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vseqi_d (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseqi.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] == imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vseqi_h (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vseqi_h (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vseqi.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the 16-bit elements in `a` and `imm`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i] == imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vseqi_h (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseqi.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i] == imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vseqi_w (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vseqi_w (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vseqi.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the 32-bit elements in `a` and `imm`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i] == imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vseqi_w (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseqi.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i] == imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vshuf4i_b (__m128i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vshuf4i_b (__m128i a, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vshuf4i.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nShuffle every four 8-bit elements in `a` with indices packed in `imm`, save the result to `dst`.\n\n![](../diagram/vshuf4i_b.svg)\n\n\n### Examples\n\n```c++\n__m128i __lsx_vshuf4i_b(__m128i{0xabcdef1314156678, 0x1234123443214321}, 0x12)\n= 0x13ef13cd78667815 0x3412343421432121\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[(i & ~0x3) + ((imm >> (2 * (i & 0x3))) & 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = a.byte[0 + ((imm >> 0) & 0x3)];\n  dst.byte[1] = a.byte[0 + ((imm >> 2) & 0x3)];\n  dst.byte[2] = a.byte[0 + ((imm >> 4) & 0x3)];\n  dst.byte[3] = a.byte[0 + ((imm >> 6) & 0x3)];\n  dst.byte[4] = a.byte[4 + ((imm >> 0) & 0x3)];\n  dst.byte[5] = a.byte[4 + ((imm >> 2) & 0x3)];\n  dst.byte[6] = a.byte[4 + ((imm >> 4) & 0x3)];\n  dst.byte[7] = a.byte[4 + ((imm >> 6) & 0x3)];\n  dst.byte[8] = a.byte[8 + ((imm >> 0) & 0x3)];\n  dst.byte[9] = a.byte[8 + ((imm >> 2) & 0x3)];\n  dst.byte[10] = a.byte[8 + ((imm >> 4) & 0x3)];\n  dst.byte[11] = a.byte[8 + ((imm >> 6) & 0x3)];\n  dst.byte[12] = a.byte[12 + ((imm >> 0) & 0x3)];\n  dst.byte[13] = a.byte[12 + ((imm >> 2) & 0x3)];\n  dst.byte[14] = a.byte[12 + ((imm >> 4) & 0x3)];\n  dst.byte[15] = a.byte[12 + ((imm >> 6) & 0x3)];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf4i_b (__m128i a, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vshuf4i.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle every four 8-bit elements in <code>a</code> with indices packed in <code>imm</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/vshuf4i_b.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf4i_b(__m128i{0xabcdef1314156678, 0x1234123443214321}, 0x12)\n= 0x13ef13cd78667815 0x3412343421432121\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[(i &amp; ~0x3) + ((imm &gt;&gt; (2 * (i &amp; 0x3))) &amp; 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = a.byte[0 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[1] = a.byte[0 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[2] = a.byte[0 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[3] = a.byte[0 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[4] = a.byte[4 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[5] = a.byte[4 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[6] = a.byte[4 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[7] = a.byte[4 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[8] = a.byte[8 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[9] = a.byte[8 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[10] = a.byte[8 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[11] = a.byte[8 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[12] = a.byte[12 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[13] = a.byte[12 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[14] = a.byte[12 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[15] = a.byte[12 + ((imm &gt;&gt; 6) &amp; 0x3)];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vshuf4i_d (__m128i a, __m128i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vshuf4i_d (__m128i a, __m128i b, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vshuf4i.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nShuffle every four 64-bit elements in `a` and `b` with indices packed in `imm`, save the result to `dst`.\n\n![](../diagram/vshuf4i_d.svg)\n\n\n### Examples\n\n```c++\n__m128i __lsx_vshuf4i_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321}, 0x12)\n= 0xabcdef1314156678 0x1122334455667788\n```\n\n\n### Operation\n\n```c++\ndst.dword[0] = (imm & 2) ? b.dword[(imm & 1)] : a.dword[(imm & 1)];\ndst.dword[1] =\n    (imm & 8) ? b.dword[((imm >> 2) & 1)] : a.dword[((imm >> 2) & 1)];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf4i_d (__m128i a, __m128i b, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vshuf4i.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle every four 64-bit elements in <code>a</code> and <code>b</code> with indices packed in <code>imm</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/vshuf4i_d.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf4i_d(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321}, 0x12)\n= 0xabcdef1314156678 0x1122334455667788\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst.dword[0] = (imm &amp; 2) ? b.dword[(imm &amp; 1)] : a.dword[(imm &amp; 1)];\ndst.dword[1] =\n    (imm &amp; 8) ? b.dword[((imm &gt;&gt; 2) &amp; 1)] : a.dword[((imm &gt;&gt; 2) &amp; 1)];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vshuf4i_h (__m128i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vshuf4i_h (__m128i a, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vshuf4i.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nShuffle every four 16-bit elements in `a` with indices packed in `imm`, save the result to `dst`.\n\n![](../diagram/vshuf4i_h.svg)\n\n\n### Examples\n\n```c++\n__m128i __lsx_vshuf4i_h(__m128i{0xabcdef1314156678, 0x1234123443214321}, 0x12)\n= 0x667814156678ef13 0x4321432143211234\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[(i & ~0x3) + ((imm >> (2 * (i & 0x3))) & 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = a.half[0 + ((imm >> 0) & 0x3)];\n  dst.half[1] = a.half[0 + ((imm >> 2) & 0x3)];\n  dst.half[2] = a.half[0 + ((imm >> 4) & 0x3)];\n  dst.half[3] = a.half[0 + ((imm >> 6) & 0x3)];\n  dst.half[4] = a.half[4 + ((imm >> 0) & 0x3)];\n  dst.half[5] = a.half[4 + ((imm >> 2) & 0x3)];\n  dst.half[6] = a.half[4 + ((imm >> 4) & 0x3)];\n  dst.half[7] = a.half[4 + ((imm >> 6) & 0x3)];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf4i_h (__m128i a, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vshuf4i.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle every four 16-bit elements in <code>a</code> with indices packed in <code>imm</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/vshuf4i_h.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf4i_h(__m128i{0xabcdef1314156678, 0x1234123443214321}, 0x12)\n= 0x667814156678ef13 0x4321432143211234\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[(i &amp; ~0x3) + ((imm &gt;&gt; (2 * (i &amp; 0x3))) &amp; 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = a.half[0 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.half[1] = a.half[0 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.half[2] = a.half[0 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.half[3] = a.half[0 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.half[4] = a.half[4 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.half[5] = a.half[4 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.half[6] = a.half[4 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.half[7] = a.half[4 + ((imm &gt;&gt; 6) &amp; 0x3)];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vshuf4i_w (__m128i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vshuf4i_w (__m128i a, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vshuf4i.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nShuffle every four 32-bit elements in `a` with indices packed in `imm`, save the result to `dst`.\n\n![](../diagram/vshuf4i_w.svg)\n\n\n### Examples\n\n```c++\n__m128i __lsx_vshuf4i_w(__m128i{0xabcdef1314156678, 0x1234123443214321}, 0x12)\n= 0x1415667843214321 0x14156678abcdef13\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[(i & ~0x3) + ((imm >> (2 * (i & 0x3))) & 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = a.word[0 + ((imm >> 0) & 0x3)];\n  dst.word[1] = a.word[0 + ((imm >> 2) & 0x3)];\n  dst.word[2] = a.word[0 + ((imm >> 4) & 0x3)];\n  dst.word[3] = a.word[0 + ((imm >> 6) & 0x3)];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf4i_w (__m128i a, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vshuf4i.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle every four 32-bit elements in <code>a</code> with indices packed in <code>imm</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/vshuf4i_w.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf4i_w(__m128i{0xabcdef1314156678, 0x1234123443214321}, 0x12)\n= 0x1415667843214321 0x14156678abcdef13\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[(i &amp; ~0x3) + ((imm &gt;&gt; (2 * (i &amp; 0x3))) &amp; 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = a.word[0 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.word[1] = a.word[0 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.word[2] = a.word[0 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.word[3] = a.word[0 + ((imm &gt;&gt; 6) &amp; 0x3)];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vshuf_b (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vshuf_b (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vshuf.b vr, vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\n\nShuffle bytes from `a` and `b` with indices from `c`.\n\nCaveat: the indices are placed in `c`, while in other `vshuf` intrinsics, they are placed in `a`.\n\n\n![](../diagram/vshuf_b.svg)\n\n\n### Examples\n\n```c++\n__m128i __lsx_vshuf_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321}, __m128i{0x0011021304050607, 0x0811120213031404})\n= 0x7877155513efcdab 0x2177661555144413\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (c.byte[i] >= 64 && (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.byte[i] = 0;\n  } else if ((c.byte[i] % 32) < 16) {\n    dst.byte[i] = b.byte[c.byte[i] % 16];\n  } else {\n    dst.byte[i] = a.byte[c.byte[i] % 16];\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf_b (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vshuf.b vr, vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle bytes from <code>a</code> and <code>b</code> with indices from <code>c</code>.</p>\n<p>Caveat: the indices are placed in <code>c</code>, while in other <code>vshuf</code> intrinsics, they are placed in <code>a</code>.</p>\n<p><img alt=\"\" src=\"../diagram/vshuf_b.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf_b(__m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321}, __m128i{0x0011021304050607, 0x0811120213031404})\n= 0x7877155513efcdab 0x2177661555144413\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (c.byte[i] &gt;= 64 &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.byte[i] = 0;\n  } else if ((c.byte[i] % 32) &lt; 16) {\n    dst.byte[i] = b.byte[c.byte[i] % 16];\n  } else {\n    dst.byte[i] = a.byte[c.byte[i] % 16];\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vshuf_d (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vshuf_d (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vshuf.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nShuffle 64-bit elements in `b` and `c` with indices from `a`, save the result to `dst`.\n\n![](../diagram/vshuf_d.svg)\n\n\n### Examples\n\n```c++\n__m128i __lsx_vshuf_d(__m128i{0x0000000000000001, 0x0000000000000002}, __m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321})\n= 0x1234123443214321 0x1122334455667788\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if ((a.dword[i] % 256) >= 64 && (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.dword[i] = 0;\n  } else if ((a.dword[i] % 4) < 2) {\n    dst.dword[i] = c.dword[a.dword[i] % 2];\n  } else {\n    dst.dword[i] = b.dword[a.dword[i] % 2];\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf_d (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vshuf.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle 64-bit elements in <code>b</code> and <code>c</code> with indices from <code>a</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/vshuf_d.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf_d(__m128i{0x0000000000000001, 0x0000000000000002}, __m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321})\n= 0x1234123443214321 0x1122334455667788\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if ((a.dword[i] % 256) &gt;= 64 &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.dword[i] = 0;\n  } else if ((a.dword[i] % 4) &lt; 2) {\n    dst.dword[i] = c.dword[a.dword[i] % 2];\n  } else {\n    dst.dword[i] = b.dword[a.dword[i] % 2];\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vshuf_h (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vshuf_h (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vshuf.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nShuffle 16-bit elements in `b` and `c` with indices from `a`, save the result to `dst`.\n\n![](../diagram/vshuf_h.svg)\n\n\n### Examples\n\n```c++\n__m128i __lsx_vshuf_h(__m128i{0x0001000200030004, 0x0005000a000b000c}, __m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321})\n= 0x1415ef13abcd4321 0x432133441122ff00\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if ((a.half[i] % 256) >= 64 && (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.half[i] = 0;\n  } else if ((a.half[i] % 16) < 8) {\n    dst.half[i] = c.half[a.half[i] % 8];\n  } else {\n    dst.half[i] = b.half[a.half[i] % 8];\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf_h (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vshuf.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle 16-bit elements in <code>b</code> and <code>c</code> with indices from <code>a</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/vshuf_h.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf_h(__m128i{0x0001000200030004, 0x0005000a000b000c}, __m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321})\n= 0x1415ef13abcd4321 0x432133441122ff00\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if ((a.half[i] % 256) &gt;= 64 &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.half[i] = 0;\n  } else if ((a.half[i] % 16) &lt; 8) {\n    dst.half[i] = c.half[a.half[i] % 8];\n  } else {\n    dst.half[i] = b.half[a.half[i] % 8];\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vshuf_w (__m128i a, __m128i b, __m128i c)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vshuf_w (__m128i a, __m128i b, __m128i c)\n#include <lsxintrin.h>\nInstruction: vshuf.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nShuffle 32-bit elements in `b` and `c` with indices from `a`, save the result to `dst`.\n\n![](../diagram/vshuf_w.svg)\n\n\n### Examples\n\n```c++\n__m128i __lsx_vshuf_w(__m128i{0x0000000200000004, 0x0000000700000005}, __m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321})\n= 0x4321432155667788 0x99aabbcc11223344\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if ((a.word[i] % 256) >= 64 && (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.word[i] = 0;\n  } else if ((a.word[i] % 8) < 4) {\n    dst.word[i] = c.word[a.word[i] % 4];\n  } else {\n    dst.word[i] = b.word[a.word[i] % 4];\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf_w (__m128i a, __m128i b, __m128i c)\n#include &lt;lsxintrin.h&gt;\nInstruction: vshuf.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle 32-bit elements in <code>b</code> and <code>c</code> with indices from <code>a</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/vshuf_w.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vshuf_w(__m128i{0x0000000200000004, 0x0000000700000005}, __m128i{0x1122334455667788, 0x99aabbccddeeff00}, __m128i{0xabcdef1314156678, 0x1234123443214321})\n= 0x4321432155667788 0x99aabbcc11223344\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if ((a.word[i] % 256) &gt;= 64 &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.word[i] = 0;\n  } else if ((a.word[i] % 8) &lt; 4) {\n    dst.word[i] = c.word[a.word[i] % 4];\n  } else {\n    dst.word[i] = b.word[a.word[i] % 4];\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsigncov_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsigncov_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsigncov.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nIf the 8-bit element in `a` equals to zero, set the result to zero. If the signed 8-bit element in `a` is positive, copy element in `b` to result. Otherwise, copy negated element in `b` to result. If `a` and `b` are the same vectors, it is equivalent to computing absolute value.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] =\n      (a.byte[i] == 0) ? 0 : ((s8)a.byte[i] > 0 ? b.byte[i] : -b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsigncov_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsigncov.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>If the 8-bit element in <code>a</code> equals to zero, set the result to zero. If the signed 8-bit element in <code>a</code> is positive, copy element in <code>b</code> to result. Otherwise, copy negated element in <code>b</code> to result. If <code>a</code> and <code>b</code> are the same vectors, it is equivalent to computing absolute value.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] =\n      (a.byte[i] == 0) ? 0 : ((s8)a.byte[i] &gt; 0 ? b.byte[i] : -b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsigncov_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsigncov_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsigncov.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nIf the 64-bit element in `a` equals to zero, set the result to zero. If the signed 64-bit element in `a` is positive, copy element in `b` to result. Otherwise, copy negated element in `b` to result. If `a` and `b` are the same vectors, it is equivalent to computing absolute value.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] =\n      (a.dword[i] == 0) ? 0 : ((s64)a.dword[i] > 0 ? b.dword[i] : -b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsigncov_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsigncov.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>If the 64-bit element in <code>a</code> equals to zero, set the result to zero. If the signed 64-bit element in <code>a</code> is positive, copy element in <code>b</code> to result. Otherwise, copy negated element in <code>b</code> to result. If <code>a</code> and <code>b</code> are the same vectors, it is equivalent to computing absolute value.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] =\n      (a.dword[i] == 0) ? 0 : ((s64)a.dword[i] &gt; 0 ? b.dword[i] : -b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsigncov_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsigncov_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsigncov.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nIf the 16-bit element in `a` equals to zero, set the result to zero. If the signed 16-bit element in `a` is positive, copy element in `b` to result. Otherwise, copy negated element in `b` to result. If `a` and `b` are the same vectors, it is equivalent to computing absolute value.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (a.half[i] == 0) ? 0 : ((s16)a.half[i] > 0 ? b.half[i] : -b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsigncov_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsigncov.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>If the 16-bit element in <code>a</code> equals to zero, set the result to zero. If the signed 16-bit element in <code>a</code> is positive, copy element in <code>b</code> to result. Otherwise, copy negated element in <code>b</code> to result. If <code>a</code> and <code>b</code> are the same vectors, it is equivalent to computing absolute value.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (a.half[i] == 0) ? 0 : ((s16)a.half[i] &gt; 0 ? b.half[i] : -b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsigncov_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsigncov_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsigncov.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nIf the 32-bit element in `a` equals to zero, set the result to zero. If the signed 32-bit element in `a` is positive, copy element in `b` to result. Otherwise, copy negated element in `b` to result. If `a` and `b` are the same vectors, it is equivalent to computing absolute value.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] =\n      (a.word[i] == 0) ? 0 : ((s32)a.word[i] > 0 ? b.word[i] : -b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsigncov_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsigncov.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>If the 32-bit element in <code>a</code> equals to zero, set the result to zero. If the signed 32-bit element in <code>a</code> is positive, copy element in <code>b</code> to result. Otherwise, copy negated element in <code>b</code> to result. If <code>a</code> and <code>b</code> are the same vectors, it is equivalent to computing absolute value.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] =\n      (a.word[i] == 0) ? 0 : ((s32)a.word[i] &gt; 0 ? b.word[i] : -b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsle_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsle_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsle.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 8-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] <= (s8)b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsle_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsle.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &lt;= (s8)b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsle_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsle_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsle.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 8-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] <= (u8)b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsle_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsle.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &lt;= (u8)b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsle_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsle_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsle.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 64-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] <= (s64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsle_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsle.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &lt;= (s64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsle_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsle_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsle.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 64-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] <= (u64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsle_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsle.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &lt;= (u64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsle_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsle_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsle.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 16-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i] <= (s16)b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsle_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsle.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i] &lt;= (s16)b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsle_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsle_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsle.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 16-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((u16)a.half[i] <= (u16)b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsle_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsle.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((u16)a.half[i] &lt;= (u16)b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsle_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsle_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsle.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 32-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i] <= (s32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsle_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsle.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i] &lt;= (s32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsle_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsle_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsle.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 32-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((u32)a.word[i] <= (u32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsle_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsle.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((u32)a.word[i] &lt;= (u32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslei_b (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslei_b (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vslei.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 8-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] <= imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslei_b (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslei.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &lt;= imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslei_bu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslei_bu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslei.bu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 8-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] <= imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslei_bu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslei.bu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &lt;= imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslei_d (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslei_d (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vslei.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 64-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] <= imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslei_d (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslei.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &lt;= imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslei_du (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslei_du (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslei.du vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 64-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] <= imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslei_du (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslei.du vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &lt;= imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslei_h (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslei_h (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vslei.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 16-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i] <= imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslei_h (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslei.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i] &lt;= imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslei_hu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslei_hu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslei.hu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 16-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((u16)a.half[i] <= imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslei_hu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslei.hu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((u16)a.half[i] &lt;= imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslei_w (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslei_w (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vslei.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 32-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i] <= imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslei_w (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslei.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i] &lt;= imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslei_wu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslei_wu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslei.wu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 32-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((u32)a.word[i] <= imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslei_wu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslei.wu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((u32)a.word[i] &lt;= imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsll_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsll_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsll.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical left shift the unsigned 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] << (b.byte[i] & 0x7);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsll_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsll.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] &lt;&lt; (b.byte[i] &amp; 0x7);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsll_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsll_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsll.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical left shift the unsigned 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] << (b.dword[i] & 0x3f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsll_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsll.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] &lt;&lt; (b.dword[i] &amp; 0x3f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsll_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsll_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsll.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical left shift the unsigned 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] << (b.half[i] & 0xf);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsll_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsll.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] &lt;&lt; (b.half[i] &amp; 0xf);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsll_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsll_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsll.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical left shift the unsigned 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] << (b.word[i] & 0x1f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsll_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsll.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] &lt;&lt; (b.word[i] &amp; 0x1f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslli_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslli_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vslli.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical left shift the unsigned 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslli_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslli.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslli_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslli_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vslli.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical left shift the unsigned 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslli_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslli.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslli_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslli_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vslli.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical left shift the unsigned 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslli_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslli.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslli_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslli_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslli.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical left shift the unsigned 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslli_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslli.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsllwil_d_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsllwil_d_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsllwil.d.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtend and shift signed 32-bit elements in `a` by `imm` to signed 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsllwil_d_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsllwil.d.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift signed 32-bit elements in <code>a</code> by <code>imm</code> to signed 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsllwil_du_wu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsllwil_du_wu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsllwil.du.wu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtend and shift unsigned 32-bit elements in `a` by `imm` to unsigned 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsllwil_du_wu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsllwil.du.wu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift unsigned 32-bit elements in <code>a</code> by <code>imm</code> to unsigned 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsllwil_h_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsllwil_h_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vsllwil.h.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtend and shift signed 8-bit elements in `a` by `imm` to signed 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsllwil_h_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsllwil.h.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift signed 8-bit elements in <code>a</code> by <code>imm</code> to signed 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsllwil_hu_bu (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsllwil_hu_bu (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vsllwil.hu.bu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtend and shift unsigned 8-bit elements in `a` by `imm` to unsigned 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsllwil_hu_bu (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsllwil.hu.bu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift unsigned 8-bit elements in <code>a</code> by <code>imm</code> to unsigned 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsllwil_w_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsllwil_w_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsllwil.w.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtend and shift signed 16-bit elements in `a` by `imm` to signed 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsllwil_w_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsllwil.w.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift signed 16-bit elements in <code>a</code> by <code>imm</code> to signed 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsllwil_wu_hu (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsllwil_wu_hu (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsllwil.wu.hu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nExtend and shift unsigned 16-bit elements in `a` by `imm` to unsigned 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsllwil_wu_hu (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsllwil.wu.hu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift unsigned 16-bit elements in <code>a</code> by <code>imm</code> to unsigned 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslt_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslt_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vslt.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 8-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] < (s8)b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslt_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslt.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &lt; (s8)b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslt_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslt_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vslt.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 8-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] < (u8)b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslt_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslt.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &lt; (u8)b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslt_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslt_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vslt.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 64-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] < (s64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslt_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslt.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &lt; (s64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslt_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslt_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vslt.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 64-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] < (u64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslt_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslt.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &lt; (u64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslt_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslt_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vslt.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 16-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i] < (s16)b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslt_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslt.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i] &lt; (s16)b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslt_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslt_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vslt.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 16-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((u16)a.half[i] < (u16)b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslt_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslt.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((u16)a.half[i] &lt; (u16)b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslt_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslt_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vslt.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 32-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i] < (s32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslt_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslt.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i] &lt; (s32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslt_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslt_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vslt.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 32-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((u32)a.word[i] < (u32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslt_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslt.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((u32)a.word[i] &lt; (u32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslti_b (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslti_b (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vslti.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 8-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] < imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslti_b (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslti.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &lt; imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslti_bu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslti_bu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslti.bu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 8-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] < imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslti_bu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslti.bu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &lt; imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslti_d (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslti_d (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vslti.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 64-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] < imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslti_d (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslti.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &lt; imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslti_du (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslti_du (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslti.du vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 64-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] < imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslti_du (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslti.du vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &lt; imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslti_h (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslti_h (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vslti.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 16-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i] < imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslti_h (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslti.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i] &lt; imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslti_hu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslti_hu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslti.hu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 16-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((u16)a.half[i] < imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslti_hu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslti.hu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((u16)a.half[i] &lt; imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslti_w (__m128i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslti_w (__m128i a, imm_n16_15 imm)\n#include <lsxintrin.h>\nInstruction: vslti.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the signed 32-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i] < imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslti_w (__m128i a, imm_n16_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslti.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i] &lt; imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vslti_wu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vslti_wu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vslti.wu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompare the unsigned 32-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((u32)a.word[i] < imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vslti_wu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vslti.wu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((u32)a.word[i] &lt; imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsra_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsra_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsra.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i]) >> (b.byte[i] & 0x7);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsra_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsra.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i]) &gt;&gt; (b.byte[i] &amp; 0x7);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsra_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsra_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsra.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i]) >> (b.dword[i] & 0x3f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsra_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsra.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i]) &gt;&gt; (b.dword[i] &amp; 0x3f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsra_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsra_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsra.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i]) >> (b.half[i] & 0xf);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsra_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsra.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i]) &gt;&gt; (b.half[i] &amp; 0xf);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsra_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsra_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsra.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i]) >> (b.word[i] & 0x1f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsra_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsra.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i]) &gt;&gt; (b.word[i] &amp; 0x1f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrai_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrai_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vsrai.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i]) >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrai_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrai.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = ((s8)a.byte[i]) &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrai_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrai_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsrai.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i]) >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrai_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrai.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = ((s64)a.dword[i]) &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrai_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrai_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsrai.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = ((s16)a.half[i]) >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrai_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrai.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = ((s16)a.half[i]) &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrai_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrai_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsrai.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = ((s32)a.word[i]) >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrai_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrai.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = ((s32)a.word[i]) &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsran_b_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsran_b_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsran.b.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by elements in `b`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i < 8) ? (s8)((s16)a.half[i] >> (b.half[i] & 15)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsran_b_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsran.b.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i &lt; 8) ? (s8)((s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsran_h_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsran_h_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsran.h.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by elements in `b`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i < 4) ? (s16)((s32)a.word[i] >> (b.word[i] & 31)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsran_h_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsran.h.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i &lt; 4) ? (s16)((s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsran_w_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsran_w_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsran.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by elements in `b`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? (s32)((s64)a.dword[i] >> (b.dword[i] & 63)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsran_w_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsran.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? (s32)((s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrani_b_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrani_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsrani.b.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` and `b` by `imm`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] =\n      (i < 8) ? (s8)((s16)b.half[i] >> imm) : (s8)((s16)a.half[i - 8] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrani_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrani.b.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] =\n      (i &lt; 8) ? (s8)((s16)b.half[i] &gt;&gt; imm) : (s8)((s16)a.half[i - 8] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrani_d_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrani_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vsrani.d.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 128-bit elements in `a` and `b` by `imm`, truncate to 64-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i < 1) ? (s64)((s128)b.qword[i] >> imm)\n                         : (s64)((s128)a.qword[i - 1] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrani_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrani.d.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 64-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i &lt; 1) ? (s64)((s128)b.qword[i] &gt;&gt; imm)\n                         : (s64)((s128)a.qword[i - 1] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrani_h_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrani_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsrani.h.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` and `b` by `imm`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (i < 4) ? (s16)((s32)b.word[i] >> imm) : (s16)((s32)a.word[i - 4] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrani_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrani.h.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (i &lt; 4) ? (s16)((s32)b.word[i] &gt;&gt; imm) : (s16)((s32)a.word[i - 4] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrani_w_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrani_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsrani.w.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` and `b` by `imm`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? (s32)((s64)b.dword[i] >> imm)\n                        : (s32)((s64)a.dword[i - 2] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrani_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrani.w.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? (s32)((s64)b.dword[i] &gt;&gt; imm)\n                        : (s32)((s64)a.dword[i - 2] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrar_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrar_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrar.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if ((b.byte[i] & 0x7) == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = ((s8)a.byte[i] >> (b.byte[i] & 0x7)) +\n                  (((s8)a.byte[i] >> ((b.byte[i] & 0x7) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrar_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrar.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if ((b.byte[i] &amp; 0x7) == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = ((s8)a.byte[i] &gt;&gt; (b.byte[i] &amp; 0x7)) +\n                  (((s8)a.byte[i] &gt;&gt; ((b.byte[i] &amp; 0x7) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrar_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrar_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrar.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if ((b.dword[i] & 0x3f) == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = ((s64)a.dword[i] >> (b.dword[i] & 0x3f)) +\n                   (((s64)a.dword[i] >> ((b.dword[i] & 0x3f) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrar_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrar.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if ((b.dword[i] &amp; 0x3f) == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = ((s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 0x3f)) +\n                   (((s64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 0x3f) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrar_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrar_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrar.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if ((b.half[i] & 0xf) == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = ((s16)a.half[i] >> (b.half[i] & 0xf)) +\n                  (((s16)a.half[i] >> ((b.half[i] & 0xf) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrar_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrar.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if ((b.half[i] &amp; 0xf) == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = ((s16)a.half[i] &gt;&gt; (b.half[i] &amp; 0xf)) +\n                  (((s16)a.half[i] &gt;&gt; ((b.half[i] &amp; 0xf) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrar_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrar_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrar.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if ((b.word[i] & 0x1f) == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = ((s32)a.word[i] >> (b.word[i] & 0x1f)) +\n                  (((s32)a.word[i] >> ((b.word[i] & 0x1f) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrar_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrar.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if ((b.word[i] &amp; 0x1f) == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = ((s32)a.word[i] &gt;&gt; (b.word[i] &amp; 0x1f)) +\n                  (((s32)a.word[i] &gt;&gt; ((b.word[i] &amp; 0x1f) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrari_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrari_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vsrari.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (imm == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = ((s8)a.byte[i] >> imm) + (((s8)a.byte[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrari_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrari.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (imm == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = ((s8)a.byte[i] &gt;&gt; imm) + (((s8)a.byte[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrari_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrari_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsrari.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (imm == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] =\n        ((s64)a.dword[i] >> imm) + (((s64)a.dword[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrari_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrari.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (imm == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] =\n        ((s64)a.dword[i] &gt;&gt; imm) + (((s64)a.dword[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrari_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrari_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsrari.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (imm == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] =\n        ((s16)a.half[i] >> imm) + (((s16)a.half[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrari_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrari.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (imm == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] =\n        ((s16)a.half[i] &gt;&gt; imm) + (((s16)a.half[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrari_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrari_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsrari.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (imm == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] =\n        ((s32)a.word[i] >> imm) + (((s32)a.word[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrari_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrari.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (imm == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] =\n        ((s32)a.word[i] &gt;&gt; imm) + (((s32)a.word[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrarn_b_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrarn_b_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrarn.b.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by elements in `b`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u8 shift = (b.half[i] & 15);\n    if (shift == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i] >> shift) +\n                         (((s16)a.half[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrarn_b_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrarn.b.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u8 shift = (b.half[i] &amp; 15);\n    if (shift == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i] &gt;&gt; shift) +\n                         (((s16)a.half[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrarn_h_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrarn_h_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrarn.h.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by elements in `b`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u8 shift = (b.word[i] & 31);\n    if (shift == 0) {\n      dst.half[i] = (s16)(s32)a.word[i];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i] >> shift) +\n                          (((s32)a.word[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrarn_h_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrarn.h.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u8 shift = (b.word[i] &amp; 31);\n    if (shift == 0) {\n      dst.half[i] = (s16)(s32)a.word[i];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i] &gt;&gt; shift) +\n                          (((s32)a.word[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrarn_w_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrarn_w_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrarn.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by elements in `b`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u8 shift = (b.dword[i] & 63);\n    if (shift == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i] >> shift) +\n                          (((s64)a.dword[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrarn_w_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrarn.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u8 shift = (b.dword[i] &amp; 63);\n    if (shift == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i] &gt;&gt; shift) +\n                          (((s64)a.dword[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrarni_b_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrarni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsrarni.b.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` and `b` by `imm`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)b.half[i];\n    } else {\n      dst.byte[i] =\n          (s8)(((s16)b.half[i] >> imm) + (((s16)b.half[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i - 8] >> imm) +\n                         (((s16)a.half[i - 8] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrarni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrarni.b.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)b.half[i];\n    } else {\n      dst.byte[i] =\n          (s8)(((s16)b.half[i] &gt;&gt; imm) + (((s16)b.half[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i - 8] &gt;&gt; imm) +\n                         (((s16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrarni_d_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrarni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vsrarni.d.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 128-bit elements in `a` and `b` by `imm`, truncate to 64-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)b.qword[i];\n    } else {\n      dst.dword[i] = (s64)(((s128)b.qword[i] >> imm) +\n                           (((s128)b.qword[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)a.qword[i - 1];\n    } else {\n      dst.dword[i] = (s64)(((s128)a.qword[i - 1] >> imm) +\n                           (((s128)a.qword[i - 1] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrarni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrarni.d.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 64-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)b.qword[i];\n    } else {\n      dst.dword[i] = (s64)(((s128)b.qword[i] &gt;&gt; imm) +\n                           (((s128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)a.qword[i - 1];\n    } else {\n      dst.dword[i] = (s64)(((s128)a.qword[i - 1] &gt;&gt; imm) +\n                           (((s128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrarni_h_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrarni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsrarni.h.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` and `b` by `imm`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)b.word[i];\n    } else {\n      dst.half[i] = (s16)(((s32)b.word[i] >> imm) +\n                          (((s32)b.word[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)a.word[i - 4];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i - 4] >> imm) +\n                          (((s32)a.word[i - 4] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrarni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrarni.h.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)b.word[i];\n    } else {\n      dst.half[i] = (s16)(((s32)b.word[i] &gt;&gt; imm) +\n                          (((s32)b.word[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)a.word[i - 4];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i - 4] &gt;&gt; imm) +\n                          (((s32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrarni_w_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrarni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsrarni.w.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` and `b` by `imm`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)b.dword[i];\n    } else {\n      dst.word[i] = (s32)(((s64)b.dword[i] >> imm) +\n                          (((s64)b.dword[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i - 2] >> imm) +\n                          (((s64)a.dword[i - 2] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrarni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrarni.w.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)b.dword[i];\n    } else {\n      dst.word[i] = (s32)(((s64)b.dword[i] &gt;&gt; imm) +\n                          (((s64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i - 2] &gt;&gt; imm) +\n                          (((s64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrl_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrl_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrl.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] >> (b.byte[i] & 0x7);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrl_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrl.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] &gt;&gt; (b.byte[i] &amp; 0x7);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrl_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrl_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrl.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] >> (b.dword[i] & 0x3f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrl_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrl.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] &gt;&gt; (b.dword[i] &amp; 0x3f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrl_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrl_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrl.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] >> (b.half[i] & 0xf);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrl_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrl.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] &gt;&gt; (b.half[i] &amp; 0xf);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrl_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrl_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrl.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] >> (b.word[i] & 0x1f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrl_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrl.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] &gt;&gt; (b.word[i] &amp; 0x1f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrli_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrli_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vsrli.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrli_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrli.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrli_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrli_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsrli.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrli_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrli.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrli_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrli_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsrli.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrli_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrli.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrli_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrli_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsrli.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrli_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrli.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrln_b_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrln_b_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrln.b.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by elements in `b`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i < 8) ? (u8)((u16)a.half[i] >> (b.half[i] & 15)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrln_b_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrln.b.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i &lt; 8) ? (u8)((u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrln_h_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrln_h_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrln.h.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by elements in `b`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i < 4) ? (u16)((u32)a.word[i] >> (b.word[i] & 31)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrln_h_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrln.h.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i &lt; 4) ? (u16)((u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrln_w_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrln_w_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrln.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by elements in `b`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? (u32)((u64)a.dword[i] >> (b.dword[i] & 63)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrln_w_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrln.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? (u32)((u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlni_b_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsrlni.b.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` and `b` by `imm`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] =\n      (i < 8) ? (u8)((u16)b.half[i] >> imm) : (u8)((u16)a.half[i - 8] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlni.b.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] =\n      (i &lt; 8) ? (u8)((u16)b.half[i] &gt;&gt; imm) : (u8)((u16)a.half[i - 8] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlni_d_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vsrlni.d.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 128-bit elements in `a` and `b` by `imm`, truncate to 64-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i < 1) ? (u64)((u128)b.qword[i] >> imm)\n                         : (u64)((u128)a.qword[i - 1] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlni.d.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 64-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i &lt; 1) ? (u64)((u128)b.qword[i] &gt;&gt; imm)\n                         : (u64)((u128)a.qword[i - 1] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlni_h_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsrlni.h.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` and `b` by `imm`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (i < 4) ? (u16)((u32)b.word[i] >> imm) : (u16)((u32)a.word[i - 4] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlni.h.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (i &lt; 4) ? (u16)((u32)b.word[i] &gt;&gt; imm) : (u16)((u32)a.word[i - 4] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlni_w_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsrlni.w.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` and `b` by `imm`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? (u32)((u64)b.dword[i] >> imm)\n                        : (u32)((u64)a.dword[i - 2] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlni.w.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? (u32)((u64)b.dword[i] &gt;&gt; imm)\n                        : (u32)((u64)a.dword[i - 2] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlr_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlr_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrlr.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if ((b.byte[i] & 0x7) == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = (a.byte[i] >> (b.byte[i] & 0x7)) +\n                  ((a.byte[i] >> ((b.byte[i] & 0x7) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlr_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlr.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if ((b.byte[i] &amp; 0x7) == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = (a.byte[i] &gt;&gt; (b.byte[i] &amp; 0x7)) +\n                  ((a.byte[i] &gt;&gt; ((b.byte[i] &amp; 0x7) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlr_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlr_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrlr.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if ((b.dword[i] & 0x3f) == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = (a.dword[i] >> (b.dword[i] & 0x3f)) +\n                   ((a.dword[i] >> ((b.dword[i] & 0x3f) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlr_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlr.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if ((b.dword[i] &amp; 0x3f) == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = (a.dword[i] &gt;&gt; (b.dword[i] &amp; 0x3f)) +\n                   ((a.dword[i] &gt;&gt; ((b.dword[i] &amp; 0x3f) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlr_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlr_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrlr.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if ((b.half[i] & 0xf) == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = (a.half[i] >> (b.half[i] & 0xf)) +\n                  ((a.half[i] >> ((b.half[i] & 0xf) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlr_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlr.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if ((b.half[i] &amp; 0xf) == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = (a.half[i] &gt;&gt; (b.half[i] &amp; 0xf)) +\n                  ((a.half[i] &gt;&gt; ((b.half[i] &amp; 0xf) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlr_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlr_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrlr.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if ((b.word[i] & 0x1f) == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = (a.word[i] >> (b.word[i] & 0x1f)) +\n                  ((a.word[i] >> ((b.word[i] & 0x1f) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlr_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlr.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if ((b.word[i] &amp; 0x1f) == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = (a.word[i] &gt;&gt; (b.word[i] &amp; 0x1f)) +\n                  ((a.word[i] &gt;&gt; ((b.word[i] &amp; 0x1f) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlri_b (__m128i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlri_b (__m128i a, imm0_7 imm)\n#include <lsxintrin.h>\nInstruction: vsrlri.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (imm == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = (a.byte[i] >> imm) + ((a.byte[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlri_b (__m128i a, imm0_7 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlri.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (imm == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = (a.byte[i] &gt;&gt; imm) + ((a.byte[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlri_d (__m128i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlri_d (__m128i a, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsrlri.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (imm == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = (a.dword[i] >> imm) + ((a.dword[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlri_d (__m128i a, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlri.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (imm == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = (a.dword[i] &gt;&gt; imm) + ((a.dword[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlri_h (__m128i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlri_h (__m128i a, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsrlri.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (imm == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = (a.half[i] >> imm) + ((a.half[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlri_h (__m128i a, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlri.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (imm == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = (a.half[i] &gt;&gt; imm) + ((a.half[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlri_w (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlri_w (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsrlri.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (imm == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = (a.word[i] >> imm) + ((a.word[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlri_w (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlri.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (imm == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = (a.word[i] &gt;&gt; imm) + ((a.word[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlrn_b_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlrn_b_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrlrn.b.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by elements in `b`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u8 shift = (b.half[i] & 15);\n    if (shift == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i] >> shift) +\n                         (((u16)a.half[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlrn_b_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlrn.b.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u8 shift = (b.half[i] &amp; 15);\n    if (shift == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i] &gt;&gt; shift) +\n                         (((u16)a.half[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlrn_h_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlrn_h_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrlrn.h.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by elements in `b`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u8 shift = (b.word[i] & 31);\n    if (shift == 0) {\n      dst.half[i] = (u16)(u32)a.word[i];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i] >> shift) +\n                          (((u32)a.word[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlrn_h_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlrn.h.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u8 shift = (b.word[i] &amp; 31);\n    if (shift == 0) {\n      dst.half[i] = (u16)(u32)a.word[i];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i] &gt;&gt; shift) +\n                          (((u32)a.word[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlrn_w_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlrn_w_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsrlrn.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by elements in `b`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u8 shift = (b.dword[i] & 63);\n    if (shift == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i] >> shift) +\n                          (((u64)a.dword[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlrn_w_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlrn.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u8 shift = (b.dword[i] &amp; 63);\n    if (shift == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i] &gt;&gt; shift) +\n                          (((u64)a.dword[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlrni_b_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlrni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vsrlrni.b.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` and `b` by `imm`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)b.half[i];\n    } else {\n      dst.byte[i] =\n          (u8)(((u16)b.half[i] >> imm) + (((u16)b.half[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i - 8] >> imm) +\n                         (((u16)a.half[i - 8] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlrni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlrni.b.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)b.half[i];\n    } else {\n      dst.byte[i] =\n          (u8)(((u16)b.half[i] &gt;&gt; imm) + (((u16)b.half[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i - 8] &gt;&gt; imm) +\n                         (((u16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlrni_d_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlrni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vsrlrni.d.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 128-bit elements in `a` and `b` by `imm`, truncate to 64-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)b.qword[i];\n    } else {\n      dst.dword[i] = (u64)(((u128)b.qword[i] >> imm) +\n                           (((u128)b.qword[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)a.qword[i - 1];\n    } else {\n      dst.dword[i] = (u64)(((u128)a.qword[i - 1] >> imm) +\n                           (((u128)a.qword[i - 1] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlrni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlrni.d.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 64-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)b.qword[i];\n    } else {\n      dst.dword[i] = (u64)(((u128)b.qword[i] &gt;&gt; imm) +\n                           (((u128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)a.qword[i - 1];\n    } else {\n      dst.dword[i] = (u64)(((u128)a.qword[i - 1] &gt;&gt; imm) +\n                           (((u128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlrni_h_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlrni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsrlrni.h.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` and `b` by `imm`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)b.word[i];\n    } else {\n      dst.half[i] = (u16)(((u32)b.word[i] >> imm) +\n                          (((u32)b.word[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)a.word[i - 4];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i - 4] >> imm) +\n                          (((u32)a.word[i - 4] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlrni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlrni.h.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)b.word[i];\n    } else {\n      dst.half[i] = (u16)(((u32)b.word[i] &gt;&gt; imm) +\n                          (((u32)b.word[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)a.word[i - 4];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i - 4] &gt;&gt; imm) +\n                          (((u32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsrlrni_w_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsrlrni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vsrlrni.w.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` and `b` by `imm`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)b.dword[i];\n    } else {\n      dst.word[i] = (u32)(((u64)b.dword[i] >> imm) +\n                          (((u64)b.dword[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i - 2] >> imm) +\n                          (((u64)a.dword[i - 2] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsrlrni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsrlrni.w.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)b.dword[i];\n    } else {\n      dst.word[i] = (u32)(((u64)b.dword[i] &gt;&gt; imm) +\n                          (((u64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i - 2] &gt;&gt; imm) +\n                          (((u64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssran_b_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssran_b_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssran.b.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by elements in `b`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp = (s16)a.half[i] >> (b.half[i] & 15);\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssran_b_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssran.b.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp = (s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15);\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssran_bu_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssran_bu_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssran.bu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by elements in `b`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp = (s16)a.half[i] >> (b.half[i] & 15);\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssran_bu_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssran.bu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp = (s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15);\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssran_h_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssran_h_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssran.h.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by elements in `b`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp = (s32)a.word[i] >> (b.word[i] & 31);\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssran_h_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssran.h.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp = (s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31);\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssran_hu_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssran_hu_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssran.hu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by elements in `b`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp = (s32)a.word[i] >> (b.word[i] & 31);\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssran_hu_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssran.hu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp = (s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31);\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssran_w_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssran_w_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssran.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by elements in `b`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp = (s64)a.dword[i] >> (b.dword[i] & 63);\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssran_w_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssran.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp = (s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63);\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssran_wu_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssran_wu_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssran.wu.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by elements in `b`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp = (s64)a.dword[i] >> (b.dword[i] & 63);\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssran_wu_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssran.wu.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp = (s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63);\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrani_b_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrani_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vssrani.b.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` and `b` by `imm`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp = (s16)b.half[i] >> imm;\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    s16 temp = (s16)a.half[i - 8] >> imm;\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrani_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrani.b.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp = (s16)b.half[i] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    s16 temp = (s16)a.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrani_bu_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrani_bu_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vssrani.bu.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp = (s16)b.half[i] >> imm;\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    s16 temp = (s16)a.half[i - 8] >> imm;\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrani_bu_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrani.bu.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp = (s16)b.half[i] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    s16 temp = (s16)a.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrani_d_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrani_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vssrani.d.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 128-bit elements in `a` and `b` by `imm`, clamp to fit in signed 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    s128 temp = (s128)b.qword[i] >> imm;\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp = (s128)a.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrani_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrani.d.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    s128 temp = (s128)b.qword[i] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp = (s128)a.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrani_du_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrani_du_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vssrani.du.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 128-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    s128 temp = (s128)b.qword[i] >> imm;\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp = (s128)a.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrani_du_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrani.du.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    s128 temp = (s128)b.qword[i] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp = (s128)a.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrani_h_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrani_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vssrani.h.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` and `b` by `imm`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp = (s32)b.word[i] >> imm;\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    s32 temp = (s32)a.word[i - 4] >> imm;\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrani_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrani.h.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp = (s32)b.word[i] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    s32 temp = (s32)a.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrani_hu_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrani_hu_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vssrani.hu.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp = (s32)b.word[i] >> imm;\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    s32 temp = (s32)a.word[i - 4] >> imm;\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrani_hu_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrani.hu.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp = (s32)b.word[i] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    s32 temp = (s32)a.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrani_w_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrani_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vssrani.w.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` and `b` by `imm`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp = (s64)b.dword[i] >> imm;\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp = (s64)a.dword[i - 2] >> imm;\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrani_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrani.w.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp = (s64)b.dword[i] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp = (s64)a.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrani_wu_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrani_wu_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vssrani.wu.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp = (s64)b.dword[i] >> imm;\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    s64 temp = (s64)a.dword[i - 2] >> imm;\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrani_wu_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrani.wu.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp = (s64)b.dword[i] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    s64 temp = (s64)a.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarn_b_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarn_b_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrarn.b.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by elements in `b`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp;\n    if ((b.half[i] & 15) == 0) {\n      temp = (s16)a.half[i];\n    } else {\n      temp = ((s16)a.half[i] >> (b.half[i] & 15)) +\n             (((s16)a.half[i] >> ((b.half[i] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarn_b_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarn.b.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp;\n    if ((b.half[i] &amp; 15) == 0) {\n      temp = (s16)a.half[i];\n    } else {\n      temp = ((s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) +\n             (((s16)a.half[i] &gt;&gt; ((b.half[i] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarn_bu_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarn_bu_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrarn.bu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by elements in `b`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp;\n    if ((b.half[i] & 15) == 0) {\n      temp = (s16)a.half[i];\n    } else {\n      temp = ((s16)a.half[i] >> (b.half[i] & 15)) +\n             (((s16)a.half[i] >> ((b.half[i] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarn_bu_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarn.bu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp;\n    if ((b.half[i] &amp; 15) == 0) {\n      temp = (s16)a.half[i];\n    } else {\n      temp = ((s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) +\n             (((s16)a.half[i] &gt;&gt; ((b.half[i] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarn_h_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarn_h_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrarn.h.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by elements in `b`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp;\n    if ((b.word[i] & 31) == 0) {\n      temp = (s32)a.word[i];\n    } else {\n      temp = ((s32)a.word[i] >> (b.word[i] & 31)) +\n             (((s32)a.word[i] >> ((b.word[i] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarn_h_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarn.h.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp;\n    if ((b.word[i] &amp; 31) == 0) {\n      temp = (s32)a.word[i];\n    } else {\n      temp = ((s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) +\n             (((s32)a.word[i] &gt;&gt; ((b.word[i] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarn_hu_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarn_hu_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrarn.hu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by elements in `b`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp;\n    if ((b.word[i] & 31) == 0) {\n      temp = (s32)a.word[i];\n    } else {\n      temp = ((s32)a.word[i] >> (b.word[i] & 31)) +\n             (((s32)a.word[i] >> ((b.word[i] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarn_hu_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarn.hu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp;\n    if ((b.word[i] &amp; 31) == 0) {\n      temp = (s32)a.word[i];\n    } else {\n      temp = ((s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) +\n             (((s32)a.word[i] &gt;&gt; ((b.word[i] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarn_w_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarn_w_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrarn.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by elements in `b`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp;\n    if ((b.dword[i] & 63) == 0) {\n      temp = (s64)a.dword[i];\n    } else {\n      temp = ((s64)a.dword[i] >> (b.dword[i] & 63)) +\n             (((s64)a.dword[i] >> ((b.dword[i] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarn_w_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarn.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp;\n    if ((b.dword[i] &amp; 63) == 0) {\n      temp = (s64)a.dword[i];\n    } else {\n      temp = ((s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) +\n             (((s64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarn_wu_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarn_wu_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrarn.wu.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by elements in `b`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp;\n    if ((b.dword[i] & 63) == 0) {\n      temp = (s64)a.dword[i];\n    } else {\n      temp = ((s64)a.dword[i] >> (b.dword[i] & 63)) +\n             (((s64)a.dword[i] >> ((b.dword[i] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarn_wu_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarn.wu.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp;\n    if ((b.dword[i] &amp; 63) == 0) {\n      temp = (s64)a.dword[i];\n    } else {\n      temp = ((s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) +\n             (((s64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarni_b_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vssrarni.b.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` and `b` by `imm`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i];\n    } else {\n      temp = ((s16)b.half[i] >> imm) + (((s16)b.half[i] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp =\n          ((s16)a.half[i - 8] >> imm) + (((s16)a.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarni.b.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i];\n    } else {\n      temp = ((s16)b.half[i] &gt;&gt; imm) + (((s16)b.half[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp =\n          ((s16)a.half[i - 8] &gt;&gt; imm) + (((s16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarni_bu_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarni_bu_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vssrarni.bu.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i];\n    } else {\n      temp = ((s16)b.half[i] >> imm) + (((s16)b.half[i] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp =\n          ((s16)a.half[i - 8] >> imm) + (((s16)a.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarni_bu_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarni.bu.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i];\n    } else {\n      temp = ((s16)b.half[i] &gt;&gt; imm) + (((s16)b.half[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp =\n          ((s16)a.half[i - 8] &gt;&gt; imm) + (((s16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarni_d_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vssrarni.d.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 128-bit elements in `a` and `b` by `imm`, clamp to fit in signed 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i];\n    } else {\n      temp = ((s128)b.qword[i] >> imm) + (((s128)b.qword[i] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 1];\n    } else {\n      temp = ((s128)a.qword[i - 1] >> imm) +\n             (((s128)a.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarni.d.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i];\n    } else {\n      temp = ((s128)b.qword[i] &gt;&gt; imm) + (((s128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 1];\n    } else {\n      temp = ((s128)a.qword[i - 1] &gt;&gt; imm) +\n             (((s128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarni_du_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarni_du_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vssrarni.du.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 128-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i];\n    } else {\n      temp = ((s128)b.qword[i] >> imm) + (((s128)b.qword[i] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 1];\n    } else {\n      temp = ((s128)a.qword[i - 1] >> imm) +\n             (((s128)a.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarni_du_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarni.du.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i];\n    } else {\n      temp = ((s128)b.qword[i] &gt;&gt; imm) + (((s128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 1];\n    } else {\n      temp = ((s128)a.qword[i - 1] &gt;&gt; imm) +\n             (((s128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarni_h_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vssrarni.h.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` and `b` by `imm`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i];\n    } else {\n      temp = ((s32)b.word[i] >> imm) + (((s32)b.word[i] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp =\n          ((s32)a.word[i - 4] >> imm) + (((s32)a.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarni.h.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i];\n    } else {\n      temp = ((s32)b.word[i] &gt;&gt; imm) + (((s32)b.word[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp =\n          ((s32)a.word[i - 4] &gt;&gt; imm) + (((s32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarni_hu_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarni_hu_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vssrarni.hu.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i];\n    } else {\n      temp = ((s32)b.word[i] >> imm) + (((s32)b.word[i] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp =\n          ((s32)a.word[i - 4] >> imm) + (((s32)a.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarni_hu_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarni.hu.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i];\n    } else {\n      temp = ((s32)b.word[i] &gt;&gt; imm) + (((s32)b.word[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp =\n          ((s32)a.word[i - 4] &gt;&gt; imm) + (((s32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarni_w_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vssrarni.w.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` and `b` by `imm`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i];\n    } else {\n      temp = ((s64)b.dword[i] >> imm) + (((s64)b.dword[i] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] >> imm) +\n             (((s64)a.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarni.w.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i];\n    } else {\n      temp = ((s64)b.dword[i] &gt;&gt; imm) + (((s64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] &gt;&gt; imm) +\n             (((s64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrarni_wu_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrarni_wu_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vssrarni.wu.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i];\n    } else {\n      temp = ((s64)b.dword[i] >> imm) + (((s64)b.dword[i] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] >> imm) +\n             (((s64)a.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrarni_wu_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrarni.wu.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i];\n    } else {\n      temp = ((s64)b.dword[i] &gt;&gt; imm) + (((s64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] &gt;&gt; imm) +\n             (((s64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrln_b_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrln_b_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrln.b.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by elements in `b`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp = (u16)a.half[i] >> (b.half[i] & 15);\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrln_b_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrln.b.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp = (u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15);\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrln_bu_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrln_bu_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrln.bu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by elements in `b`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp = (u16)a.half[i] >> (b.half[i] & 15);\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrln_bu_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrln.bu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp = (u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15);\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrln_h_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrln_h_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrln.h.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by elements in `b`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp = (u32)a.word[i] >> (b.word[i] & 31);\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrln_h_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrln.h.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp = (u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31);\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrln_hu_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrln_hu_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrln.hu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by elements in `b`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp = (u32)a.word[i] >> (b.word[i] & 31);\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrln_hu_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrln.hu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp = (u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31);\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrln_w_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrln_w_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrln.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by elements in `b`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp = (u64)a.dword[i] >> (b.dword[i] & 63);\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrln_w_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrln.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp = (u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63);\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrln_wu_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrln_wu_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrln.wu.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by elements in `b`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp = (u64)a.dword[i] >> (b.dword[i] & 63);\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrln_wu_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrln.wu.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp = (u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63);\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlni_b_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vssrlni.b.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` and `b` by `imm`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp = (u16)b.half[i] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    u16 temp = (u16)a.half[i - 8] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlni.b.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp = (u16)b.half[i] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    u16 temp = (u16)a.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlni_bu_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlni_bu_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vssrlni.bu.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp = (u16)b.half[i] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    u16 temp = (u16)a.half[i - 8] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlni_bu_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlni.bu.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp = (u16)b.half[i] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    u16 temp = (u16)a.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlni_d_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vssrlni.d.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 128-bit elements in `a` and `b` by `imm`, clamp to fit in signed 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    u128 temp = (u128)b.qword[i] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp = (u128)a.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlni.d.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    u128 temp = (u128)b.qword[i] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp = (u128)a.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlni_du_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlni_du_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vssrlni.du.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 128-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    u128 temp = (u128)b.qword[i] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp = (u128)a.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlni_du_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlni.du.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    u128 temp = (u128)b.qword[i] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp = (u128)a.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlni_h_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vssrlni.h.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` and `b` by `imm`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp = (u32)b.word[i] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    u32 temp = (u32)a.word[i - 4] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlni.h.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp = (u32)b.word[i] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    u32 temp = (u32)a.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlni_hu_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlni_hu_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vssrlni.hu.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp = (u32)b.word[i] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    u32 temp = (u32)a.word[i - 4] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlni_hu_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlni.hu.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp = (u32)b.word[i] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    u32 temp = (u32)a.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlni_w_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vssrlni.w.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` and `b` by `imm`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp = (u64)b.dword[i] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    u64 temp = (u64)a.dword[i - 2] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlni.w.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp = (u64)b.dword[i] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    u64 temp = (u64)a.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlni_wu_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlni_wu_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vssrlni.wu.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp = (u64)b.dword[i] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    u64 temp = (u64)a.dword[i - 2] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlni_wu_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlni.wu.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp = (u64)b.dword[i] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    u64 temp = (u64)a.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrn_b_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrn_b_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrlrn.b.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by elements in `b`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp;\n    if ((b.half[i] & 15) == 0) {\n      temp = (u16)a.half[i];\n    } else {\n      temp = ((u16)a.half[i] >> (b.half[i] & 15)) +\n             (((u16)a.half[i] >> ((b.half[i] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrn_b_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrn.b.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp;\n    if ((b.half[i] &amp; 15) == 0) {\n      temp = (u16)a.half[i];\n    } else {\n      temp = ((u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) +\n             (((u16)a.half[i] &gt;&gt; ((b.half[i] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrn_bu_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrn_bu_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrlrn.bu.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by elements in `b`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp;\n    if ((b.half[i] & 15) == 0) {\n      temp = (u16)a.half[i];\n    } else {\n      temp = ((u16)a.half[i] >> (b.half[i] & 15)) +\n             (((u16)a.half[i] >> ((b.half[i] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrn_bu_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrn.bu.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp;\n    if ((b.half[i] &amp; 15) == 0) {\n      temp = (u16)a.half[i];\n    } else {\n      temp = ((u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) +\n             (((u16)a.half[i] &gt;&gt; ((b.half[i] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrn_h_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrn_h_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrlrn.h.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by elements in `b`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp;\n    if ((b.word[i] & 31) == 0) {\n      temp = (u32)a.word[i];\n    } else {\n      temp = ((u32)a.word[i] >> (b.word[i] & 31)) +\n             (((u32)a.word[i] >> ((b.word[i] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrn_h_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrn.h.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp;\n    if ((b.word[i] &amp; 31) == 0) {\n      temp = (u32)a.word[i];\n    } else {\n      temp = ((u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) +\n             (((u32)a.word[i] &gt;&gt; ((b.word[i] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrn_hu_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrn_hu_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrlrn.hu.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by elements in `b`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp;\n    if ((b.word[i] & 31) == 0) {\n      temp = (u32)a.word[i];\n    } else {\n      temp = ((u32)a.word[i] >> (b.word[i] & 31)) +\n             (((u32)a.word[i] >> ((b.word[i] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrn_hu_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrn.hu.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp;\n    if ((b.word[i] &amp; 31) == 0) {\n      temp = (u32)a.word[i];\n    } else {\n      temp = ((u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) +\n             (((u32)a.word[i] &gt;&gt; ((b.word[i] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrn_w_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrn_w_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrlrn.w.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by elements in `b`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp;\n    if ((b.dword[i] & 63) == 0) {\n      temp = (u64)a.dword[i];\n    } else {\n      temp = ((u64)a.dword[i] >> (b.dword[i] & 63)) +\n             (((u64)a.dword[i] >> ((b.dword[i] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrn_w_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrn.w.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp;\n    if ((b.dword[i] &amp; 63) == 0) {\n      temp = (u64)a.dword[i];\n    } else {\n      temp = ((u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) +\n             (((u64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrn_wu_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrn_wu_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssrlrn.wu.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by elements in `b`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp;\n    if ((b.dword[i] & 63) == 0) {\n      temp = (u64)a.dword[i];\n    } else {\n      temp = ((u64)a.dword[i] >> (b.dword[i] & 63)) +\n             (((u64)a.dword[i] >> ((b.dword[i] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrn_wu_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrn.wu.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp;\n    if ((b.dword[i] &amp; 63) == 0) {\n      temp = (u64)a.dword[i];\n    } else {\n      temp = ((u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) +\n             (((u64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrni_b_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vssrlrni.b.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` and `b` by `imm`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i];\n    } else {\n      temp = ((u16)b.half[i] >> imm) + (((u16)b.half[i] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp =\n          ((u16)a.half[i - 8] >> imm) + (((u16)a.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrni_b_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrni.b.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i];\n    } else {\n      temp = ((u16)b.half[i] &gt;&gt; imm) + (((u16)b.half[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp =\n          ((u16)a.half[i - 8] &gt;&gt; imm) + (((u16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrni_bu_h (__m128i a, __m128i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrni_bu_h (__m128i a, __m128i b, imm0_15 imm)\n#include <lsxintrin.h>\nInstruction: vssrlrni.bu.h vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i];\n    } else {\n      temp = ((u16)b.half[i] >> imm) + (((u16)b.half[i] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp =\n          ((u16)a.half[i - 8] >> imm) + (((u16)a.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrni_bu_h (__m128i a, __m128i b, imm0_15 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrni.bu.h vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i];\n    } else {\n      temp = ((u16)b.half[i] &gt;&gt; imm) + (((u16)b.half[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp =\n          ((u16)a.half[i - 8] &gt;&gt; imm) + (((u16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrni_d_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vssrlrni.d.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 128-bit elements in `a` and `b` by `imm`, clamp to fit in signed 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i];\n    } else {\n      temp = ((u128)b.qword[i] >> imm) + (((u128)b.qword[i] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 1];\n    } else {\n      temp = ((u128)a.qword[i - 1] >> imm) +\n             (((u128)a.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrni_d_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrni.d.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i];\n    } else {\n      temp = ((u128)b.qword[i] &gt;&gt; imm) + (((u128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 1];\n    } else {\n      temp = ((u128)a.qword[i - 1] &gt;&gt; imm) +\n             (((u128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrni_du_q (__m128i a, __m128i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrni_du_q (__m128i a, __m128i b, imm0_127 imm)\n#include <lsxintrin.h>\nInstruction: vssrlrni.du.q vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 128-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i];\n    } else {\n      temp = ((u128)b.qword[i] >> imm) + (((u128)b.qword[i] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 1];\n    } else {\n      temp = ((u128)a.qword[i - 1] >> imm) +\n             (((u128)a.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrni_du_q (__m128i a, __m128i b, imm0_127 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrni.du.q vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i];\n    } else {\n      temp = ((u128)b.qword[i] &gt;&gt; imm) + (((u128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 1];\n    } else {\n      temp = ((u128)a.qword[i - 1] &gt;&gt; imm) +\n             (((u128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrni_h_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vssrlrni.h.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` and `b` by `imm`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i];\n    } else {\n      temp = ((u32)b.word[i] >> imm) + (((u32)b.word[i] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp =\n          ((u32)a.word[i - 4] >> imm) + (((u32)a.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrni_h_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrni.h.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i];\n    } else {\n      temp = ((u32)b.word[i] &gt;&gt; imm) + (((u32)b.word[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp =\n          ((u32)a.word[i - 4] &gt;&gt; imm) + (((u32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrni_hu_w (__m128i a, __m128i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrni_hu_w (__m128i a, __m128i b, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vssrlrni.hu.w vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i];\n    } else {\n      temp = ((u32)b.word[i] >> imm) + (((u32)b.word[i] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp =\n          ((u32)a.word[i - 4] >> imm) + (((u32)a.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrni_hu_w (__m128i a, __m128i b, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrni.hu.w vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i];\n    } else {\n      temp = ((u32)b.word[i] &gt;&gt; imm) + (((u32)b.word[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp =\n          ((u32)a.word[i - 4] &gt;&gt; imm) + (((u32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrni_w_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vssrlrni.w.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` and `b` by `imm`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i];\n    } else {\n      temp = ((u64)b.dword[i] >> imm) + (((u64)b.dword[i] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] >> imm) +\n             (((u64)a.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrni_w_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrni.w.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i];\n    } else {\n      temp = ((u64)b.dword[i] &gt;&gt; imm) + (((u64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] &gt;&gt; imm) +\n             (((u64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssrlrni_wu_d (__m128i a, __m128i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssrlrni_wu_d (__m128i a, __m128i b, imm0_63 imm)\n#include <lsxintrin.h>\nInstruction: vssrlrni.wu.d vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i];\n    } else {\n      temp = ((u64)b.dword[i] >> imm) + (((u64)b.dword[i] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] >> imm) +\n             (((u64)a.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |\n| 2K1000LA | LA264 | 3 | 0.5(1/2) |\n| 2K3000 | LA364E | 3 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssrlrni_wu_d (__m128i a, __m128i b, imm0_63 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssrlrni.wu.d vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i];\n    } else {\n      temp = ((u64)b.dword[i] &gt;&gt; imm) + (((u64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] &gt;&gt; imm) +\n             (((u64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>3</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssub_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssub_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssub.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating subtract the signed 8-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (s8)ssub((s8)a.byte[i], (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssub_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssub.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the signed 8-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (s8)ssub((s8)a.byte[i], (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssub_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssub_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssub.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating subtract the unsigned 8-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (u8)ssub((u8)a.byte[i], (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssub_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssub.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the unsigned 8-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (u8)ssub((u8)a.byte[i], (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssub_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssub_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssub.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating subtract the signed 64-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)ssub((s64)a.dword[i], (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssub_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssub.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the signed 64-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)ssub((s64)a.dword[i], (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssub_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssub_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssub.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating subtract the unsigned 64-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)ssub((u64)a.dword[i], (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssub_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssub.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the unsigned 64-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)ssub((u64)a.dword[i], (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssub_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssub_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssub.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating subtract the signed 16-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)ssub((s16)a.half[i], (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssub_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssub.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the signed 16-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)ssub((s16)a.half[i], (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssub_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssub_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssub.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating subtract the unsigned 16-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)ssub((u16)a.half[i], (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssub_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssub.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the unsigned 16-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)ssub((u16)a.half[i], (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssub_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssub_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssub.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating subtract the signed 32-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)ssub((s32)a.word[i], (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssub_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssub.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the signed 32-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)ssub((s32)a.word[i], (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vssub_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vssub_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vssub.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSaturating subtract the unsigned 32-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)ssub((u32)a.word[i], (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vssub_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vssub.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the unsigned 32-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)ssub((u32)a.word[i], (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsub_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsub_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsub.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] - b.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsub_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsub.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] - b.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsub_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsub_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsub.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] - b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsub_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsub.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] - b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsub_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsub_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsub.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] - b.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsub_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsub.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] - b.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsub_q (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsub_q (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsub.q vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 128-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst.qword[0] = a.qword[0] - b.qword[0];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsub_q (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsub.q vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 128-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst.qword[0] = a.qword[0] - b.qword[0];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsub_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsub_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsub.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] - b.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsub_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsub.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] - b.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubi_bu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubi_bu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsubi.bu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 8-bit elements in `a` by `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] - imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubi_bu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubi.bu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 8-bit elements in <code>a</code> by <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] - imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubi_du (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubi_du (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsubi.du vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 64-bit elements in `a` by `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] - imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubi_du (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubi.du vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 64-bit elements in <code>a</code> by <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] - imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubi_hu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubi_hu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsubi.hu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 16-bit elements in `a` by `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[i] - imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubi_hu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubi.hu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 16-bit elements in <code>a</code> by <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[i] - imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubi_wu (__m128i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubi_wu (__m128i a, imm0_31 imm)\n#include <lsxintrin.h>\nInstruction: vsubi.wu vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract 32-bit elements in `a` by `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[i] - imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubi_wu (__m128i a, imm0_31 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubi.wu vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 32-bit elements in <code>a</code> by <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[i] - imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwev_d_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwev_d_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwev.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract even-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] - (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) - ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) - ((s64)((s32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwev_d_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwev.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] - (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) - ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) - ((s64)((s32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwev_d_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwev_d_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwev.d.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract even-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] - (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) - ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) - ((u64)((u32)b.word[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwev_d_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwev.d.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] - (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) - ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) - ((u64)((u32)b.word[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwev_h_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwev_h_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwev.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract even-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] - (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) - ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) - ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) - ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) - ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) - ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) - ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) - ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) - ((s16)((s8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwev_h_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwev.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] - (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) - ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) - ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) - ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) - ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) - ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) - ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) - ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) - ((s16)((s8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwev_h_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwev_h_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwev.h.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract even-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] - (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) - ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) - ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) - ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) - ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) - ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) - ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) - ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) - ((u16)((u8)b.byte[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwev_h_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwev.h.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] - (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) - ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) - ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) - ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) - ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) - ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) - ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) - ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) - ((u16)((u8)b.byte[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwev_q_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwev_q_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwev.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract even-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] - (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) - ((s128)((s64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwev_q_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwev.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] - (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) - ((s128)((s64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwev_q_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwev_q_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwev.q.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract even-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] - (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) - ((u128)((u64)b.dword[0]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwev_q_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwev.q.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] - (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) - ((u128)((u64)b.dword[0]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwev_w_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwev_w_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwev.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract even-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] - (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) - ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) - ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) - ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) - ((s32)((s16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwev_w_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwev.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] - (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) - ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) - ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) - ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) - ((s32)((s16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwev_w_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwev_w_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwev.w.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract even-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] - (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) - ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) - ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) - ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) - ((u32)((u16)b.half[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwev_w_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwev.w.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] - (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) - ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) - ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) - ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) - ((u32)((u16)b.half[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwod_d_w (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwod_d_w (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwod.d.w vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] - (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) - ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) - ((s64)((s32)b.word[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwod_d_w (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwod.d.w vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] - (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) - ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) - ((s64)((s32)b.word[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwod_d_wu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwod_d_wu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwod.d.wu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] - (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) - ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) - ((u64)((u32)b.word[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwod_d_wu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwod.d.wu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] - (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) - ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) - ((u64)((u32)b.word[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwod_h_b (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwod_h_b (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwod.h.b vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] - (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) - ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) - ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) - ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) - ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) - ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) - ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) - ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) - ((s16)((s8)b.byte[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwod_h_b (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwod.h.b vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] - (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) - ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) - ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) - ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) - ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) - ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) - ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) - ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) - ((s16)((s8)b.byte[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwod_h_bu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwod_h_bu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwod.h.bu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] - (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) - ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) - ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) - ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) - ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) - ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) - ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) - ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) - ((u16)((u8)b.byte[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwod_h_bu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwod.h.bu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] - (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) - ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) - ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) - ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) - ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) - ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) - ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) - ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) - ((u16)((u8)b.byte[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwod_q_d (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwod_q_d (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwod.q.d vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] - (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) - ((s128)((s64)b.dword[1]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwod_q_d (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwod.q.d vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] - (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) - ((s128)((s64)b.dword[1]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwod_q_du (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwod_q_du (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwod.q.du vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] - (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) - ((u128)((u64)b.dword[1]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwod_q_du (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwod.q.du vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] - (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) - ((u128)((u64)b.dword[1]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwod_w_h (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwod_w_h (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwod.w.h vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] - (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) - ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) - ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) - ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) - ((s32)((s16)b.half[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwod_w_h (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwod.w.h vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] - (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) - ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) - ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) - ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) - ((s32)((s16)b.half[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vsubwod_w_hu (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vsubwod_w_hu (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vsubwod.w.hu vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] - (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) - ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) - ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) - ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) - ((u32)((u16)b.half[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |\n| 2K1000LA | LA264 | 2 | 1 |\n| 2K3000 | LA364E | 2 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vsubwod_w_hu (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsubwod.w.hu vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] - (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) - ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) - ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) - ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) - ((u32)((u16)b.half[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vxor_v (__m128i a, __m128i b)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vxor_v (__m128i a, __m128i b)\n#include <lsxintrin.h>\nInstruction: vxor.v vr, vr, vr\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise XOR between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[i] ^ b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vxor_v (__m128i a, __m128i b)\n#include &lt;lsxintrin.h&gt;\nInstruction: vxor.v vr, vr, vr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise XOR between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[i] ^ b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m128i __lsx_vxori_b (__m128i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m128i __lsx_vxori_b (__m128i a, imm0_255 imm)\n#include <lsxintrin.h>\nInstruction: vxori.b vr, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nCompute bitwise XOR between elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[i] ^ imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |\n| 2K1000LA | LA264 | 1 | 1 |\n| 2K3000 | LA364E | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m128i __lsx_vxori_b (__m128i a, imm0_255 imm)\n#include &lt;lsxintrin.h&gt;\nInstruction: vxori.b vr, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise XOR between elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[i] ^ imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LSX", "display": true}, {"name": "__m256 __lasx_xvfadd_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfadd_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfadd.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd single precision floating point elements in `a` to elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = a.fp32[i] + b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfadd_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfadd.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add single precision floating point elements in <code>a</code> to elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp32[i] + b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfcvt_s_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfcvt_s_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcvt.s.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double precision floating point elements in `a` and `b` to single precision.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.fp32[i] = b.fp64[i];\n}\nfor (; i < 4; i++) {\n  dst.fp32[i] = a.fp64[i - 2];\n}\nfor (; i < 6; i++) {\n  dst.fp32[i] = b.fp64[i - 2];\n}\nfor (; i < 8; i++) {\n  dst.fp32[i] = a.fp64[i - 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = b.fp64[0];\n  dst.fp32[1] = b.fp64[1];\n  dst.fp32[2] = a.fp64[0];\n  dst.fp32[3] = a.fp64[1];\n  dst.fp32[4] = b.fp64[2];\n  dst.fp32[5] = b.fp64[3];\n  dst.fp32[6] = a.fp64[2];\n  dst.fp32[7] = a.fp64[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfcvt_s_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcvt.s.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double precision floating point elements in <code>a</code> and <code>b</code> to single precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.fp32[i] = b.fp64[i];\n}\nfor (; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp64[i - 2];\n}\nfor (; i &lt; 6; i++) {\n  dst.fp32[i] = b.fp64[i - 2];\n}\nfor (; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp64[i - 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = b.fp64[0];\n  dst.fp32[1] = b.fp64[1];\n  dst.fp32[2] = a.fp64[0];\n  dst.fp32[3] = a.fp64[1];\n  dst.fp32[4] = b.fp64[2];\n  dst.fp32[5] = b.fp64[3];\n  dst.fp32[6] = a.fp64[2];\n  dst.fp32[7] = a.fp64[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfcvth_s_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfcvth_s_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvfcvth.s.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert half precision floating point elements in higher half of `a` to single precision.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp16[i + 4];\n}\nfor (; i < 8; i++) {\n  dst.fp32[i] = a.fp16[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = a.fp16[4];\n  dst.fp32[1] = a.fp16[5];\n  dst.fp32[2] = a.fp16[6];\n  dst.fp32[3] = a.fp16[7];\n  dst.fp32[4] = a.fp16[12];\n  dst.fp32[5] = a.fp16[13];\n  dst.fp32[6] = a.fp16[14];\n  dst.fp32[7] = a.fp16[15];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfcvth_s_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcvth.s.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert half precision floating point elements in higher half of <code>a</code> to single precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp16[i + 4];\n}\nfor (; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp16[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = a.fp16[4];\n  dst.fp32[1] = a.fp16[5];\n  dst.fp32[2] = a.fp16[6];\n  dst.fp32[3] = a.fp16[7];\n  dst.fp32[4] = a.fp16[12];\n  dst.fp32[5] = a.fp16[13];\n  dst.fp32[6] = a.fp16[14];\n  dst.fp32[7] = a.fp16[15];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfcvtl_s_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfcvtl_s_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvfcvtl.s.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert half precision floating point elements in lower half of `a` to single precision.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.fp32[i] = a.fp16[i];\n}\nfor (; i < 8; i++) {\n  dst.fp32[i] = a.fp16[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = a.fp16[0];\n  dst.fp32[1] = a.fp16[1];\n  dst.fp32[2] = a.fp16[2];\n  dst.fp32[3] = a.fp16[3];\n  dst.fp32[4] = a.fp16[8];\n  dst.fp32[5] = a.fp16[9];\n  dst.fp32[6] = a.fp16[10];\n  dst.fp32[7] = a.fp16[11];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfcvtl_s_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcvtl.s.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert half precision floating point elements in lower half of <code>a</code> to single precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.fp32[i] = a.fp16[i];\n}\nfor (; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp16[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = a.fp16[0];\n  dst.fp32[1] = a.fp16[1];\n  dst.fp32[2] = a.fp16[2];\n  dst.fp32[3] = a.fp16[3];\n  dst.fp32[4] = a.fp16[8];\n  dst.fp32[5] = a.fp16[9];\n  dst.fp32[6] = a.fp16[10];\n  dst.fp32[7] = a.fp16[11];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfdiv_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfdiv_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfdiv.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide single precision floating point elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = a.fp32[i] / b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 19.5 | 0.1(1/10.5) |\n| 3A6000 | LA664 | 11 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11 | 0.22(1/4.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfdiv_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfdiv.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide single precision floating point elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp32[i] / b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 19.5</td>\n<td>0.1(1/10.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.22(1/4.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvffint_s_l (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvffint_s_l (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvffint.s.l xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert 64-bit integer elements in `a` and `b` to single-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] =\n      (i < 4) ? (f32)(s32)a.dword[i]\n              : (f32)(s32)b.dword[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = (f32)((s32)a.dword[0]);\n  dst.fp32[1] = (f32)((s32)a.dword[1]);\n  dst.fp32[2] = (f32)((s32)a.dword[2]);\n  dst.fp32[3] = (f32)((s32)a.dword[3]);\n  dst.fp32[4] = (f32)((s32)b.dword[4]);\n  dst.fp32[5] = (f32)((s32)b.dword[5]);\n  dst.fp32[6] = (f32)((s32)b.dword[6]);\n  dst.fp32[7] = (f32)((s32)b.dword[7]);\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = (f32)((s32)a.dword[0]);\n  dst.fp32[1] = (f32)((s32)a.dword[1]);\n  dst.fp32[2] = (f32)((s32)a.dword[2]);\n  dst.fp32[3] = (f32)((s32)a.dword[3]);\n  dst.fp32[4] = (f32)((s32)b.dword[4]);\n  dst.fp32[5] = (f32)((s32)b.dword[5]);\n  dst.fp32[6] = (f32)((s32)b.dword[6]);\n  dst.fp32[7] = (f32)((s32)b.dword[7]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvffint_s_l (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvffint.s.l xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert 64-bit integer elements in <code>a</code> and <code>b</code> to single-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] =\n      (i &lt; 4) ? (f32)(s32)a.dword[i]\n              : (f32)(s32)b.dword[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = (f32)((s32)a.dword[0]);\n  dst.fp32[1] = (f32)((s32)a.dword[1]);\n  dst.fp32[2] = (f32)((s32)a.dword[2]);\n  dst.fp32[3] = (f32)((s32)a.dword[3]);\n  dst.fp32[4] = (f32)((s32)b.dword[4]);\n  dst.fp32[5] = (f32)((s32)b.dword[5]);\n  dst.fp32[6] = (f32)((s32)b.dword[6]);\n  dst.fp32[7] = (f32)((s32)b.dword[7]);\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = (f32)((s32)a.dword[0]);\n  dst.fp32[1] = (f32)((s32)a.dword[1]);\n  dst.fp32[2] = (f32)((s32)a.dword[2]);\n  dst.fp32[3] = (f32)((s32)a.dword[3]);\n  dst.fp32[4] = (f32)((s32)b.dword[4]);\n  dst.fp32[5] = (f32)((s32)b.dword[5]);\n  dst.fp32[6] = (f32)((s32)b.dword[6]);\n  dst.fp32[7] = (f32)((s32)b.dword[7]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvffint_s_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvffint_s_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvffint.s.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert signed 32-bit integer elements in `a` to single-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (f32)(s32)a.word[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = (f32)((s32)a.word[0]);\n  dst.fp32[1] = (f32)((s32)a.word[1]);\n  dst.fp32[2] = (f32)((s32)a.word[2]);\n  dst.fp32[3] = (f32)((s32)a.word[3]);\n  dst.fp32[4] = (f32)((s32)a.word[4]);\n  dst.fp32[5] = (f32)((s32)a.word[5]);\n  dst.fp32[6] = (f32)((s32)a.word[6]);\n  dst.fp32[7] = (f32)((s32)a.word[7]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvffint_s_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvffint.s.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert signed 32-bit integer elements in <code>a</code> to single-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (f32)(s32)a.word[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = (f32)((s32)a.word[0]);\n  dst.fp32[1] = (f32)((s32)a.word[1]);\n  dst.fp32[2] = (f32)((s32)a.word[2]);\n  dst.fp32[3] = (f32)((s32)a.word[3]);\n  dst.fp32[4] = (f32)((s32)a.word[4]);\n  dst.fp32[5] = (f32)((s32)a.word[5]);\n  dst.fp32[6] = (f32)((s32)a.word[6]);\n  dst.fp32[7] = (f32)((s32)a.word[7]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvffint_s_wu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvffint_s_wu (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvffint.s.wu xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert unsigned 32-bit integer elements in `a` to single-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (f32)(u32)a.word[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = (f32)((u32)a.word[0]);\n  dst.fp32[1] = (f32)((u32)a.word[1]);\n  dst.fp32[2] = (f32)((u32)a.word[2]);\n  dst.fp32[3] = (f32)((u32)a.word[3]);\n  dst.fp32[4] = (f32)((u32)a.word[4]);\n  dst.fp32[5] = (f32)((u32)a.word[5]);\n  dst.fp32[6] = (f32)((u32)a.word[6]);\n  dst.fp32[7] = (f32)((u32)a.word[7]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvffint_s_wu (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvffint.s.wu xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert unsigned 32-bit integer elements in <code>a</code> to single-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (f32)(u32)a.word[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp32[0] = (f32)((u32)a.word[0]);\n  dst.fp32[1] = (f32)((u32)a.word[1]);\n  dst.fp32[2] = (f32)((u32)a.word[2]);\n  dst.fp32[3] = (f32)((u32)a.word[3]);\n  dst.fp32[4] = (f32)((u32)a.word[4]);\n  dst.fp32[5] = (f32)((u32)a.word[5]);\n  dst.fp32[6] = (f32)((u32)a.word[6]);\n  dst.fp32[7] = (f32)((u32)a.word[7]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvflogb_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvflogb_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvflogb.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute 2-based logarithm of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = log2(a.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvflogb_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvflogb.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute 2-based logarithm of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = log2(a.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfmadd_s (__m256 a, __m256 b, __m256 c)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfmadd_s (__m256 a, __m256 b, __m256 c)\n#include <lasxintrin.h>\nInstruction: xvfmadd.s xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, accumulate to elements in `c` and store the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i] + c.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfmadd_s (__m256 a, __m256 b, __m256 c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmadd.s xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, accumulate to elements in <code>c</code> and store the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i] + c.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfmax_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfmax_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfmax.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute maximum of single precision floating point elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = fmax(a.fp32[i], b.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfmax_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmax.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute maximum of single precision floating point elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = fmax(a.fp32[i], b.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfmaxa_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfmaxa_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfmaxa.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute maximum of single precision floating point elements in `a` and `b` by magnitude.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (abs(a.fp32[i]) > abs(b.fp32[i])) ? a.fp32[i] : b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfmaxa_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmaxa.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute maximum of single precision floating point elements in <code>a</code> and <code>b</code> by magnitude.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (abs(a.fp32[i]) &gt; abs(b.fp32[i])) ? a.fp32[i] : b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfmin_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfmin_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfmin.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute minimum of single precision floating point elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = fmin(a.fp32[i], b.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfmin_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmin.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute minimum of single precision floating point elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = fmin(a.fp32[i], b.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfmina_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfmina_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfmina.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute minimum of single precision floating point elements in `a` and `b` by magnitude.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (abs(a.fp32[i]) < abs(b.fp32[i])) ? a.fp32[i] : b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfmina_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmina.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute minimum of single precision floating point elements in <code>a</code> and <code>b</code> by magnitude.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (abs(a.fp32[i]) &lt; abs(b.fp32[i])) ? a.fp32[i] : b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfmsub_s (__m256 a, __m256 b, __m256 c)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfmsub_s (__m256 a, __m256 b, __m256 c)\n#include <lasxintrin.h>\nInstruction: xvfmsub.s xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, subtract elements in `c` and store the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i] - c.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfmsub_s (__m256 a, __m256 b, __m256 c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmsub.s xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, subtract elements in <code>c</code> and store the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i] - c.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfmul_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfmul_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfmul.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply single precision floating point elements in `a` and elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfmul_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmul.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply single precision floating point elements in <code>a</code> and elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp32[i] * b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfnmadd_s (__m256 a, __m256 b, __m256 c)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfnmadd_s (__m256 a, __m256 b, __m256 c)\n#include <lasxintrin.h>\nInstruction: xvfnmadd.s xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, accumulate to elements in `c` and store the negated result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = -(a.fp32[i] * b.fp32[i] + c.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfnmadd_s (__m256 a, __m256 b, __m256 c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfnmadd.s xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, accumulate to elements in <code>c</code> and store the negated result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = -(a.fp32[i] * b.fp32[i] + c.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfnmsub_s (__m256 a, __m256 b, __m256 c)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfnmsub_s (__m256 a, __m256 b, __m256 c)\n#include <lasxintrin.h>\nInstruction: xvfnmsub.s xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, subtract elements in `c` and store the negated result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = -(a.fp32[i] * b.fp32[i] - c.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfnmsub_s (__m256 a, __m256 b, __m256 c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfnmsub.s xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed single precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, subtract elements in <code>c</code> and store the negated result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = -(a.fp32[i] * b.fp32[i] - c.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrecip_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrecip_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrecip.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute reciprocal of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = 1 / a.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 27 | 0.14(1/7) |\n| 3A6000 | LA664 | 27 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 27 | 0.12(1/8.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrecip_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrecip.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute reciprocal of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = 1 / a.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>27</td>\n<td>0.14(1/7)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>27</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>27</td>\n<td>0.12(1/8.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrecipe_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrecipe_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrecipe.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute estimated reciprocal of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = 1 / a.fp32[i]; // estimated\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrecipe_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrecipe.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute estimated reciprocal of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = 1 / a.fp32[i]; // estimated\n}\n</code></pre>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrint_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrint_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrint.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, using current rounding mode specified in `fscr`, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrint_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrint.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, using current rounding mode specified in <code>fscr</code>, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrintrm_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrintrm_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrintrm.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards negative infinity, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrintrm_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrintrm.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards negative infinity, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrintrne_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrintrne_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrintrne.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards nearest even, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrintrne_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrintrne.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards nearest even, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrintrp_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrintrp_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrintrp.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards positive infinity, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrintrp_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrintrp.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards positive infinity, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrintrz_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrintrz_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrintrz.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards zero, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrintrz_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrintrz.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards zero, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = (fp32)(s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrsqrt_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrsqrt_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrsqrt.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute reciprocal of square root of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = 1.0 / sqrt(a.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 25 | 0.03(1/32) |\n| 3A6000 | LA664 | 25 | 0.05(1/19) |\n| 3C6000 | LA664 | 21 | 0.11(1/9.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrsqrt_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrsqrt.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute reciprocal of square root of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = 1.0 / sqrt(a.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>25</td>\n<td>0.03(1/32)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>25</td>\n<td>0.05(1/19)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>21</td>\n<td>0.11(1/9.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfrsqrte_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfrsqrte_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfrsqrte.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute estimated reciprocal of square root of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = 1.0 / sqrt(a.fp32[i]); // estimated\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfrsqrte_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrsqrte.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute estimated reciprocal of square root of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = 1.0 / sqrt(a.fp32[i]); // estimated\n}\n</code></pre>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfscaleb_s (__m256 a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfscaleb_s (__m256 a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvfscaleb.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute IEEE754 scaleB of single precision floating point elements in `a` by integer elements in `b`. Currently undocumented.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = __builtin_scalbn(a.fp32[i], b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfscaleb_s (__m256 a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfscaleb.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute IEEE754 scaleB of single precision floating point elements in <code>a</code> by integer elements in <code>b</code>. Currently undocumented.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = __builtin_scalbn(a.fp32[i], b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Undocumented Intrinsics", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfsqrt_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfsqrt_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfsqrt.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute square root of single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = sqrt(a.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 15 | 0.07(1/13.5) |\n| 3A6000 | LA664 | 15 | 0.08(1/12) |\n| 3C6000 | LA664 | 25 | 0.09(1/11.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfsqrt_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfsqrt.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute square root of single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = sqrt(a.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>15</td>\n<td>0.07(1/13.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>15</td>\n<td>0.08(1/12)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>25</td>\n<td>0.09(1/11.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvfsub_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvfsub_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfsub.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract single precision floating point elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.fp32[i] = a.fp32[i] - b.fp32[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvfsub_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfsub.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract single precision floating point elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.fp32[i] = a.fp32[i] - b.fp32[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256 __lasx_xvpickve_w_f (__m256 a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256 __lasx_xvpickve_w_f (__m256 a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvpickve.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCopy one 32-bit lane from `a` specified by `imm` to the first lane of `dst`, and set the other lanes to zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (i == 0) ? a.word[imm] : 0;\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = a.word[imm];\n  dst.word[1] = 0;\n  dst.word[2] = 0;\n  dst.word[3] = 0;\n  dst.word[4] = 0;\n  dst.word[5] = 0;\n  dst.word[6] = 0;\n  dst.word[7] = 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256 __lasx_xvpickve_w_f (__m256 a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickve.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Copy one 32-bit lane from <code>a</code> specified by <code>imm</code> to the first lane of <code>dst</code>, and set the other lanes to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (i == 0) ? a.word[imm] : 0;\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = a.word[imm];\n  dst.word[1] = 0;\n  dst.word[2] = 0;\n  dst.word[3] = 0;\n  dst.word[4] = 0;\n  dst.word[5] = 0;\n  dst.word[6] = 0;\n  dst.word[7] = 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfadd_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfadd_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfadd.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd double precision floating point elements in `a` to elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = a.fp64[i] + b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfadd_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfadd.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add double precision floating point elements in <code>a</code> to elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = a.fp64[i] + b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfcvth_d_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfcvth_d_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfcvth.d.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single precision floating point elements in higher half of `a` to double precision.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp32[i + 2];\n}\nfor (; i < 4; i++) {\n  dst.fp64[i] = a.fp32[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = a.fp32[2];\n  dst.fp64[1] = a.fp32[3];\n  dst.fp64[2] = a.fp32[6];\n  dst.fp64[3] = a.fp32[7];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfcvth_d_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcvth.d.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single precision floating point elements in higher half of <code>a</code> to double precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp32[i + 2];\n}\nfor (; i &lt; 4; i++) {\n  dst.fp64[i] = a.fp32[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = a.fp32[2];\n  dst.fp64[1] = a.fp32[3];\n  dst.fp64[2] = a.fp32[6];\n  dst.fp64[3] = a.fp32[7];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfcvtl_d_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfcvtl_d_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfcvtl.d.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single precision floating point elements in lower half of `a` to double precision.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.fp64[i] = a.fp32[i];\n}\nfor (; i < 4; i++) {\n  dst.fp64[i] = a.fp32[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = a.fp32[0];\n  dst.fp64[1] = a.fp32[1];\n  dst.fp64[2] = a.fp32[4];\n  dst.fp64[3] = a.fp32[5];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfcvtl_d_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcvtl.d.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single precision floating point elements in lower half of <code>a</code> to double precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = a.fp32[i];\n}\nfor (; i &lt; 4; i++) {\n  dst.fp64[i] = a.fp32[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = a.fp32[0];\n  dst.fp64[1] = a.fp32[1];\n  dst.fp64[2] = a.fp32[4];\n  dst.fp64[3] = a.fp32[5];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfdiv_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfdiv_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfdiv.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide double precision floating point elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = a.fp64[i] / b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 17 | 0.08(1/12.5) |\n| 3A6000 | LA664 | 8, 21.5 | 0.25(1/4) |\n| 3C6000 | LA664 | 8, 16.5 | 0.33(1/3) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfdiv_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfdiv.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide double precision floating point elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = a.fp64[i] / b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 17</td>\n<td>0.08(1/12.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8, 21.5</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8, 16.5</td>\n<td>0.33(1/3)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvffint_d_l (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvffint_d_l (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvffint.d.l xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert signed 64-bit integer elements in `a` to double-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (f64)(s64)a.dword[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s64)a.dword[0]);\n  dst.fp64[1] = (f64)((s64)a.dword[1]);\n  dst.fp64[2] = (f64)((s64)a.dword[2]);\n  dst.fp64[3] = (f64)((s64)a.dword[3]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvffint_d_l (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvffint.d.l xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert signed 64-bit integer elements in <code>a</code> to double-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (f64)(s64)a.dword[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s64)a.dword[0]);\n  dst.fp64[1] = (f64)((s64)a.dword[1]);\n  dst.fp64[2] = (f64)((s64)a.dword[2]);\n  dst.fp64[3] = (f64)((s64)a.dword[3]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvffint_d_lu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvffint_d_lu (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvffint.d.lu xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert unsigned 64-bit integer elements in `a` to double-precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (f64)(u64)a.dword[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((u64)a.dword[0]);\n  dst.fp64[1] = (f64)((u64)a.dword[1]);\n  dst.fp64[2] = (f64)((u64)a.dword[2]);\n  dst.fp64[3] = (f64)((u64)a.dword[3]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvffint_d_lu (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvffint.d.lu xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert unsigned 64-bit integer elements in <code>a</code> to double-precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (f64)(u64)a.dword[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((u64)a.dword[0]);\n  dst.fp64[1] = (f64)((u64)a.dword[1]);\n  dst.fp64[2] = (f64)((u64)a.dword[2]);\n  dst.fp64[3] = (f64)((u64)a.dword[3]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvffinth_d_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvffinth_d_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvffinth.d.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert 32-bit integer elements in higher part of `a` to double precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s32)a.word[2]);\n  dst.fp64[1] = (f64)((s32)a.word[3]);\n  dst.fp64[2] = (f64)((s32)a.word[6]);\n  dst.fp64[3] = (f64)((s32)a.word[7]);\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s32)a.word[2]);\n  dst.fp64[1] = (f64)((s32)a.word[3]);\n  dst.fp64[2] = (f64)((s32)a.word[6]);\n  dst.fp64[3] = (f64)((s32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvffinth_d_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvffinth.d.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert 32-bit integer elements in higher part of <code>a</code> to double precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s32)a.word[2]);\n  dst.fp64[1] = (f64)((s32)a.word[3]);\n  dst.fp64[2] = (f64)((s32)a.word[6]);\n  dst.fp64[3] = (f64)((s32)a.word[7]);\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s32)a.word[2]);\n  dst.fp64[1] = (f64)((s32)a.word[3]);\n  dst.fp64[2] = (f64)((s32)a.word[6]);\n  dst.fp64[3] = (f64)((s32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvffintl_d_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvffintl_d_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvffintl.d.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert 32-bit integer elements in lower part of `a` to double precision floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s32)a.word[0]);\n  dst.fp64[1] = (f64)((s32)a.word[1]);\n  dst.fp64[2] = (f64)((s32)a.word[4]);\n  dst.fp64[3] = (f64)((s32)a.word[5]);\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s32)a.word[0]);\n  dst.fp64[1] = (f64)((s32)a.word[1]);\n  dst.fp64[2] = (f64)((s32)a.word[4]);\n  dst.fp64[3] = (f64)((s32)a.word[5]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvffintl_d_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvffintl.d.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert 32-bit integer elements in lower part of <code>a</code> to double precision floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.fp64[i] = (f64)(s32)a.word[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s32)a.word[0]);\n  dst.fp64[1] = (f64)((s32)a.word[1]);\n  dst.fp64[2] = (f64)((s32)a.word[4]);\n  dst.fp64[3] = (f64)((s32)a.word[5]);\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp64[0] = (f64)((s32)a.word[0]);\n  dst.fp64[1] = (f64)((s32)a.word[1]);\n  dst.fp64[2] = (f64)((s32)a.word[4]);\n  dst.fp64[3] = (f64)((s32)a.word[5]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvflogb_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvflogb_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvflogb.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute 2-based logarithm of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = log2(a.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvflogb_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvflogb.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute 2-based logarithm of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = log2(a.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfmadd_d (__m256d a, __m256d b, __m256d c)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfmadd_d (__m256d a, __m256d b, __m256d c)\n#include <lasxintrin.h>\nInstruction: xvfmadd.d xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, accumulate to elements in `c` and store the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i] + c.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfmadd_d (__m256d a, __m256d b, __m256d c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmadd.d xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, accumulate to elements in <code>c</code> and store the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i] + c.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfmax_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfmax_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfmax.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute maximum of double precision floating point elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = fmax(a.fp64[i], b.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfmax_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmax.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute maximum of double precision floating point elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = fmax(a.fp64[i], b.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfmaxa_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfmaxa_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfmaxa.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute maximum of double precision floating point elements in `a` and `b` by magnitude.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (abs(a.fp64[i]) > abs(b.fp64[i])) ? a.fp64[i] : b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfmaxa_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmaxa.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute maximum of double precision floating point elements in <code>a</code> and <code>b</code> by magnitude.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (abs(a.fp64[i]) &gt; abs(b.fp64[i])) ? a.fp64[i] : b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfmin_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfmin_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfmin.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute minimum of double precision floating point elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = fmin(a.fp64[i], b.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfmin_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmin.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute minimum of double precision floating point elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = fmin(a.fp64[i], b.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfmina_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfmina_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfmina.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute minimum of double precision floating point elements in `a` and `b` by magnitude.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (abs(a.fp64[i]) < abs(b.fp64[i])) ? a.fp64[i] : b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfmina_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmina.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute minimum of double precision floating point elements in <code>a</code> and <code>b</code> by magnitude.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (abs(a.fp64[i]) &lt; abs(b.fp64[i])) ? a.fp64[i] : b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfmsub_d (__m256d a, __m256d b, __m256d c)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfmsub_d (__m256d a, __m256d b, __m256d c)\n#include <lasxintrin.h>\nInstruction: xvfmsub.d xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, subtract elements in `c` and store the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i] - c.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfmsub_d (__m256d a, __m256d b, __m256d c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmsub.d xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, subtract elements in <code>c</code> and store the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i] - c.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfmul_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfmul_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfmul.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply double precision floating point elements in `a` and elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfmul_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfmul.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply double precision floating point elements in <code>a</code> and elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = a.fp64[i] * b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfnmadd_d (__m256d a, __m256d b, __m256d c)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfnmadd_d (__m256d a, __m256d b, __m256d c)\n#include <lasxintrin.h>\nInstruction: xvfnmadd.d xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, accumulate to elements in `c` and store the negated result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (a.fp64[i] * b.fp64[i] + c.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfnmadd_d (__m256d a, __m256d b, __m256d c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfnmadd.d xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, accumulate to elements in <code>c</code> and store the negated result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (a.fp64[i] * b.fp64[i] + c.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfnmsub_d (__m256d a, __m256d b, __m256d c)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfnmsub_d (__m256d a, __m256d b, __m256d c)\n#include <lasxintrin.h>\nInstruction: xvfnmsub.d xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in `a` and `b`, subtract elements in `c` and store the negated result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = -(a.fp64[i] * b.fp64[i] - c.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfnmsub_d (__m256d a, __m256d b, __m256d c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfnmsub.d xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute packed double precision floating point FMA(Fused Multiply-Add): multiply elements in <code>a</code> and <code>b</code>, subtract elements in <code>c</code> and store the negated result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = -(a.fp64[i] * b.fp64[i] - c.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Fused Multiply-Add", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrecip_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrecip_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrecip.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute reciprocal of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = 1 / a.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 23 | 0.08(1/12) |\n| 3A6000 | LA664 | 23 | 0.25(1/4) |\n| 3C6000 | LA664 | 23 | 0.1(1/10.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrecip_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrecip.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute reciprocal of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = 1 / a.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>23</td>\n<td>0.08(1/12)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>23</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>23</td>\n<td>0.1(1/10.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrecipe_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrecipe_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrecipe.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute estimated reciprocal of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = 1 / a.fp64[i]; // estimated\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrecipe_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrecipe.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute estimated reciprocal of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = 1 / a.fp64[i]; // estimated\n}\n</code></pre>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrint_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrint_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrint.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, using current rounding mode specified in `fscr`, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrint_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrint.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, using current rounding mode specified in <code>fscr</code>, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrintrm_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrintrm_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrintrm.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards negative infinity, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrintrm_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrintrm.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards negative infinity, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrintrne_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrintrne_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrintrne.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards nearest even, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrintrne_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrintrne.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards nearest even, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrintrp_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrintrp_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrintrp.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards positive infinity, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrintrp_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrintrp.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards positive infinity, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrintrz_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrintrz_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrintrz.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRound single-precision floating point elements in `a` to integers, rounding towards zero, and store as floating point numbers.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrintrz_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrintrz.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Round single-precision floating point elements in <code>a</code> to integers, rounding towards zero, and store as floating point numbers.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = (fp64)(s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrsqrt_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrsqrt_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrsqrt.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute reciprocal of square root of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = 1.0 / sqrt(a.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 15 | 0.04(1/27.5) |\n| 3A6000 | LA664 | 15 | 0.04(1/26.5) |\n| 3C6000 | LA664 | 15 | 0.04(1/26) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrsqrt_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrsqrt.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute reciprocal of square root of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = 1.0 / sqrt(a.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>15</td>\n<td>0.04(1/27.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>15</td>\n<td>0.04(1/26.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>15</td>\n<td>0.04(1/26)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfrsqrte_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfrsqrte_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfrsqrte.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute estimated reciprocal of square root of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = 1.0 / sqrt(a.fp64[i]); // estimated\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfrsqrte_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrsqrte.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute estimated reciprocal of square root of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = 1.0 / sqrt(a.fp64[i]); // estimated\n}\n</code></pre>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfscaleb_d (__m256d a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfscaleb_d (__m256d a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvfscaleb.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute IEEE754 scaleB of double precision floating point elements in `a` by integer elements in `b`. Currently undocumented.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = __builtin_scalbn(a.fp64[i], b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfscaleb_d (__m256d a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfscaleb.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute IEEE754 scaleB of double precision floating point elements in <code>a</code> by integer elements in <code>b</code>. Currently undocumented.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = __builtin_scalbn(a.fp64[i], b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Undocumented Intrinsics", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfsqrt_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfsqrt_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfsqrt.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute square root of double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = sqrt(a.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 36 | 0.05(1/18.5) |\n| 3A6000 | LA664 | 36 | 0.06(1/17.5) |\n| 3C6000 | LA664 | 36 | 0.06(1/17) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfsqrt_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfsqrt.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute square root of double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = sqrt(a.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>36</td>\n<td>0.05(1/18.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>36</td>\n<td>0.06(1/17.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>36</td>\n<td>0.06(1/17)</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvfsub_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvfsub_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfsub.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract double precision floating point elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.fp64[i] = a.fp64[i] - b.fp64[i];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvfsub_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfsub.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract double precision floating point elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.fp64[i] = a.fp64[i] - b.fp64[i];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Computation", "extension": "LASX", "display": true}, {"name": "__m256d __lasx_xvpickve_d_f (__m256d a, imm0_3 imm)", "markdown": "### Synopsis\n\n```c++\n__m256d __lasx_xvpickve_d_f (__m256d a, imm0_3 imm)\n#include <lasxintrin.h>\nInstruction: xvpickve.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCopy one 64-bit lane from `a` specified by `imm` to the first lane of `dst`, and set the other lanes to zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (i == 0) ? a.dword[imm] : 0;\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = a.dword[imm];\n  dst.dword[1] = 0;\n  dst.dword[2] = 0;\n  dst.dword[3] = 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256d __lasx_xvpickve_d_f (__m256d a, imm0_3 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickve.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Copy one 64-bit lane from <code>a</code> specified by <code>imm</code> to the first lane of <code>dst</code>, and set the other lanes to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (i == 0) ? a.dword[imm] : 0;\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = a.dword[imm];\n  dst.dword[1] = 0;\n  dst.dword[2] = 0;\n  dst.dword[3] = 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_d_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_d_b (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.d.b xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 8-bit lane of `a` to signed 64-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s8)a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_d_b (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.d.b xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 8-bit lane of <code>a</code> to signed 64-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s8)a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_d_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_d_h (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.d.h xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 16-bit lane of `a` to signed 64-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s16)a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_d_h (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.d.h xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 16-bit lane of <code>a</code> to signed 64-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s16)a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_d_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_d_w (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.d.w xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 32-bit lane of `a` to signed 64-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_d_w (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.d.w xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 32-bit lane of <code>a</code> to signed 64-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_du_bu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_du_bu (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.du.bu xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 8-bit lane of `a` to unsigned 64-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u8)a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_du_bu (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.du.bu xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 8-bit lane of <code>a</code> to unsigned 64-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u8)a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_du_hu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_du_hu (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.du.hu xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 16-bit lane of `a` to unsigned 64-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u16)a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_du_hu (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.du.hu xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 16-bit lane of <code>a</code> to unsigned 64-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u16)a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_du_wu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_du_wu (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.du.wu xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 32-bit lane of `a` to unsigned 64-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_du_wu (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.du.wu xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 32-bit lane of <code>a</code> to unsigned 64-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_h_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_h_b (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.h.b xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 8-bit lane of `a` to signed 16-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_h_b (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.h.b xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 8-bit lane of <code>a</code> to signed 16-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_hu_bu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_hu_bu (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.hu.bu xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 8-bit lane of `a` to unsigned 16-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_hu_bu (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.hu.bu xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 8-bit lane of <code>a</code> to unsigned 16-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_w_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_w_b (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.w.b xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 8-bit lane of `a` to signed 32-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s8)a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_w_b (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.w.b xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 8-bit lane of <code>a</code> to signed 32-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s8)a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_w_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_w_h (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.w.h xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend signed 16-bit lane of `a` to signed 32-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_w_h (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.w.h xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 16-bit lane of <code>a</code> to signed 32-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_wu_bu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_wu_bu (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.wu.bu xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 8-bit lane of `a` to unsigned 32-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u8)a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_wu_bu (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.wu.bu xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 8-bit lane of <code>a</code> to unsigned 32-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u8)a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_vext2xv_wu_hu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_vext2xv_wu_hu (__m256i a)\n#include <lsxintrin.h>\nInstruction: vext2xv.wu.hu xr, xr\nCPU Flags: LSX\n```\n\n### Description\n\nExtend unsigned 16-bit lane of `a` to unsigned 32-bit elements.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_vext2xv_wu_hu (__m256i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vext2xv.wu.hu xr, xr\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 16-bit lane of <code>a</code> to unsigned 32-bit elements.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvabsd_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvabsd_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvabsd.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute absolute difference of signed 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] > (s8)b.byte[i]) ? (a.byte[i] - b.byte[i])\n                                                : (b.byte[i] - a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvabsd_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvabsd.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of signed 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &gt; (s8)b.byte[i]) ? (a.byte[i] - b.byte[i])\n                                                : (b.byte[i] - a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvabsd_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvabsd_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvabsd.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute absolute difference of unsigned 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] > (u8)b.byte[i]) ? (a.byte[i] - b.byte[i])\n                                                : (b.byte[i] - a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvabsd_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvabsd.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of unsigned 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &gt; (u8)b.byte[i]) ? (a.byte[i] - b.byte[i])\n                                                : (b.byte[i] - a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvabsd_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvabsd_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvabsd.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute absolute difference of signed 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] > (s64)b.dword[i])\n                     ? (a.dword[i] - b.dword[i])\n                     : (b.dword[i] - a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvabsd_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvabsd.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of signed 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &gt; (s64)b.dword[i])\n                     ? (a.dword[i] - b.dword[i])\n                     : (b.dword[i] - a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvabsd_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvabsd_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvabsd.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute absolute difference of unsigned 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] > (u64)b.dword[i])\n                     ? (a.dword[i] - b.dword[i])\n                     : (b.dword[i] - a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvabsd_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvabsd.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of unsigned 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &gt; (u64)b.dword[i])\n                     ? (a.dword[i] - b.dword[i])\n                     : (b.dword[i] - a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvabsd_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvabsd_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvabsd.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute absolute difference of signed 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i] > (s16)b.half[i]) ? (a.half[i] - b.half[i])\n                                                  : (b.half[i] - a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvabsd_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvabsd.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of signed 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i] &gt; (s16)b.half[i]) ? (a.half[i] - b.half[i])\n                                                  : (b.half[i] - a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvabsd_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvabsd_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvabsd.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute absolute difference of unsigned 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((u16)a.half[i] > (u16)b.half[i]) ? (a.half[i] - b.half[i])\n                                                  : (b.half[i] - a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvabsd_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvabsd.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of unsigned 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((u16)a.half[i] &gt; (u16)b.half[i]) ? (a.half[i] - b.half[i])\n                                                  : (b.half[i] - a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvabsd_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvabsd_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvabsd.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute absolute difference of signed 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i] > (s32)b.word[i]) ? (a.word[i] - b.word[i])\n                                                  : (b.word[i] - a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvabsd_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvabsd.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of signed 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i] &gt; (s32)b.word[i]) ? (a.word[i] - b.word[i])\n                                                  : (b.word[i] - a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvabsd_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvabsd_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvabsd.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute absolute difference of unsigned 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((u32)a.word[i] > (u32)b.word[i]) ? (a.word[i] - b.word[i])\n                                                  : (b.word[i] - a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvabsd_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvabsd.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute absolute difference of unsigned 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((u32)a.word[i] &gt; (u32)b.word[i]) ? (a.word[i] - b.word[i])\n                                                  : (b.word[i] - a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadd_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadd_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadd.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] + b.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadd_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadd.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] + b.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadd_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadd_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadd.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] + b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadd_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadd.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] + b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadd_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadd_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadd.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] + b.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadd_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadd.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] + b.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadd_q (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadd_q (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadd.q xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 128-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = a.qword[i] + b.qword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadd_q (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadd.q xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 128-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = a.qword[i] + b.qword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadd_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadd_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadd.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] + b.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadd_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadd.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] + b.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadda_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadda_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadda.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd absolute of 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = abs((s8)a.byte[i]) + abs((s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadda_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadda.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add absolute of 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = abs((s8)a.byte[i]) + abs((s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadda_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadda_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadda.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd absolute of 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = abs((s64)a.dword[i]) + abs((s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadda_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadda.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add absolute of 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = abs((s64)a.dword[i]) + abs((s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadda_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadda_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadda.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd absolute of 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = abs((s16)a.half[i]) + abs((s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadda_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadda.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add absolute of 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = abs((s16)a.half[i]) + abs((s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvadda_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvadda_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvadda.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd absolute of 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = abs((s32)a.word[i]) + abs((s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvadda_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvadda.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add absolute of 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = abs((s32)a.word[i]) + abs((s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddi_bu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddi_bu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvaddi.bu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 8-bit elements in `a` and `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] + imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddi_bu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddi.bu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 8-bit elements in <code>a</code> and <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] + imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddi_du (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddi_du (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvaddi.du xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 64-bit elements in `a` and `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] + imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddi_du (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddi.du xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 64-bit elements in <code>a</code> and <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] + imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddi_hu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddi_hu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvaddi.hu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 16-bit elements in `a` and `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] + imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddi_hu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddi.hu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 16-bit elements in <code>a</code> and <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] + imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddi_wu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddi_wu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvaddi.wu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nAdd 32-bit elements in `a` and `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] + imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddi_wu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddi.wu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add 32-bit elements in <code>a</code> and <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] + imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_d_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_d_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) + ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[4])) + ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[6])) + ((s64)((s32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_d_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) + ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[4])) + ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[6])) + ((s64)((s32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_d_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_d_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.d.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] + (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) + ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) + ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) + ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) + ((u64)((u32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_d_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.d.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] + (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) + ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) + ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) + ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) + ((u64)((u32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_d_wu_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_d_wu_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.d.wu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned unsigned 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) + ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) + ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) + ((s64)((s32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_d_wu_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.d.wu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) + ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) + ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) + ((s64)((s32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_h_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_h_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) + ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[16])) + ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[18])) + ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[20])) + ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[22])) + ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[24])) + ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[26])) + ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[28])) + ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[30])) + ((s16)((s8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_h_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) + ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[16])) + ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[18])) + ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[20])) + ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[22])) + ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[24])) + ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[26])) + ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[28])) + ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[30])) + ((s16)((s8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_h_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_h_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.h.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] + (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) + ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) + ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) + ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) + ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) + ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) + ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) + ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) + ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) + ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) + ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) + ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) + ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) + ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) + ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) + ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) + ((u16)((u8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_h_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.h.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] + (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) + ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) + ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) + ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) + ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) + ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) + ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) + ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) + ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) + ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) + ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) + ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) + ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) + ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) + ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) + ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) + ((u16)((u8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_h_bu_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_h_bu_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.h.bu.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned unsigned 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) + ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) + ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) + ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) + ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) + ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) + ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) + ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) + ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) + ((s16)((s8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_h_bu_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.h.bu.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) + ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) + ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) + ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) + ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) + ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) + ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) + ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) + ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) + ((s16)((s8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_q_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_q_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) + ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[2])) + ((s128)((s64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_q_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) + ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[2])) + ((s128)((s64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_q_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_q_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.q.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] + (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) + ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) + ((u128)((u64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_q_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.q.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] + (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) + ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) + ((u128)((u64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_q_du_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_q_du_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.q.du.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned unsigned 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) + ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) + ((s128)((s64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_q_du_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.q.du.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) + ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) + ((s128)((s64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_w_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_w_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) + ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[8])) + ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[10])) + ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[12])) + ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[14])) + ((s32)((s16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_w_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) + ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[8])) + ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[10])) + ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[12])) + ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[14])) + ((s32)((s16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_w_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_w_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.w.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] + (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) + ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) + ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) + ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) + ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) + ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) + ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) + ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) + ((u32)((u16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_w_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.w.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] + (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) + ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) + ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) + ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) + ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) + ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) + ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) + ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) + ((u32)((u16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwev_w_hu_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwev_w_hu_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwev.w.hu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd even-positioned unsigned 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) + ((s32)((s16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) + ((s32)((s16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) + ((s32)((s16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) + ((s32)((s16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) + ((s32)((s16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwev_w_hu_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwev.w.hu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add even-positioned unsigned 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) + ((s32)((s16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) + ((s32)((s16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) + ((s32)((s16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) + ((s32)((s16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) + ((s32)((s16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_d_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_d_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) + ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) + ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) + ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) + ((s64)((s32)b.word[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_d_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) + ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) + ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) + ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) + ((s64)((s32)b.word[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_d_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_d_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.d.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((u64)((u32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) + ((u64)((u32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) + ((u64)((u32)b.word[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_d_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.d.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((u64)((u32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) + ((u64)((u32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) + ((u64)((u32)b.word[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_d_wu_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_d_wu_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.d.wu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) + ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) + ((s64)((s32)b.word[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_d_wu_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.d.wu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) + ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) + ((s64)((s32)b.word[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_h_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_h_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) + ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) + ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) + ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) + ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) + ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) + ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) + ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) + ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) + ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) + ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) + ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) + ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) + ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) + ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) + ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) + ((s16)((s8)b.byte[31]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_h_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) + ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) + ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) + ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) + ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) + ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) + ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) + ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) + ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) + ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) + ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) + ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) + ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) + ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) + ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) + ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) + ((s16)((s8)b.byte[31]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_h_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_h_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.h.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((u16)((u8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) + ((u16)((u8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) + ((u16)((u8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) + ((u16)((u8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) + ((u16)((u8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) + ((u16)((u8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) + ((u16)((u8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) + ((u16)((u8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) + ((u16)((u8)b.byte[31]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_h_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.h.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((u16)((u8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) + ((u16)((u8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) + ((u16)((u8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) + ((u16)((u8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) + ((u16)((u8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) + ((u16)((u8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) + ((u16)((u8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) + ((u16)((u8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) + ((u16)((u8)b.byte[31]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_h_bu_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_h_bu_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.h.bu.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) + ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) + ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) + ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) + ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) + ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) + ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) + ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) + ((s16)((s8)b.byte[31]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_h_bu_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.h.bu.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) + ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) + ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) + ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) + ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) + ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) + ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) + ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) + ((s16)((s8)b.byte[31]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_q_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_q_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) + ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) + ((s128)((s64)b.dword[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_q_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) + ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) + ((s128)((s64)b.dword[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_q_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_q_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.q.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((u128)((u64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) + ((u128)((u64)b.dword[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_q_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.q.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((u128)((u64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) + ((u128)((u64)b.dword[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_q_du_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_q_du_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.q.du.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) + ((s128)((s64)b.dword[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_q_du_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.q.du.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) + ((s128)((s64)b.dword[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_w_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_w_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) + ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) + ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) + ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) + ((s32)((s16)b.half[7]));\n  dst.word[4] = ((s32)((s16)a.half[9])) + ((s32)((s16)b.half[9]));\n  dst.word[5] = ((s32)((s16)a.half[11])) + ((s32)((s16)b.half[11]));\n  dst.word[6] = ((s32)((s16)a.half[13])) + ((s32)((s16)b.half[13]));\n  dst.word[7] = ((s32)((s16)a.half[15])) + ((s32)((s16)b.half[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_w_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) + ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) + ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) + ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) + ((s32)((s16)b.half[7]));\n  dst.word[4] = ((s32)((s16)a.half[9])) + ((s32)((s16)b.half[9]));\n  dst.word[5] = ((s32)((s16)a.half[11])) + ((s32)((s16)b.half[11]));\n  dst.word[6] = ((s32)((s16)a.half[13])) + ((s32)((s16)b.half[13]));\n  dst.word[7] = ((s32)((s16)a.half[15])) + ((s32)((s16)b.half[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_w_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_w_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.w.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((u32)((u16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) + ((u32)((u16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) + ((u32)((u16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) + ((u32)((u16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) + ((u32)((u16)b.half[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_w_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.w.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((u32)((u16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) + ((u32)((u16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) + ((u32)((u16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) + ((u32)((u16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) + ((u32)((u16)b.half[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvaddwod_w_hu_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvaddwod_w_hu_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvaddwod.w.hu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((s32)((s16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((s32)((s16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((s32)((s16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((s32)((s16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) + ((s32)((s16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) + ((s32)((s16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) + ((s32)((s16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) + ((s32)((s16)b.half[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvaddwod_w_hu_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvaddwod.w.hu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((s32)((s16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((s32)((s16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((s32)((s16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((s32)((s16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) + ((s32)((s16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) + ((s32)((s16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) + ((s32)((s16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) + ((s32)((s16)b.half[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvand_v (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvand_v (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvand.v xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise AND between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] & b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvand_v (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvand.v xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise AND between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] &amp; b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvandi_b (__m256i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvandi_b (__m256i a, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvandi.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise AND between elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] & imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvandi_b (__m256i a, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvandi.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise AND between elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] &amp; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvandn_v (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvandn_v (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvandn.v xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise ANDN between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = b.dword[i] & (~a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvandn_v (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvandn.v xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise ANDN between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = b.dword[i] &amp; (~a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavg_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavg_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavg.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of signed 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] >> 1) + ((s8)b.byte[i] >> 1) +\n                ((a.byte[i] & b.byte[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavg_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavg.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of signed 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &gt;&gt; 1) + ((s8)b.byte[i] &gt;&gt; 1) +\n                ((a.byte[i] &amp; b.byte[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavg_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavg_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavg.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of unsigned 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] >> 1) + ((u8)b.byte[i] >> 1) +\n                ((a.byte[i] & b.byte[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavg_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavg.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of unsigned 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &gt;&gt; 1) + ((u8)b.byte[i] &gt;&gt; 1) +\n                ((a.byte[i] &amp; b.byte[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavg_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavg_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavg.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of signed 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] >> 1) + ((s64)b.dword[i] >> 1) +\n                 ((a.dword[i] & b.dword[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavg_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavg.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of signed 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &gt;&gt; 1) + ((s64)b.dword[i] &gt;&gt; 1) +\n                 ((a.dword[i] &amp; b.dword[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavg_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavg_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavg.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of unsigned 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] >> 1) + ((u64)b.dword[i] >> 1) +\n                 ((a.dword[i] & b.dword[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavg_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavg.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of unsigned 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &gt;&gt; 1) + ((u64)b.dword[i] &gt;&gt; 1) +\n                 ((a.dword[i] &amp; b.dword[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavg_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavg_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavg.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of signed 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i] >> 1) + ((s16)b.half[i] >> 1) +\n                ((a.half[i] & b.half[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavg_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavg.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of signed 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i] &gt;&gt; 1) + ((s16)b.half[i] &gt;&gt; 1) +\n                ((a.half[i] &amp; b.half[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavg_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavg_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavg.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of unsigned 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((u16)a.half[i] >> 1) + ((u16)b.half[i] >> 1) +\n                ((a.half[i] & b.half[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavg_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavg.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of unsigned 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((u16)a.half[i] &gt;&gt; 1) + ((u16)b.half[i] &gt;&gt; 1) +\n                ((a.half[i] &amp; b.half[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavg_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavg_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavg.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of signed 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i] >> 1) + ((s32)b.word[i] >> 1) +\n                ((a.word[i] & b.word[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavg_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavg.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of signed 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i] &gt;&gt; 1) + ((s32)b.word[i] &gt;&gt; 1) +\n                ((a.word[i] &amp; b.word[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavg_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavg_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavg.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards negative infinity) of unsigned 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((u32)a.word[i] >> 1) + ((u32)b.word[i] >> 1) +\n                ((a.word[i] & b.word[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavg_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavg.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards negative infinity) of unsigned 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((u32)a.word[i] &gt;&gt; 1) + ((u32)b.word[i] &gt;&gt; 1) +\n                ((a.word[i] &amp; b.word[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavgr_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavgr_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavgr.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of signed 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] >> 1) + ((s8)b.byte[i] >> 1) +\n                ((a.byte[i] | b.byte[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavgr_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavgr.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of signed 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &gt;&gt; 1) + ((s8)b.byte[i] &gt;&gt; 1) +\n                ((a.byte[i] | b.byte[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavgr_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavgr_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavgr.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of unsigned 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] >> 1) + ((u8)b.byte[i] >> 1) +\n                ((a.byte[i] | b.byte[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavgr_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavgr.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of unsigned 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &gt;&gt; 1) + ((u8)b.byte[i] &gt;&gt; 1) +\n                ((a.byte[i] | b.byte[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavgr_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavgr_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavgr.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of signed 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] >> 1) + ((s64)b.dword[i] >> 1) +\n                 ((a.dword[i] | b.dword[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavgr_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavgr.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of signed 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &gt;&gt; 1) + ((s64)b.dword[i] &gt;&gt; 1) +\n                 ((a.dword[i] | b.dword[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavgr_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavgr_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavgr.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of unsigned 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] >> 1) + ((u64)b.dword[i] >> 1) +\n                 ((a.dword[i] | b.dword[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavgr_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavgr.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of unsigned 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &gt;&gt; 1) + ((u64)b.dword[i] &gt;&gt; 1) +\n                 ((a.dword[i] | b.dword[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavgr_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavgr_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavgr.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of signed 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i] >> 1) + ((s16)b.half[i] >> 1) +\n                ((a.half[i] | b.half[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavgr_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavgr.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of signed 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i] &gt;&gt; 1) + ((s16)b.half[i] &gt;&gt; 1) +\n                ((a.half[i] | b.half[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavgr_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavgr_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavgr.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of unsigned 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((u16)a.half[i] >> 1) + ((u16)b.half[i] >> 1) +\n                ((a.half[i] | b.half[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavgr_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavgr.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of unsigned 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((u16)a.half[i] &gt;&gt; 1) + ((u16)b.half[i] &gt;&gt; 1) +\n                ((a.half[i] | b.half[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavgr_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavgr_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavgr.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of signed 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i] >> 1) + ((s32)b.word[i] >> 1) +\n                ((a.word[i] | b.word[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavgr_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavgr.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of signed 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i] &gt;&gt; 1) + ((s32)b.word[i] &gt;&gt; 1) +\n                ((a.word[i] | b.word[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvavgr_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvavgr_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvavgr.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute the average (rounded towards positive infinity) of unsigned 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((u32)a.word[i] >> 1) + ((u32)b.word[i] >> 1) +\n                ((a.word[i] | b.word[i]) & 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvavgr_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvavgr.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute the average (rounded towards positive infinity) of unsigned 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((u32)a.word[i] &gt;&gt; 1) + ((u32)b.word[i] &gt;&gt; 1) +\n                ((a.word[i] | b.word[i]) &amp; 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitclr_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitclr_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitclr.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nClear the bit specified by elements in `b` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitclr_b(__m256i{0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xf7f7f7f7f7f7f7f7 0x99aabbccd5ecf700 0xabcdeb0212341234 0xaabaaaba9dee9dee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] & (~((u8)1 << (b.byte[i] % 8)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclr_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitclr.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by elements in <code>b</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclr_b(__m256i{0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xf7f7f7f7f7f7f7f7 0x99aabbccd5ecf700 0xabcdeb0212341234 0xaabaaaba9dee9dee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] &amp; (~((u8)1 &lt;&lt; (b.byte[i] % 8)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitclr_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitclr_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitclr.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nClear the bit specified by elements in `b` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitclr_d(__m256i{0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xfffff7ffffffffff 0x99aabbccddeeff00 0xabcdef1012341234 0xaabbaabbddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] & (~((u64)1 << (b.dword[i] % 64)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclr_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitclr.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by elements in <code>b</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclr_d(__m256i{0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xfffff7ffffffffff 0x99aabbccddeeff00 0xabcdef1012341234 0xaabbaabbddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] &amp; (~((u64)1 &lt;&lt; (b.dword[i] % 64)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitclr_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitclr_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitclr.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nClear the bit specified by elements in `b` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitclr_h(__m256i{0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xf7fff7fff7fff7ff 0x99aabbccddecff00 0xabcdef0212341234 0xaabbaabbdceedcee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] & (~((u16)1 << (b.half[i] % 16)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclr_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitclr.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by elements in <code>b</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclr_h(__m256i{0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xf7fff7fff7fff7ff 0x99aabbccddecff00 0xabcdef0212341234 0xaabbaabbdceedcee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] &amp; (~((u16)1 &lt;&lt; (b.half[i] % 16)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitclr_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitclr_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitclr.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nClear the bit specified by elements in `b` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitclr_w(__m256i{0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xfffff7fffffff7ff 0x99aabbccddeeff00 0xabcdef1212341234 0xaabbaabbdceeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] & (~((u32)1 << (b.word[i] % 32)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclr_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitclr.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by elements in <code>b</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclr_w(__m256i{0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xfffff7fffffff7ff 0x99aabbccddeeff00 0xabcdef1212341234 0xaabbaabbdceeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] &amp; (~((u32)1 &lt;&lt; (b.word[i] % 32)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitclri_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitclri_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvbitclri.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClear the bit specified by `imm` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitclri_b( __m256i{ 0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0xfdfdfdfdfdfdfdfd 0x99a8b9ccddecfd00 0xa9cded1010341034 0xa8b9a8b9ddecddec\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] & (~((u8)1 << imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclri_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitclri.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by <code>imm</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclri_b( __m256i{ 0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0xfdfdfdfdfdfdfdfd 0x99a8b9ccddecfd00 0xa9cded1010341034 0xa8b9a8b9ddecddec\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] &amp; (~((u8)1 &lt;&lt; imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitclri_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitclri_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvbitclri.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClear the bit specified by `imm` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitclri_d( __m256i{ 0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0xfffffffffffffffd 0x99aabbccddeeff00 0xabcdef1212341234 0xaabbaabbddeeddec\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] & (~((u64)1 << imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclri_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitclri.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by <code>imm</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclri_d( __m256i{ 0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0xfffffffffffffffd 0x99aabbccddeeff00 0xabcdef1212341234 0xaabbaabbddeeddec\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] &amp; (~((u64)1 &lt;&lt; imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitclri_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitclri_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvbitclri.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClear the bit specified by `imm` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitclri_h( __m256i{ 0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0xfffdfffdfffdfffd 0x99a8bbccddecff00 0xabcdef1012341234 0xaab9aab9ddecddec\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] & (~((u16)1 << imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclri_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitclri.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by <code>imm</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclri_h( __m256i{ 0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0xfffdfffdfffdfffd 0x99a8bbccddecff00 0xabcdef1012341234 0xaab9aab9ddecddec\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] &amp; (~((u16)1 &lt;&lt; imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitclri_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitclri_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvbitclri.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClear the bit specified by `imm` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitclri_w( __m256i{ 0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0xfffffffdfffffffd 0x99aabbccddeeff00 0xabcdef1012341234 0xaabbaab9ddeeddec\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] & (~((u32)1 << imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclri_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitclri.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clear the bit specified by <code>imm</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitclri_w( __m256i{ 0xffffffffffffffff, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0xfffffffdfffffffd 0x99aabbccddeeff00 0xabcdef1012341234 0xaabbaab9ddeeddec\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] &amp; (~((u32)1 &lt;&lt; imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitrev_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitrev_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitrev.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nToggle the bit specified by elements in `b` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitrev_b(__m256i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0707070707070707 0x9dbabfdcd5ecf702 0xafddeb021a361a36 0xeabaeaba9def9def\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] ^ ((u8)1 << (b.byte[i] % 8));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrev_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitrev.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by elements in <code>b</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrev_b(__m256i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0707070707070707 0x9dbabfdcd5ecf702 0xafddeb021a361a36 0xeabaeaba9def9def\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] ^ ((u8)1 &lt;&lt; (b.byte[i] % 8));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitrev_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitrev_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitrev.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nToggle the bit specified by elements in `b` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitrev_d(__m256i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0f0f070f0f0f0f0f 0x99aabbceddeeff00 0xabcdef1012341234 0xabbbaabbddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] ^ ((u64)1 << (b.dword[i] % 64));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrev_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitrev.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by elements in <code>b</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrev_d(__m256i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0f0f070f0f0f0f0f 0x99aabbceddeeff00 0xabcdef1012341234 0xabbbaabbddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] ^ ((u64)1 &lt;&lt; (b.dword[i] % 64));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitrev_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitrev_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitrev.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nToggle the bit specified by elements in `b` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitrev_h(__m256i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x070f070f070f070f 0x99babbdcddecff02 0xabddef0212361236 0xabbbabbbdceedcee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] ^ ((u16)1 << (b.half[i] % 16));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrev_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitrev.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by elements in <code>b</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrev_h(__m256i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x070f070f070f070f 0x99babbdcddecff02 0xabddef0212361236 0xabbbabbbdceedcee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] ^ ((u16)1 &lt;&lt; (b.half[i] % 16));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitrev_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitrev_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitrev.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nToggle the bit specified by elements in `b` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitrev_w(__m256i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0f0f070f0f0f070f 0x99babbccddeeff02 0xabddef1212341236 0xabbbaabbdceeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] ^ ((u32)1 << (b.word[i] % 32));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrev_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitrev.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by elements in <code>b</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrev_w(__m256i{0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0f0f070f0f0f070f 0x99babbccddeeff02 0xabddef1212341236 0xabbbaabbdceeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] ^ ((u32)1 &lt;&lt; (b.word[i] % 32));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitrevi_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitrevi_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvbitrevi.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nToggle the bit specified by `imm` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitrevi_b( __m256i{ 0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0d0d0d0d0d0d0d0d 0x9ba8b9cedfecfd02 0xa9cfed1010361036 0xa8b9a8b9dfecdfec\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] ^ ((u8)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrevi_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitrevi.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by <code>imm</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrevi_b( __m256i{ 0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0d0d0d0d0d0d0d0d 0x9ba8b9cedfecfd02 0xa9cfed1010361036 0xa8b9a8b9dfecdfec\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] ^ ((u8)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitrevi_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitrevi_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvbitrevi.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nToggle the bit specified by `imm` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitrevi_d( __m256i{ 0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0f0f0f0f0f0f0f0d 0x99aabbccddeeff02 0xabcdef1212341236 0xaabbaabbddeeddec\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] ^ ((u64)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrevi_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitrevi.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by <code>imm</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrevi_d( __m256i{ 0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0f0f0f0f0f0f0f0d 0x99aabbccddeeff02 0xabcdef1212341236 0xaabbaabbddeeddec\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] ^ ((u64)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitrevi_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitrevi_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvbitrevi.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nToggle the bit specified by `imm` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitrevi_h( __m256i{ 0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0f0d0f0d0f0d0f0d 0x99a8bbceddecff02 0xabcfef1012361236 0xaab9aab9ddecddec\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] ^ ((u16)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrevi_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitrevi.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by <code>imm</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrevi_h( __m256i{ 0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0f0d0f0d0f0d0f0d 0x99a8bbceddecff02 0xabcfef1012361236 0xaab9aab9ddecddec\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] ^ ((u16)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitrevi_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitrevi_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvbitrevi.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nToggle the bit specified by `imm` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitrevi_w( __m256i{ 0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0f0f0f0d0f0f0f0d 0x99aabbceddeeff02 0xabcdef1012341236 0xaabbaab9ddeeddec\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] ^ ((u32)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrevi_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitrevi.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Toggle the bit specified by <code>imm</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitrevi_w( __m256i{ 0x0f0f0f0f0f0f0f0f, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0f0f0f0d0f0f0f0d 0x99aabbceddeeff02 0xabcdef1012341236 0xaabbaab9ddeeddec\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] ^ ((u32)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitsel_v (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitsel_v (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvbitsel.v xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise selection: for each bit position, if the bit in `c` equals to one, copy the bit from `b` to `dst`, otherwise copy from `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitsel_v(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, __m256i{0xffff0000aaaabbbb, 0x1111222233334444, 0x00000000ffffffff, 0xffffffff00000000})\n= 0xabab3344ffeeefab 0x98ba9beccfedfb00 0xabcdef1243214321 0x56785678ddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (c.dword[i] & b.dword[i]) | (~c.dword[i] & a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitsel_v (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitsel.v xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise selection: for each bit position, if the bit in <code>c</code> equals to one, copy the bit from <code>b</code> to <code>dst</code>, otherwise copy from <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitsel_v(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, __m256i{0xffff0000aaaabbbb, 0x1111222233334444, 0x00000000ffffffff, 0xffffffff00000000})\n= 0xabab3344ffeeefab 0x98ba9beccfedfb00 0xabcdef1243214321 0x56785678ddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (c.dword[i] &amp; b.dword[i]) | (~c.dword[i] &amp; a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitseli_b (__m256i a, __m256i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitseli_b (__m256i a, __m256i b, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvbitseli.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise selection: for each bit position, if the bit in `a` equals to one, copy the bit from `imm` to `dst`, otherwise copy from `b`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitseli_b( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{ 0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0xba8b9aabba8b9a23 0x1216123012031221 0x1230123653115311 0x5652565212121212\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (~a.byte[i] & b.byte[i]) | (a.byte[i] & (u8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseli_b (__m256i a, __m256i b, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitseli.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise selection: for each bit position, if the bit in <code>a</code> equals to one, copy the bit from <code>imm</code> to <code>dst</code>, otherwise copy from <code>b</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseli_b( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{ 0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0xba8b9aabba8b9a23 0x1216123012031221 0x1230123653115311 0x5652565212121212\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (~a.byte[i] &amp; b.byte[i]) | (a.byte[i] &amp; (u8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitset_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitset_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitset.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSet the bit specified by elements in `b` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitset_b(__m256i{0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0808080808080808 0x9dbabfdcddeeff02 0xafddef121a361a36 0xeabbeabbddefddef\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] | ((u8)1 << (b.byte[i] % 8));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitset_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitset.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by elements in <code>b</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitset_b(__m256i{0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0808080808080808 0x9dbabfdcddeeff02 0xafddef121a361a36 0xeabbeabbddefddef\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] | ((u8)1 &lt;&lt; (b.byte[i] % 8));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitset_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitset_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitset.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSet the bit specified by elements in `b` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitset_d(__m256i{0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0000080000000000 0x99aabbceddeeff00 0xabcdef1212341234 0xabbbaabbddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] | ((u64)1 << (b.dword[i] % 64));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitset_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitset.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by elements in <code>b</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitset_d(__m256i{0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0000080000000000 0x99aabbceddeeff00 0xabcdef1212341234 0xabbbaabbddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] | ((u64)1 &lt;&lt; (b.dword[i] % 64));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitset_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitset_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitset.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSet the bit specified by elements in `b` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitset_h(__m256i{0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0800080008000800 0x99babbdcddeeff02 0xabddef1212361236 0xabbbabbbddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] | ((u16)1 << (b.half[i] % 16));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitset_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitset.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by elements in <code>b</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitset_h(__m256i{0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0800080008000800 0x99babbdcddeeff02 0xabddef1212361236 0xabbbabbbddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] | ((u16)1 &lt;&lt; (b.half[i] % 16));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitset_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitset_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvbitset.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSet the bit specified by elements in `b` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitset_w(__m256i{0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0000080000000800 0x99babbccddeeff02 0xabddef1212341236 0xabbbaabbddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] | ((u32)1 << (b.word[i] % 32));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitset_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitset.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by elements in <code>b</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitset_w(__m256i{0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabababababababab, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x0000080000000800 0x99babbccddeeff02 0xabddef1212341236 0xabbbaabbddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] | ((u32)1 &lt;&lt; (b.word[i] % 32));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitseti_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitseti_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvbitseti.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSet the bit specified by `imm` from 8-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitseti_b( __m256i{ 0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0202020202020202 0x9baabbcedfeeff02 0xabcfef1212361236 0xaabbaabbdfeedfee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] | ((u8)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseti_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitseti.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by <code>imm</code> from 8-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseti_b( __m256i{ 0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0202020202020202 0x9baabbcedfeeff02 0xabcfef1212361236 0xaabbaabbdfeedfee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] | ((u8)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitseti_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitseti_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvbitseti.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSet the bit specified by `imm` from 64-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitseti_d( __m256i{ 0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0000000000000002 0x99aabbccddeeff02 0xabcdef1212341236 0xaabbaabbddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] | ((u64)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseti_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitseti.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by <code>imm</code> from 64-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseti_d( __m256i{ 0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0000000000000002 0x99aabbccddeeff02 0xabcdef1212341236 0xaabbaabbddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] | ((u64)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitseti_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitseti_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvbitseti.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSet the bit specified by `imm` from 16-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitseti_h( __m256i{ 0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0002000200020002 0x99aabbceddeeff02 0xabcfef1212361236 0xaabbaabbddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] | ((u16)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseti_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitseti.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by <code>imm</code> from 16-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseti_h( __m256i{ 0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0002000200020002 0x99aabbceddeeff02 0xabcfef1212361236 0xaabbaabbddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] | ((u16)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbitseti_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbitseti_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvbitseti.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSet the bit specified by `imm` from 32-bit elements in `a`, save the result in `dst`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvbitseti_w( __m256i{ 0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0000000200000002 0x99aabbceddeeff02 0xabcdef1212341236 0xaabbaabbddeeddee\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] | ((u32)1 << imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseti_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbitseti.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Set the bit specified by <code>imm</code> from 32-bit elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbitseti_w( __m256i{ 0x0000000000000000, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 1)\n= 0x0000000200000002 0x99aabbceddeeff02 0xabcdef1212341236 0xaabbaabbddeeddee\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] | ((u32)1 &lt;&lt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbsll_v (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbsll_v (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvbsll.v xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute whole vector `a` shifted left by `imm * 8` bits.\n\n\n\n\n\n### Operation\n\n```c++\nint shift = (imm * 8) % 128;\ndst.qword[0] = (u128)a.qword[0] << shift;\ndst.qword[1] = (u128)a.qword[1] << shift;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbsll_v (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbsll.v xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute whole vector <code>a</code> shifted left by <code>imm * 8</code> bits.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int shift = (imm * 8) % 128;\ndst.qword[0] = (u128)a.qword[0] &lt;&lt; shift;\ndst.qword[1] = (u128)a.qword[1] &lt;&lt; shift;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvbsrl_v (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvbsrl_v (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvbsrl.v xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute whole vector `a` shifted right by `imm * 8` bits.\n\n\n\n\n\n### Operation\n\n```c++\nint shift = (imm * 8) % 128;\ndst.qword[0] = (u128)a.qword[0] >> shift;\ndst.qword[1] = (u128)a.qword[1] >> shift;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvbsrl_v (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvbsrl.v xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute whole vector <code>a</code> shifted right by <code>imm * 8</code> bits.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int shift = (imm * 8) % 128;\ndst.qword[0] = (u128)a.qword[0] &gt;&gt; shift;\ndst.qword[1] = (u128)a.qword[1] &gt;&gt; shift;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvclo_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvclo_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvclo.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount leading ones of 8-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvclo_b(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000001 0x0101010202030800 0x0102030000000000 0x0101010102030203\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = clo(a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclo_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvclo.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading ones of 8-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclo_b(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000001 0x0101010202030800 0x0102030000000000 0x0101010102030203\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = clo(a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvclo_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvclo_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvclo.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount leading ones of 64-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvclo_d(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000000 0x0000000000000001 0x0000000000000001 0x0000000000000001\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = clo(a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclo_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvclo.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading ones of 64-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclo_d(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000000 0x0000000000000001 0x0000000000000001 0x0000000000000001\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = clo(a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvclo_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvclo_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvclo.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount leading ones of 16-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvclo_h(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000000 0x0001000100020008 0x0001000300000000 0x0001000100020002\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = clo(a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclo_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvclo.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading ones of 16-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclo_h(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000000 0x0001000100020008 0x0001000300000000 0x0001000100020002\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = clo(a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvclo_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvclo_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvclo.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount leading ones of 32-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvclo_w(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000000 0x0000000100000002 0x0000000100000000 0x0000000100000002\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = clo(a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclo_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvclo.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading ones of 32-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclo_w(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000000 0x0000000100000002 0x0000000100000000 0x0000000100000002\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = clo(a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvclz_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvclz_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvclz.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount leading zeros of 8-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvclz_b(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0302020101010100 0x0000000000000008 0x0000000303020302 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = clz(a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclz_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvclz.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading zeros of 8-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclz_b(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0302020101010100 0x0000000000000008 0x0000000303020302 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = clz(a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvclz_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvclz_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvclz.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount leading zeros of 64-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvclz_d(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000003 0x0000000000000000 0x0000000000000000 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = clz(a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclz_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvclz.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading zeros of 64-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclz_d(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000000000003 0x0000000000000000 0x0000000000000000 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = clz(a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvclz_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvclz_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvclz.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount leading zeros of 16-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvclz_h(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0003000200010001 0x0000000000000000 0x0000000000030003 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = clz(a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclz_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvclz.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading zeros of 16-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclz_h(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0003000200010001 0x0000000000000000 0x0000000000030003 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = clz(a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvclz_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvclz_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvclz.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount leading zeros of 32-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvclz_w(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000300000001 0x0000000000000000 0x0000000000000003 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = clz(a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclz_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvclz.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count leading zeros of 32-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvclz_w(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000300000001 0x0000000000000000 0x0000000000000003 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = clz(a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvdiv_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvdiv_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvdiv.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide signed 8-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((s8)a.byte[i] / (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 32, 36 | 0.05(1/20.5) |\n| 3A6000 | LA664 | 29, 32 | 0.06(1/15.5) |\n| 3C6000 | LA664 | 55, 57 | 0.04(1/27.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvdiv_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvdiv.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide signed 8-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((s8)a.byte[i] / (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>32, 36</td>\n<td>0.05(1/20.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>29, 32</td>\n<td>0.06(1/15.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>55, 57</td>\n<td>0.04(1/27.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvdiv_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvdiv_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvdiv.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide unsigned 8-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((u8)a.byte[i] / (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 29, 36 | 0.05(1/20.5) |\n| 3A6000 | LA664 | 29, 33 | 0.06(1/16.5) |\n| 3C6000 | LA664 | 29, 36 | 0.07(1/13.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvdiv_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvdiv.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((u8)a.byte[i] / (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>29, 36</td>\n<td>0.05(1/20.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>29, 33</td>\n<td>0.06(1/16.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>29, 36</td>\n<td>0.07(1/13.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvdiv_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvdiv_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvdiv.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide signed 64-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((s64)a.dword[i] / (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 18.5 | 0.11(1/9) |\n| 3A6000 | LA664 | 8 | 0.25(1/4) |\n| 3C6000 | LA664 | 18.5, 19 | 0.12(1/8.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvdiv_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvdiv.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide signed 64-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((s64)a.dword[i] / (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 18.5</td>\n<td>0.11(1/9)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>18.5, 19</td>\n<td>0.12(1/8.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvdiv_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvdiv_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvdiv.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide unsigned 64-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((u64)a.dword[i] / (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 18.5 | 0.11(1/9) |\n| 3A6000 | LA664 | 8 | 0.25(1/4) |\n| 3C6000 | LA664 | 8, 18.5 | 0.33(1/3) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvdiv_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvdiv.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((u64)a.dword[i] / (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 18.5</td>\n<td>0.11(1/9)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8, 18.5</td>\n<td>0.33(1/3)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvdiv_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvdiv_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvdiv.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide signed 16-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((s16)a.half[i] / (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 21.5, 22 | 0.08(1/13) |\n| 3A6000 | LA664 | 17 | 0.12(1/8.5) |\n| 3C6000 | LA664 | 34, 40 | 0.05(1/19) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvdiv_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvdiv.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide signed 16-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((s16)a.half[i] / (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>21.5, 22</td>\n<td>0.08(1/13)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17</td>\n<td>0.12(1/8.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>34, 40</td>\n<td>0.05(1/19)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvdiv_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvdiv_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvdiv.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide unsigned 16-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((u16)a.half[i] / (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 17, 21.5 | 0.07(1/15) |\n| 3A6000 | LA664 | 17, 22 | 0.11(1/9) |\n| 3C6000 | LA664 | 17, 21.5 | 0.13(1/7.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvdiv_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvdiv.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((u16)a.half[i] / (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>17, 21.5</td>\n<td>0.07(1/15)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17, 22</td>\n<td>0.11(1/9)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>17, 21.5</td>\n<td>0.13(1/7.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvdiv_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvdiv_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvdiv.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide signed 32-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((s32)a.word[i] / (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 17.5 | 0.09(1/11.5) |\n| 3A6000 | LA664 | 11 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 23.5, 30 | 0.13(1/7.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvdiv_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvdiv.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide signed 32-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((s32)a.word[i] / (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 17.5</td>\n<td>0.09(1/11.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>23.5, 30</td>\n<td>0.13(1/7.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvdiv_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvdiv_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvdiv.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nDivide unsigned 32-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((u32)a.word[i] / (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 17.5 | 0.07(1/15) |\n| 3A6000 | LA664 | 11 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11, 17.5 | 0.22(1/4.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvdiv_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvdiv.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Divide unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((u32)a.word[i] / (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 17.5</td>\n<td>0.07(1/15)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11, 17.5</td>\n<td>0.22(1/4.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvexth_d_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvexth_d_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvexth.d.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend signed 32-bit elements in the higher half of `a` to 64-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i + 2];\n}\nfor (; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)((s32)a.word[2]);\n  dst.dword[1] = (s64)((s32)a.word[3]);\n  dst.dword[2] = (s64)((s32)a.word[6]);\n  dst.dword[3] = (s64)((s32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvexth_d_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvexth.d.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 32-bit elements in the higher half of <code>a</code> to 64-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i + 2];\n}\nfor (; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)((s32)a.word[2]);\n  dst.dword[1] = (s64)((s32)a.word[3]);\n  dst.dword[2] = (s64)((s32)a.word[6]);\n  dst.dword[3] = (s64)((s32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvexth_du_wu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvexth_du_wu (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvexth.du.wu xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend unsigned 32-bit elements in the higher half of `a` to 64-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i + 2];\n}\nfor (; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (u64)((u32)a.word[2]);\n  dst.dword[1] = (u64)((u32)a.word[3]);\n  dst.dword[2] = (u64)((u32)a.word[6]);\n  dst.dword[3] = (u64)((u32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvexth_du_wu (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvexth.du.wu xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 32-bit elements in the higher half of <code>a</code> to 64-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i + 2];\n}\nfor (; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (u64)((u32)a.word[2]);\n  dst.dword[1] = (u64)((u32)a.word[3]);\n  dst.dword[2] = (u64)((u32)a.word[6]);\n  dst.dword[3] = (u64)((u32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvexth_h_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvexth_h_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvexth.h.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend signed 8-bit elements in the higher half of `a` to 16-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i + 8];\n}\nfor (; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i + 16];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (s16)((s8)a.byte[8]);\n  dst.half[1] = (s16)((s8)a.byte[9]);\n  dst.half[2] = (s16)((s8)a.byte[10]);\n  dst.half[3] = (s16)((s8)a.byte[11]);\n  dst.half[4] = (s16)((s8)a.byte[12]);\n  dst.half[5] = (s16)((s8)a.byte[13]);\n  dst.half[6] = (s16)((s8)a.byte[14]);\n  dst.half[7] = (s16)((s8)a.byte[15]);\n  dst.half[8] = (s16)((s8)a.byte[24]);\n  dst.half[9] = (s16)((s8)a.byte[25]);\n  dst.half[10] = (s16)((s8)a.byte[26]);\n  dst.half[11] = (s16)((s8)a.byte[27]);\n  dst.half[12] = (s16)((s8)a.byte[28]);\n  dst.half[13] = (s16)((s8)a.byte[29]);\n  dst.half[14] = (s16)((s8)a.byte[30]);\n  dst.half[15] = (s16)((s8)a.byte[31]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvexth_h_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvexth.h.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 8-bit elements in the higher half of <code>a</code> to 16-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i + 8];\n}\nfor (; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i + 16];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (s16)((s8)a.byte[8]);\n  dst.half[1] = (s16)((s8)a.byte[9]);\n  dst.half[2] = (s16)((s8)a.byte[10]);\n  dst.half[3] = (s16)((s8)a.byte[11]);\n  dst.half[4] = (s16)((s8)a.byte[12]);\n  dst.half[5] = (s16)((s8)a.byte[13]);\n  dst.half[6] = (s16)((s8)a.byte[14]);\n  dst.half[7] = (s16)((s8)a.byte[15]);\n  dst.half[8] = (s16)((s8)a.byte[24]);\n  dst.half[9] = (s16)((s8)a.byte[25]);\n  dst.half[10] = (s16)((s8)a.byte[26]);\n  dst.half[11] = (s16)((s8)a.byte[27]);\n  dst.half[12] = (s16)((s8)a.byte[28]);\n  dst.half[13] = (s16)((s8)a.byte[29]);\n  dst.half[14] = (s16)((s8)a.byte[30]);\n  dst.half[15] = (s16)((s8)a.byte[31]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvexth_hu_bu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvexth_hu_bu (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvexth.hu.bu xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend unsigned 8-bit elements in the higher half of `a` to 16-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i + 8];\n}\nfor (; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i + 16];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (u16)((u8)a.byte[8]);\n  dst.half[1] = (u16)((u8)a.byte[9]);\n  dst.half[2] = (u16)((u8)a.byte[10]);\n  dst.half[3] = (u16)((u8)a.byte[11]);\n  dst.half[4] = (u16)((u8)a.byte[12]);\n  dst.half[5] = (u16)((u8)a.byte[13]);\n  dst.half[6] = (u16)((u8)a.byte[14]);\n  dst.half[7] = (u16)((u8)a.byte[15]);\n  dst.half[8] = (u16)((u8)a.byte[24]);\n  dst.half[9] = (u16)((u8)a.byte[25]);\n  dst.half[10] = (u16)((u8)a.byte[26]);\n  dst.half[11] = (u16)((u8)a.byte[27]);\n  dst.half[12] = (u16)((u8)a.byte[28]);\n  dst.half[13] = (u16)((u8)a.byte[29]);\n  dst.half[14] = (u16)((u8)a.byte[30]);\n  dst.half[15] = (u16)((u8)a.byte[31]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvexth_hu_bu (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvexth.hu.bu xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 8-bit elements in the higher half of <code>a</code> to 16-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i + 8];\n}\nfor (; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i + 16];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (u16)((u8)a.byte[8]);\n  dst.half[1] = (u16)((u8)a.byte[9]);\n  dst.half[2] = (u16)((u8)a.byte[10]);\n  dst.half[3] = (u16)((u8)a.byte[11]);\n  dst.half[4] = (u16)((u8)a.byte[12]);\n  dst.half[5] = (u16)((u8)a.byte[13]);\n  dst.half[6] = (u16)((u8)a.byte[14]);\n  dst.half[7] = (u16)((u8)a.byte[15]);\n  dst.half[8] = (u16)((u8)a.byte[24]);\n  dst.half[9] = (u16)((u8)a.byte[25]);\n  dst.half[10] = (u16)((u8)a.byte[26]);\n  dst.half[11] = (u16)((u8)a.byte[27]);\n  dst.half[12] = (u16)((u8)a.byte[28]);\n  dst.half[13] = (u16)((u8)a.byte[29]);\n  dst.half[14] = (u16)((u8)a.byte[30]);\n  dst.half[15] = (u16)((u8)a.byte[31]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvexth_q_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvexth_q_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvexth.q.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend signed 64-bit elements in the higher half of `a` to 128-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i + 1];\n}\nfor (; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (s128)((s64)a.dword[1]);\n  dst.qword[1] = (s128)((s64)a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvexth_q_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvexth.q.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 64-bit elements in the higher half of <code>a</code> to 128-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i + 1];\n}\nfor (; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (s128)((s64)a.dword[1]);\n  dst.qword[1] = (s128)((s64)a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvexth_qu_du (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvexth_qu_du (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvexth.qu.du xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend unsigned 64-bit elements in the higher half of `a` to 128-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i + 1];\n}\nfor (; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (u128)((u64)a.dword[1]);\n  dst.qword[1] = (u128)((u64)a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvexth_qu_du (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvexth.qu.du xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 64-bit elements in the higher half of <code>a</code> to 128-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i + 1];\n}\nfor (; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (u128)((u64)a.dword[1]);\n  dst.qword[1] = (u128)((u64)a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvexth_w_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvexth_w_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvexth.w.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend signed 16-bit elements in the higher half of `a` to 32-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[i + 4];\n}\nfor (; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)((s16)a.half[4]);\n  dst.word[1] = (s32)((s16)a.half[5]);\n  dst.word[2] = (s32)((s16)a.half[6]);\n  dst.word[3] = (s32)((s16)a.half[7]);\n  dst.word[4] = (s32)((s16)a.half[12]);\n  dst.word[5] = (s32)((s16)a.half[13]);\n  dst.word[6] = (s32)((s16)a.half[14]);\n  dst.word[7] = (s32)((s16)a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvexth_w_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvexth.w.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 16-bit elements in the higher half of <code>a</code> to 32-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[i + 4];\n}\nfor (; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)((s16)a.half[4]);\n  dst.word[1] = (s32)((s16)a.half[5]);\n  dst.word[2] = (s32)((s16)a.half[6]);\n  dst.word[3] = (s32)((s16)a.half[7]);\n  dst.word[4] = (s32)((s16)a.half[12]);\n  dst.word[5] = (s32)((s16)a.half[13]);\n  dst.word[6] = (s32)((s16)a.half[14]);\n  dst.word[7] = (s32)((s16)a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvexth_wu_hu (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvexth_wu_hu (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvexth.wu.hu xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend unsigned 16-bit elements in the higher half of `a` to 32-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[i + 4];\n}\nfor (; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (u32)((u16)a.half[4]);\n  dst.word[1] = (u32)((u16)a.half[5]);\n  dst.word[2] = (u32)((u16)a.half[6]);\n  dst.word[3] = (u32)((u16)a.half[7]);\n  dst.word[4] = (u32)((u16)a.half[12]);\n  dst.word[5] = (u32)((u16)a.half[13]);\n  dst.word[6] = (u32)((u16)a.half[14]);\n  dst.word[7] = (u32)((u16)a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvexth_wu_hu (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvexth.wu.hu xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 16-bit elements in the higher half of <code>a</code> to 32-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[i + 4];\n}\nfor (; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[i + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (u32)((u16)a.half[4]);\n  dst.word[1] = (u32)((u16)a.half[5]);\n  dst.word[2] = (u32)((u16)a.half[6]);\n  dst.word[3] = (u32)((u16)a.half[7]);\n  dst.word[4] = (u32)((u16)a.half[12]);\n  dst.word[5] = (u32)((u16)a.half[13]);\n  dst.word[6] = (u32)((u16)a.half[14]);\n  dst.word[7] = (u32)((u16)a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvextl_q_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvextl_q_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvextl.q.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend signed 64-bit elements in the lower half of `a` to 128-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i];\n}\nfor (; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (s128)((s64)a.dword[0]);\n  dst.qword[1] = (s128)((s64)a.dword[2]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvextl_q_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvextl.q.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend signed 64-bit elements in the lower half of <code>a</code> to 128-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i];\n}\nfor (; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (s128)((s64)a.dword[0]);\n  dst.qword[1] = (s128)((s64)a.dword[2]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvextl_qu_du (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvextl_qu_du (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvextl.qu.du xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nExtend unsigned 64-bit elements in the lower half of `a` to 128-bit.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i];\n}\nfor (; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (u128)((u64)a.dword[0]);\n  dst.qword[1] = (u128)((u64)a.dword[2]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvextl_qu_du (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvextl.qu.du xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend unsigned 64-bit elements in the lower half of <code>a</code> to 128-bit.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 1; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i];\n}\nfor (; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (u128)((u64)a.dword[0]);\n  dst.qword[1] = (u128)((u64)a.dword[2]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvextrins_b (__m256i a, __m256i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvextrins_b (__m256i a, __m256i b, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvextrins.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtract one 8-bit element in `b` and insert it to `a` according to `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 16; i++) {\n  dst.byte[i] = (i == ((imm >> 4) & 15)) ? b.byte[imm & 15] : a.byte[i];\n}\nfor (; i < 32; i++) {\n  dst.byte[i] =\n      (i - 16 == ((imm >> 4) & 15)) ? b.byte[(imm & 15) + 16] : a.byte[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = (0 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[0]);\n  dst.byte[1] = (1 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[1]);\n  dst.byte[2] = (2 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[2]);\n  dst.byte[3] = (3 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[3]);\n  dst.byte[4] = (4 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[4]);\n  dst.byte[5] = (5 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[5]);\n  dst.byte[6] = (6 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[6]);\n  dst.byte[7] = (7 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[7]);\n  dst.byte[8] = (8 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[8]);\n  dst.byte[9] = (9 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[9]);\n  dst.byte[10] = (10 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[10]);\n  dst.byte[11] = (11 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[11]);\n  dst.byte[12] = (12 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[12]);\n  dst.byte[13] = (13 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[13]);\n  dst.byte[14] = (14 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[14]);\n  dst.byte[15] = (15 == ((imm >> 4) & 15)) ? (b.byte[imm & 15]) : (a.byte[15]);\n  dst.byte[16] =\n      (0 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[16]);\n  dst.byte[17] =\n      (1 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[17]);\n  dst.byte[18] =\n      (2 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[18]);\n  dst.byte[19] =\n      (3 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[19]);\n  dst.byte[20] =\n      (4 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[20]);\n  dst.byte[21] =\n      (5 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[21]);\n  dst.byte[22] =\n      (6 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[22]);\n  dst.byte[23] =\n      (7 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[23]);\n  dst.byte[24] =\n      (8 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[24]);\n  dst.byte[25] =\n      (9 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[25]);\n  dst.byte[26] =\n      (10 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[26]);\n  dst.byte[27] =\n      (11 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[27]);\n  dst.byte[28] =\n      (12 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[28]);\n  dst.byte[29] =\n      (13 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[29]);\n  dst.byte[30] =\n      (14 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[30]);\n  dst.byte[31] =\n      (15 == ((imm >> 4) & 15)) ? (b.byte[(imm & 15) + 16]) : (a.byte[31]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvextrins_b (__m256i a, __m256i b, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvextrins.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extract one 8-bit element in <code>b</code> and insert it to <code>a</code> according to <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i == ((imm &gt;&gt; 4) &amp; 15)) ? b.byte[imm &amp; 15] : a.byte[i];\n}\nfor (; i &lt; 32; i++) {\n  dst.byte[i] =\n      (i - 16 == ((imm &gt;&gt; 4) &amp; 15)) ? b.byte[(imm &amp; 15) + 16] : a.byte[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = (0 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[0]);\n  dst.byte[1] = (1 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[1]);\n  dst.byte[2] = (2 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[2]);\n  dst.byte[3] = (3 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[3]);\n  dst.byte[4] = (4 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[4]);\n  dst.byte[5] = (5 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[5]);\n  dst.byte[6] = (6 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[6]);\n  dst.byte[7] = (7 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[7]);\n  dst.byte[8] = (8 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[8]);\n  dst.byte[9] = (9 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[9]);\n  dst.byte[10] = (10 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[10]);\n  dst.byte[11] = (11 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[11]);\n  dst.byte[12] = (12 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[12]);\n  dst.byte[13] = (13 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[13]);\n  dst.byte[14] = (14 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[14]);\n  dst.byte[15] = (15 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[imm &amp; 15]) : (a.byte[15]);\n  dst.byte[16] =\n      (0 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[16]);\n  dst.byte[17] =\n      (1 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[17]);\n  dst.byte[18] =\n      (2 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[18]);\n  dst.byte[19] =\n      (3 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[19]);\n  dst.byte[20] =\n      (4 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[20]);\n  dst.byte[21] =\n      (5 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[21]);\n  dst.byte[22] =\n      (6 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[22]);\n  dst.byte[23] =\n      (7 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[23]);\n  dst.byte[24] =\n      (8 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[24]);\n  dst.byte[25] =\n      (9 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[25]);\n  dst.byte[26] =\n      (10 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[26]);\n  dst.byte[27] =\n      (11 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[27]);\n  dst.byte[28] =\n      (12 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[28]);\n  dst.byte[29] =\n      (13 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[29]);\n  dst.byte[30] =\n      (14 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[30]);\n  dst.byte[31] =\n      (15 == ((imm &gt;&gt; 4) &amp; 15)) ? (b.byte[(imm &amp; 15) + 16]) : (a.byte[31]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvextrins_d (__m256i a, __m256i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvextrins_d (__m256i a, __m256i b, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvextrins.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtract one 64-bit element in `b` and insert it to `a` according to `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.dword[i] = (i == ((imm >> 4) & 1)) ? b.dword[imm & 1] : a.dword[i];\n}\nfor (; i < 4; i++) {\n  dst.dword[i] =\n      (i - 2 == ((imm >> 4) & 1)) ? b.dword[(imm & 1) + 2] : a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (0 == ((imm >> 4) & 1)) ? (b.dword[imm & 1]) : (a.dword[0]);\n  dst.dword[1] = (1 == ((imm >> 4) & 1)) ? (b.dword[imm & 1]) : (a.dword[1]);\n  dst.dword[2] =\n      (0 == ((imm >> 4) & 1)) ? (b.dword[(imm & 1) + 2]) : (a.dword[2]);\n  dst.dword[3] =\n      (1 == ((imm >> 4) & 1)) ? (b.dword[(imm & 1) + 2]) : (a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvextrins_d (__m256i a, __m256i b, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvextrins.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extract one 64-bit element in <code>b</code> and insert it to <code>a</code> according to <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i == ((imm &gt;&gt; 4) &amp; 1)) ? b.dword[imm &amp; 1] : a.dword[i];\n}\nfor (; i &lt; 4; i++) {\n  dst.dword[i] =\n      (i - 2 == ((imm &gt;&gt; 4) &amp; 1)) ? b.dword[(imm &amp; 1) + 2] : a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (0 == ((imm &gt;&gt; 4) &amp; 1)) ? (b.dword[imm &amp; 1]) : (a.dword[0]);\n  dst.dword[1] = (1 == ((imm &gt;&gt; 4) &amp; 1)) ? (b.dword[imm &amp; 1]) : (a.dword[1]);\n  dst.dword[2] =\n      (0 == ((imm &gt;&gt; 4) &amp; 1)) ? (b.dword[(imm &amp; 1) + 2]) : (a.dword[2]);\n  dst.dword[3] =\n      (1 == ((imm &gt;&gt; 4) &amp; 1)) ? (b.dword[(imm &amp; 1) + 2]) : (a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvextrins_h (__m256i a, __m256i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvextrins_h (__m256i a, __m256i b, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvextrins.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtract one 16-bit element in `b` and insert it to `a` according to `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 8; i++) {\n  dst.half[i] = (i == ((imm >> 4) & 7)) ? b.half[imm & 7] : a.half[i];\n}\nfor (; i < 16; i++) {\n  dst.half[i] = (i - 8 == ((imm >> 4) & 7)) ? b.half[(imm & 7) + 8] : a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (0 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[0]);\n  dst.half[1] = (1 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[1]);\n  dst.half[2] = (2 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[2]);\n  dst.half[3] = (3 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[3]);\n  dst.half[4] = (4 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[4]);\n  dst.half[5] = (5 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[5]);\n  dst.half[6] = (6 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[6]);\n  dst.half[7] = (7 == ((imm >> 4) & 7)) ? (b.half[imm & 7]) : (a.half[7]);\n  dst.half[8] = (0 == ((imm >> 4) & 7)) ? (b.half[(imm & 7) + 8]) : (a.half[8]);\n  dst.half[9] = (1 == ((imm >> 4) & 7)) ? (b.half[(imm & 7) + 8]) : (a.half[9]);\n  dst.half[10] =\n      (2 == ((imm >> 4) & 7)) ? (b.half[(imm & 7) + 8]) : (a.half[10]);\n  dst.half[11] =\n      (3 == ((imm >> 4) & 7)) ? (b.half[(imm & 7) + 8]) : (a.half[11]);\n  dst.half[12] =\n      (4 == ((imm >> 4) & 7)) ? (b.half[(imm & 7) + 8]) : (a.half[12]);\n  dst.half[13] =\n      (5 == ((imm >> 4) & 7)) ? (b.half[(imm & 7) + 8]) : (a.half[13]);\n  dst.half[14] =\n      (6 == ((imm >> 4) & 7)) ? (b.half[(imm & 7) + 8]) : (a.half[14]);\n  dst.half[15] =\n      (7 == ((imm >> 4) & 7)) ? (b.half[(imm & 7) + 8]) : (a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvextrins_h (__m256i a, __m256i b, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvextrins.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extract one 16-bit element in <code>b</code> and insert it to <code>a</code> according to <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i == ((imm &gt;&gt; 4) &amp; 7)) ? b.half[imm &amp; 7] : a.half[i];\n}\nfor (; i &lt; 16; i++) {\n  dst.half[i] = (i - 8 == ((imm &gt;&gt; 4) &amp; 7)) ? b.half[(imm &amp; 7) + 8] : a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = (0 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[0]);\n  dst.half[1] = (1 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[1]);\n  dst.half[2] = (2 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[2]);\n  dst.half[3] = (3 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[3]);\n  dst.half[4] = (4 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[4]);\n  dst.half[5] = (5 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[5]);\n  dst.half[6] = (6 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[6]);\n  dst.half[7] = (7 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[imm &amp; 7]) : (a.half[7]);\n  dst.half[8] = (0 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[(imm &amp; 7) + 8]) : (a.half[8]);\n  dst.half[9] = (1 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[(imm &amp; 7) + 8]) : (a.half[9]);\n  dst.half[10] =\n      (2 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[(imm &amp; 7) + 8]) : (a.half[10]);\n  dst.half[11] =\n      (3 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[(imm &amp; 7) + 8]) : (a.half[11]);\n  dst.half[12] =\n      (4 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[(imm &amp; 7) + 8]) : (a.half[12]);\n  dst.half[13] =\n      (5 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[(imm &amp; 7) + 8]) : (a.half[13]);\n  dst.half[14] =\n      (6 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[(imm &amp; 7) + 8]) : (a.half[14]);\n  dst.half[15] =\n      (7 == ((imm &gt;&gt; 4) &amp; 7)) ? (b.half[(imm &amp; 7) + 8]) : (a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvextrins_w (__m256i a, __m256i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvextrins_w (__m256i a, __m256i b, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvextrins.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtract one 32-bit element in `b` and insert it to `a` according to `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.word[i] = (i == ((imm >> 4) & 3)) ? b.word[imm & 3] : a.word[i];\n}\nfor (; i < 8; i++) {\n  dst.word[i] = (i - 4 == ((imm >> 4) & 3)) ? b.word[(imm & 3) + 4] : a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (0 == ((imm >> 4) & 3)) ? (b.word[imm & 3]) : (a.word[0]);\n  dst.word[1] = (1 == ((imm >> 4) & 3)) ? (b.word[imm & 3]) : (a.word[1]);\n  dst.word[2] = (2 == ((imm >> 4) & 3)) ? (b.word[imm & 3]) : (a.word[2]);\n  dst.word[3] = (3 == ((imm >> 4) & 3)) ? (b.word[imm & 3]) : (a.word[3]);\n  dst.word[4] = (0 == ((imm >> 4) & 3)) ? (b.word[(imm & 3) + 4]) : (a.word[4]);\n  dst.word[5] = (1 == ((imm >> 4) & 3)) ? (b.word[(imm & 3) + 4]) : (a.word[5]);\n  dst.word[6] = (2 == ((imm >> 4) & 3)) ? (b.word[(imm & 3) + 4]) : (a.word[6]);\n  dst.word[7] = (3 == ((imm >> 4) & 3)) ? (b.word[(imm & 3) + 4]) : (a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvextrins_w (__m256i a, __m256i b, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvextrins.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extract one 32-bit element in <code>b</code> and insert it to <code>a</code> according to <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i == ((imm &gt;&gt; 4) &amp; 3)) ? b.word[imm &amp; 3] : a.word[i];\n}\nfor (; i &lt; 8; i++) {\n  dst.word[i] = (i - 4 == ((imm &gt;&gt; 4) &amp; 3)) ? b.word[(imm &amp; 3) + 4] : a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (0 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[imm &amp; 3]) : (a.word[0]);\n  dst.word[1] = (1 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[imm &amp; 3]) : (a.word[1]);\n  dst.word[2] = (2 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[imm &amp; 3]) : (a.word[2]);\n  dst.word[3] = (3 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[imm &amp; 3]) : (a.word[3]);\n  dst.word[4] = (0 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[(imm &amp; 3) + 4]) : (a.word[4]);\n  dst.word[5] = (1 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[(imm &amp; 3) + 4]) : (a.word[5]);\n  dst.word[6] = (2 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[(imm &amp; 3) + 4]) : (a.word[6]);\n  dst.word[7] = (3 == ((imm &gt;&gt; 4) &amp; 3)) ? (b.word[(imm &amp; 3) + 4]) : (a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfclass_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfclass_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvfclass.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nClassifiy each double precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = fp_classify(a.fp64[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfclass_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfclass.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Classifiy each double precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = fp_classify(a.fp64[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfclass_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfclass_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvfclass.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nClassifiy each single precision floating point elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.word[i] = fp_classify(a.fp32[i]);\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfclass_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfclass.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Classifiy each single precision floating point elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.word[i] = fp_classify(a.fp32[i]);\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_caf_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_caf_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.caf.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if AF(Always False), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_caf(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_caf_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.caf.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if AF(Always False), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_caf(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_caf_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_caf_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.caf.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if AF(Always False), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_caf(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_caf_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.caf.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if AF(Always False), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_caf(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_ceq_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_ceq_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.ceq.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_ceq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_ceq_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.ceq.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_ceq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_ceq_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_ceq_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.ceq.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_ceq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_ceq_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.ceq.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_ceq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cle_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cle_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cle.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cle(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cle_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cle.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cle(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cle_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cle_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cle.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_cle(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cle_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cle.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_cle(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_clt_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_clt_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.clt.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if LT(Less than), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_clt(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_clt_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.clt.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LT(Less than), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_clt(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_clt_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_clt_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.clt.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if LT(Less than), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_clt(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_clt_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.clt.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LT(Less than), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_clt(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cne_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cne_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cne.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cne(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cne_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cne.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cne(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cne_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cne_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cne.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_cne(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cne_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cne.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_cne(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cor_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cor_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cor.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cor(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cor_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cor.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cor(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cor_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cor_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cor.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_cor(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cor_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cor.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_cor(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cueq_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cueq_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cueq.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cueq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cueq_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cueq.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cueq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cueq_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cueq_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cueq.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_cueq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cueq_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cueq.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_cueq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cule_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cule_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cule.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cule(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cule_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cule.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cule(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cule_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cule_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cule.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_cule(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cule_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cule.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_cule(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cult_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cult_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cult.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cult(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cult_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cult.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cult(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cult_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cult_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cult.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_cult(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cult_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cult.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_cult(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cun_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cun_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cun.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cun(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cun_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cun.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cun(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cun_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cun_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cun.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_cun(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cun_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cun.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_cun(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cune_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cune_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cune.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_cune(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cune_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cune.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_cune(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_cune_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_cune_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.cune.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into `dst`. Do not trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_cune(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_cune_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.cune.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into <code>dst</code>. Do not trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_cune(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_saf_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_saf_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.saf.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if AF(Always False), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_saf(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_saf_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.saf.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if AF(Always False), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_saf(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_saf_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_saf_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.saf.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if AF(Always False), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_saf(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_saf_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.saf.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if AF(Always False), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_saf(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_seq_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_seq_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.seq.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_seq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_seq_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.seq.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_seq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_seq_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_seq_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.seq.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_seq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_seq_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.seq.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if EQ(Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_seq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sle_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sle_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sle.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sle(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sle_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sle.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sle(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sle_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sle_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sle.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_sle(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sle_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sle.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LE(Less than or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_sle(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_slt_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_slt_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.slt.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if LT(Less than), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_slt(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_slt_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.slt.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LT(Less than), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_slt(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_slt_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_slt_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.slt.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if LT(Less than), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_slt(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_slt_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.slt.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if LT(Less than), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_slt(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sne_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sne_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sne.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sne(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sne_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sne.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sne(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sne_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sne_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sne.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_sne(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sne_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sne.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if NE(Not Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_sne(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sor_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sor_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sor.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sor(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sor_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sor.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sor(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sor_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sor_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sor.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_sor(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sor_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sor.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if OR(Ordered), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_sor(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sueq_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sueq_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sueq.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sueq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sueq_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sueq.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sueq(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sueq_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sueq_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sueq.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_sueq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sueq_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sueq.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UEQ(Unordered or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_sueq(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sule_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sule_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sule.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sule(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sule_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sule.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sule(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sule_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sule_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sule.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_sule(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sule_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sule.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULE(Unordered, Less than or Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_sule(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sult_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sult_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sult.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sult(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sult_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sult.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sult(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sult_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sult_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sult.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_sult(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sult_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sult.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if ULT(Unordered or Less than), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_sult(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sun_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sun_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sun.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sun(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sun_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sun.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sun(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sun_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sun_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sun.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_sun(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sun_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sun.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UN(Unordered), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_sun(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sune_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sune_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sune.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare double precision elements in `a` and `b`, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (fp_compare_sune(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sune_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sune.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare double precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (fp_compare_sune(a.fp64[i], b.fp64[i])) {\n    dst.dword[i] = 0xFFFFFFFFFFFFFFFF;\n  } else {\n    dst.dword[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcmp_sune_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcmp_sune_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcmp.sune.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare single precision elements in `a` and `b`, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into `dst`. Trap for QNaN.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (fp_compare_sune(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcmp_sune_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcmp.sune.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare single precision elements in <code>a</code> and <code>b</code>, save the comparison result (all ones if UNE(Unordered or Not Equal), all zeros otherwise) into <code>dst</code>. Trap for QNaN.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (fp_compare_sune(a.fp32[i], b.fp32[i])) {\n    dst.word[i] = 0xFFFFFFFF;\n  } else {\n    dst.word[i] = 0;\n  }\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfcvt_h_s (__m256 a, __m256 b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfcvt_h_s (__m256 a, __m256 b)\n#include <lasxintrin.h>\nInstruction: xvfcvt.h.s xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single precision floating point elements in `a` and `b` to half precision.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.fp16[i] = b.fp32[i];\n}\nfor (; i < 8; i++) {\n  dst.fp16[i] = a.fp32[i - 4];\n}\nfor (; i < 12; i++) {\n  dst.fp16[i] = b.fp32[i - 4];\n}\nfor (; i < 16; i++) {\n  dst.fp16[i] = a.fp32[i - 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp16[0] = b.fp32[0];\n  dst.fp16[1] = b.fp32[1];\n  dst.fp16[2] = b.fp32[2];\n  dst.fp16[3] = b.fp32[3];\n  dst.fp16[4] = a.fp32[0];\n  dst.fp16[5] = a.fp32[1];\n  dst.fp16[6] = a.fp32[2];\n  dst.fp16[7] = a.fp32[3];\n  dst.fp16[8] = b.fp32[4];\n  dst.fp16[9] = b.fp32[5];\n  dst.fp16[10] = b.fp32[6];\n  dst.fp16[11] = b.fp32[7];\n  dst.fp16[12] = a.fp32[4];\n  dst.fp16[13] = a.fp32[5];\n  dst.fp16[14] = a.fp32[6];\n  dst.fp16[15] = a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 1 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfcvt_h_s (__m256 a, __m256 b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfcvt.h.s xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single precision floating point elements in <code>a</code> and <code>b</code> to half precision.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.fp16[i] = b.fp32[i];\n}\nfor (; i &lt; 8; i++) {\n  dst.fp16[i] = a.fp32[i - 4];\n}\nfor (; i &lt; 12; i++) {\n  dst.fp16[i] = b.fp32[i - 4];\n}\nfor (; i &lt; 16; i++) {\n  dst.fp16[i] = a.fp32[i - 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.fp16[0] = b.fp32[0];\n  dst.fp16[1] = b.fp32[1];\n  dst.fp16[2] = b.fp32[2];\n  dst.fp16[3] = b.fp32[3];\n  dst.fp16[4] = a.fp32[0];\n  dst.fp16[5] = a.fp32[1];\n  dst.fp16[6] = a.fp32[2];\n  dst.fp16[7] = a.fp32[3];\n  dst.fp16[8] = b.fp32[4];\n  dst.fp16[9] = b.fp32[5];\n  dst.fp16[10] = b.fp32[6];\n  dst.fp16[11] = b.fp32[7];\n  dst.fp16[12] = a.fp32[4];\n  dst.fp16[13] = a.fp32[5];\n  dst.fp16[14] = a.fp32[6];\n  dst.fp16[15] = a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfrstp_b (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfrstp_b (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvfrstp.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nFind the first negative 8-bit element in `b`, set the index of the element to the lane of `a` specified by `c`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i];\n}\nint i;\nfor (i = 0; i < 16; i++) {\n  if ((s8)b.byte[i] < 0) {\n    break;\n  }\n}\ndst.byte[c.byte[0] % 16] = i;\nfor (i = 16; i < 32; i++) {\n  if ((s8)b.byte[i] < 0) {\n    break;\n  }\n}\ndst.byte[(c.byte[16] % 16) + 16] = i - 16;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfrstp_b (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrstp.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Find the first negative 8-bit element in <code>b</code>, set the index of the element to the lane of <code>a</code> specified by <code>c</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i];\n}\nint i;\nfor (i = 0; i &lt; 16; i++) {\n  if ((s8)b.byte[i] &lt; 0) {\n    break;\n  }\n}\ndst.byte[c.byte[0] % 16] = i;\nfor (i = 16; i &lt; 32; i++) {\n  if ((s8)b.byte[i] &lt; 0) {\n    break;\n  }\n}\ndst.byte[(c.byte[16] % 16) + 16] = i - 16;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfrstp_h (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfrstp_h (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvfrstp.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nFind the first negative 16-bit element in `b`, set the index of the element to the lane of `a` specified by `c`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i];\n}\nint i;\nfor (i = 0; i < 8; i++) {\n  if ((s16)b.half[i] < 0) {\n    break;\n  }\n}\ndst.half[c.half[0] % 8] = i;\nfor (i = 8; i < 16; i++) {\n  if ((s16)b.half[i] < 0) {\n    break;\n  }\n}\ndst.half[(c.half[8] % 8) + 8] = i - 8;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfrstp_h (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrstp.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Find the first negative 16-bit element in <code>b</code>, set the index of the element to the lane of <code>a</code> specified by <code>c</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i];\n}\nint i;\nfor (i = 0; i &lt; 8; i++) {\n  if ((s16)b.half[i] &lt; 0) {\n    break;\n  }\n}\ndst.half[c.half[0] % 8] = i;\nfor (i = 8; i &lt; 16; i++) {\n  if ((s16)b.half[i] &lt; 0) {\n    break;\n  }\n}\ndst.half[(c.half[8] % 8) + 8] = i - 8;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfrstpi_b (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfrstpi_b (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvfrstpi.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nFind the first negative 8-bit element in `b`, set the index of the element to the lane of `a` specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i];\n}\nint i;\nfor (i = 0; i < 16; i++) {\n  if ((s8)b.byte[i] < 0) {\n    break;\n  }\n}\ndst.byte[imm % 16] = i;\nfor (i = 16; i < 32; i++) {\n  if ((s8)b.byte[i] < 0) {\n    break;\n  }\n}\ndst.byte[(imm % 16) + 16] = i - 16;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfrstpi_b (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrstpi.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Find the first negative 8-bit element in <code>b</code>, set the index of the element to the lane of <code>a</code> specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i];\n}\nint i;\nfor (i = 0; i &lt; 16; i++) {\n  if ((s8)b.byte[i] &lt; 0) {\n    break;\n  }\n}\ndst.byte[imm % 16] = i;\nfor (i = 16; i &lt; 32; i++) {\n  if ((s8)b.byte[i] &lt; 0) {\n    break;\n  }\n}\ndst.byte[(imm % 16) + 16] = i - 16;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvfrstpi_h (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvfrstpi_h (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvfrstpi.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nFind the first negative 16-bit element in `b`, set the index of the element to the lane of `a` specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i];\n}\nint i;\nfor (i = 0; i < 8; i++) {\n  if ((s16)b.half[i] < 0) {\n    break;\n  }\n}\ndst.half[imm % 8] = i;\nfor (i = 8; i < 16; i++) {\n  if ((s16)b.half[i] < 0) {\n    break;\n  }\n}\ndst.half[(imm % 8) + 8] = i - 8;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvfrstpi_h (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvfrstpi.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Find the first negative 16-bit element in <code>b</code>, set the index of the element to the lane of <code>a</code> specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i];\n}\nint i;\nfor (i = 0; i &lt; 8; i++) {\n  if ((s16)b.half[i] &lt; 0) {\n    break;\n  }\n}\ndst.half[imm % 8] = i;\nfor (i = 8; i &lt; 16; i++) {\n  if ((s16)b.half[i] &lt; 0) {\n    break;\n  }\n}\ndst.half[(imm % 8) + 8] = i - 8;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftint_l_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftint_l_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvftint.l.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftint_l_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftint.l.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftint_lu_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftint_lu_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvftint.lu.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to unsigned 64-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (u64)a.fp64[0];\n  dst.dword[1] = (u64)a.fp64[1];\n  dst.dword[2] = (u64)a.fp64[2];\n  dst.dword[3] = (u64)a.fp64[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftint_lu_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftint.lu.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to unsigned 64-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (u64)a.fp64[0];\n  dst.dword[1] = (u64)a.fp64[1];\n  dst.dword[2] = (u64)a.fp64[2];\n  dst.dword[3] = (u64)a.fp64[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftint_w_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftint_w_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvftint.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftint_w_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftint.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftint_w_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftint_w_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftint.w.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftint_w_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftint.w.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftint_wu_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftint_wu_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftint.wu.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to unsigned 32-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (u32)a.fp32[0];\n  dst.word[1] = (u32)a.fp32[1];\n  dst.word[2] = (u32)a.fp32[2];\n  dst.word[3] = (u32)a.fp32[3];\n  dst.word[4] = (u32)a.fp32[4];\n  dst.word[5] = (u32)a.fp32[5];\n  dst.word[6] = (u32)a.fp32[6];\n  dst.word[7] = (u32)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftint_wu_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftint.wu.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to unsigned 32-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (u32)a.fp32[0];\n  dst.word[1] = (u32)a.fp32[1];\n  dst.word[2] = (u32)a.fp32[2];\n  dst.word[3] = (u32)a.fp32[3];\n  dst.word[4] = (u32)a.fp32[4];\n  dst.word[5] = (u32)a.fp32[5];\n  dst.word[6] = (u32)a.fp32[6];\n  dst.word[7] = (u32)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftinth_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftinth_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftinth.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftinth_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftinth.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintl_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintl_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintl.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, using current rounding mode specified in `fscr`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintl_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintl.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, using current rounding mode specified in <code>fscr</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrm_l_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrm_l_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvftintrm.l.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrm_l_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrm.l.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrm_w_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrm_w_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvftintrm.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrm_w_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrm.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrm_w_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrm_w_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrm.w.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrm_w_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrm.w.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrmh_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrmh_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrmh.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrmh_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrmh.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrml_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrml_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrml.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, rounding towards negative infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrml_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrml.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, rounding towards negative infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrne_l_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrne_l_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvftintrne.l.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrne_l_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrne.l.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrne_w_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrne_w_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvftintrne.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrne_w_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrne.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrne_w_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrne_w_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrne.w.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrne_w_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrne.w.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrneh_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrneh_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrneh.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrneh_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrneh.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrnel_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrnel_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrnel.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, rounding towards nearest even.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrnel_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrnel.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, rounding towards nearest even.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrp_l_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrp_l_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvftintrp.l.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrp_l_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrp.l.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrp_w_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrp_w_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvftintrp.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrp_w_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrp.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrp_w_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrp_w_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrp.w.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrp_w_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrp.w.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrph_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrph_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrph.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrph_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrph.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrpl_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrpl_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrpl.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, rounding towards positive infinity.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrpl_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrpl.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, rounding towards positive infinity.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrz_l_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrz_l_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvftintrz.l.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to signed 64-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrz_l_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrz.l.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to signed 64-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp64[0];\n  dst.dword[1] = (s64)a.fp64[1];\n  dst.dword[2] = (s64)a.fp64[2];\n  dst.dword[3] = (s64)a.fp64[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrz_lu_d (__m256d a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrz_lu_d (__m256d a)\n#include <lasxintrin.h>\nInstruction: xvftintrz.lu.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` to unsigned 64-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (u64)a.fp64[0];\n  dst.dword[1] = (u64)a.fp64[1];\n  dst.dword[2] = (u64)a.fp64[2];\n  dst.dword[3] = (u64)a.fp64[3];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrz_lu_d (__m256d a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrz.lu.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> to unsigned 64-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)a.fp64[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (u64)a.fp64[0];\n  dst.dword[1] = (u64)a.fp64[1];\n  dst.dword[2] = (u64)a.fp64[2];\n  dst.dword[3] = (u64)a.fp64[3];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrz_w_d (__m256d a, __m256d b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrz_w_d (__m256d a, __m256d b)\n#include <lasxintrin.h>\nInstruction: xvftintrz.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert double-precision floating point elements in `a` and `b` to 32-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrz_w_d (__m256d a, __m256d b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrz.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert double-precision floating point elements in <code>a</code> and <code>b</code> to 32-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2)\n                    ? (s32)b.fp64[i]\n                    : (s32)a.fp64[i - 2]; // rounding mode is not expressed in C\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6)\n                    ? (s32)b.fp64[i - 2]\n                    : (s32)a.fp64[i - 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)b.fp64[0];\n  dst.word[1] = (s32)b.fp64[1];\n  dst.word[2] = (s32)a.fp64[0];\n  dst.word[3] = (s32)a.fp64[1];\n  dst.word[4] = (s32)b.fp64[2];\n  dst.word[5] = (s32)b.fp64[3];\n  dst.word[6] = (s32)a.fp64[2];\n  dst.word[7] = (s32)a.fp64[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrz_w_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrz_w_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrz.w.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to signed 32-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrz_w_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrz.w.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to signed 32-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (s32)a.fp32[0];\n  dst.word[1] = (s32)a.fp32[1];\n  dst.word[2] = (s32)a.fp32[2];\n  dst.word[3] = (s32)a.fp32[3];\n  dst.word[4] = (s32)a.fp32[4];\n  dst.word[5] = (s32)a.fp32[5];\n  dst.word[6] = (s32)a.fp32[6];\n  dst.word[7] = (s32)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrz_wu_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrz_wu_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrz.wu.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in `a` to unsigned 32-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (u32)a.fp32[0];\n  dst.word[1] = (u32)a.fp32[1];\n  dst.word[2] = (u32)a.fp32[2];\n  dst.word[3] = (u32)a.fp32[3];\n  dst.word[4] = (u32)a.fp32[4];\n  dst.word[5] = (u32)a.fp32[5];\n  dst.word[6] = (u32)a.fp32[6];\n  dst.word[7] = (u32)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 4 |\n| 3C6000 | LA664 | 4 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrz_wu_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrz.wu.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in <code>a</code> to unsigned 32-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)a.fp32[i]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = (u32)a.fp32[0];\n  dst.word[1] = (u32)a.fp32[1];\n  dst.word[2] = (u32)a.fp32[2];\n  dst.word[3] = (u32)a.fp32[3];\n  dst.word[4] = (u32)a.fp32[4];\n  dst.word[5] = (u32)a.fp32[5];\n  dst.word[6] = (u32)a.fp32[6];\n  dst.word[7] = (u32)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrzh_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrzh_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrzh.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in higher part of `a` to 64-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrzh_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrzh.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in higher part of <code>a</code> to 64-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 4]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[2];\n  dst.dword[1] = (s64)a.fp32[3];\n  dst.dword[2] = (s64)a.fp32[6];\n  dst.dword[3] = (s64)a.fp32[7];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvftintrzl_l_s (__m256 a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvftintrzl_l_s (__m256 a)\n#include <lasxintrin.h>\nInstruction: xvftintrzl.l.s xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nConvert single-precision floating point elements in lower part of `a` to 64-bit integer, rounding towards zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n```\n\n\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 5 | 1 |\n| 3A6000 | LA664 | 5 | 2 |\n| 3C6000 | LA664 | 5 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvftintrzl_l_s (__m256 a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvftintrzl.l.s xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Convert single-precision floating point elements in lower part of <code>a</code> to 64-bit integer, rounding towards zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)a.fp32[i]; // rounding mode is not expressed in C\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)a.fp32[i + 2]; // rounding mode is not expressed in C\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = (s64)a.fp32[0];\n  dst.dword[1] = (s64)a.fp32[1];\n  dst.dword[2] = (s64)a.fp32[4];\n  dst.dword[3] = (s64)a.fp32[5];\n}\n</code></pre>\n\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>5</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Floating Point Conversion", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhaddw_d_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhaddw_d_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhaddw.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned signed 32-bit elements in `a` to even-positioned signed 32-bit elements in `b` to get 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) + ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) + ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) + ((s64)((s32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhaddw_d_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhaddw.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 32-bit elements in <code>a</code> to even-positioned signed 32-bit elements in <code>b</code> to get 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] + (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) + ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) + ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) + ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) + ((s64)((s32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhaddw_du_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhaddw_du_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhaddw.du.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 32-bit elements in `a` to even-positioned unsigned 32-bit elements in `b` to get 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) + ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) + ((u64)((u32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhaddw_du_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhaddw.du.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 32-bit elements in <code>a</code> to even-positioned unsigned 32-bit elements in <code>b</code> to get 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] + (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) + ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) + ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) + ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) + ((u64)((u32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhaddw_h_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhaddw_h_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhaddw.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned signed 8-bit elements in `a` to even-positioned signed 8-bit elements in `b` to get 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) + ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) + ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) + ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) + ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) + ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) + ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) + ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) + ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) + ((s16)((s8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhaddw_h_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhaddw.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 8-bit elements in <code>a</code> to even-positioned signed 8-bit elements in <code>b</code> to get 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] + (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) + ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) + ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) + ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) + ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) + ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) + ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) + ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) + ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) + ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) + ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) + ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) + ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) + ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) + ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) + ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) + ((s16)((s8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhaddw_hu_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhaddw_hu_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhaddw.hu.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 8-bit elements in `a` to even-positioned unsigned 8-bit elements in `b` to get 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) + ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) + ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) + ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) + ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) + ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) + ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) + ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) + ((u16)((u8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhaddw_hu_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhaddw.hu.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 8-bit elements in <code>a</code> to even-positioned unsigned 8-bit elements in <code>b</code> to get 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] + (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) + ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) + ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) + ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) + ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) + ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) + ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) + ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) + ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) + ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) + ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) + ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) + ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) + ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) + ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) + ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) + ((u16)((u8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhaddw_q_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhaddw_q_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhaddw.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned signed 64-bit elements in `a` to even-positioned signed 64-bit elements in `b` to get 128-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) + ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) + ((s128)((s64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhaddw_q_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhaddw.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 64-bit elements in <code>a</code> to even-positioned signed 64-bit elements in <code>b</code> to get 128-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] + (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) + ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) + ((s128)((s64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhaddw_qu_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhaddw_qu_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhaddw.qu.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 64-bit elements in `a` to even-positioned unsigned 64-bit elements in `b` to get 128-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) + ((u128)((u64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhaddw_qu_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhaddw.qu.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 64-bit elements in <code>a</code> to even-positioned unsigned 64-bit elements in <code>b</code> to get 128-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] + (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) + ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) + ((u128)((u64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhaddw_w_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhaddw_w_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhaddw.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned signed 16-bit elements in `a` to even-positioned signed 16-bit elements in `b` to get 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[3])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[5])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[7])) + ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[9])) + ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[11])) + ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[13])) + ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[15])) + ((s32)((s16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhaddw_w_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhaddw.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned signed 16-bit elements in <code>a</code> to even-positioned signed 16-bit elements in <code>b</code> to get 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] + (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) + ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[3])) + ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[5])) + ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[7])) + ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[9])) + ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[11])) + ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[13])) + ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[15])) + ((s32)((s16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhaddw_wu_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhaddw_wu_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhaddw.wu.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nAdd odd-positioned unsigned 16-bit elements in `a` to even-positioned unsigned 16-bit elements in `b` to get 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[9])) + ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[11])) + ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[13])) + ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[15])) + ((u32)((u16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhaddw_wu_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhaddw.wu.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Add odd-positioned unsigned 16-bit elements in <code>a</code> to even-positioned unsigned 16-bit elements in <code>b</code> to get 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] + (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) + ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[3])) + ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[5])) + ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[7])) + ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[9])) + ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[11])) + ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[13])) + ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[15])) + ((u32)((u16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhseli_d (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhseli_d (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvhseli.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSelect double words from `a` with indices recorded in `imm` and store into `dst`.\n\n![](../diagram/xvhseli_d.svg)\n\n\n\n### Operation\n\n```c++\ndst.dword[0] = (imm & 1) ? a.dword[1] : a.dword[0];\ndst.dword[1] = (imm & 2) ? a.dword[1] : a.dword[0];\ndst.dword[2] = (imm & 4) ? a.dword[3] : a.dword[2];\ndst.dword[3] = (imm & 8) ? a.dword[3] : a.dword[2];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhseli_d (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhseli.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Select double words from <code>a</code> with indices recorded in <code>imm</code> and store into <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvhseli_d.svg\" /></p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst.dword[0] = (imm &amp; 1) ? a.dword[1] : a.dword[0];\ndst.dword[1] = (imm &amp; 2) ? a.dword[1] : a.dword[0];\ndst.dword[2] = (imm &amp; 4) ? a.dword[3] : a.dword[2];\ndst.dword[3] = (imm &amp; 8) ? a.dword[3] : a.dword[2];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Undocumented Intrinsics", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhsubw_d_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhsubw_d_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhsubw.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned signed 32-bit elements in `a` by even-positioned signed 32-bit elements in `b` to get 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] - (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) - ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) - ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) - ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) - ((s64)((s32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhsubw_d_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhsubw.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 32-bit elements in <code>a</code> by even-positioned signed 32-bit elements in <code>b</code> to get 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] - (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) - ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) - ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) - ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) - ((s64)((s32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhsubw_du_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhsubw_du_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhsubw.du.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 32-bit elements in `a` by even-positioned unsigned 32-bit elements in `b` to get 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] - (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) - ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) - ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) - ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) - ((u64)((u32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhsubw_du_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhsubw.du.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 32-bit elements in <code>a</code> by even-positioned unsigned 32-bit elements in <code>b</code> to get 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] - (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) - ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) - ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) - ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) - ((u64)((u32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhsubw_h_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhsubw_h_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhsubw.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned signed 8-bit elements in `a` by even-positioned signed 8-bit elements in `b` to get 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] - (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) - ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) - ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) - ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) - ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) - ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) - ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) - ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) - ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) - ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) - ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) - ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) - ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) - ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) - ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) - ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) - ((s16)((s8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhsubw_h_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhsubw.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 8-bit elements in <code>a</code> by even-positioned signed 8-bit elements in <code>b</code> to get 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] - (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) - ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) - ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) - ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) - ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) - ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) - ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) - ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) - ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) - ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) - ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) - ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) - ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) - ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) - ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) - ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) - ((s16)((s8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhsubw_hu_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhsubw_hu_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhsubw.hu.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 8-bit elements in `a` by even-positioned unsigned 8-bit elements in `b` to get 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] - (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) - ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) - ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) - ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) - ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) - ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) - ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) - ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) - ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) - ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) - ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) - ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) - ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) - ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) - ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) - ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) - ((u16)((u8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhsubw_hu_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhsubw.hu.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 8-bit elements in <code>a</code> by even-positioned unsigned 8-bit elements in <code>b</code> to get 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] - (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) - ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) - ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) - ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) - ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) - ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) - ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) - ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) - ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) - ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) - ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) - ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) - ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) - ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) - ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) - ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) - ((u16)((u8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhsubw_q_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhsubw_q_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhsubw.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned signed 64-bit elements in `a` by even-positioned signed 64-bit elements in `b` to get 128-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] - (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) - ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) - ((s128)((s64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhsubw_q_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhsubw.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 64-bit elements in <code>a</code> by even-positioned signed 64-bit elements in <code>b</code> to get 128-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] - (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) - ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) - ((s128)((s64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhsubw_qu_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhsubw_qu_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhsubw.qu.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 64-bit elements in `a` by even-positioned unsigned 64-bit elements in `b` to get 128-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] - (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) - ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) - ((u128)((u64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhsubw_qu_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhsubw.qu.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 64-bit elements in <code>a</code> by even-positioned unsigned 64-bit elements in <code>b</code> to get 128-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] - (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) - ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) - ((u128)((u64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhsubw_w_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhsubw_w_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhsubw.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned signed 16-bit elements in `a` by even-positioned signed 16-bit elements in `b` to get 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] - (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) - ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[3])) - ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[5])) - ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[7])) - ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[9])) - ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[11])) - ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[13])) - ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[15])) - ((s32)((s16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhsubw_w_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhsubw.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 16-bit elements in <code>a</code> by even-positioned signed 16-bit elements in <code>b</code> to get 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] - (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) - ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[3])) - ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[5])) - ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[7])) - ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[9])) - ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[11])) - ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[13])) - ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[15])) - ((s32)((s16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvhsubw_wu_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvhsubw_wu_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvhsubw.wu.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 16-bit elements in `a` by even-positioned unsigned 16-bit elements in `b` to get 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] - (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) - ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[3])) - ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[5])) - ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[7])) - ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[9])) - ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[11])) - ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[13])) - ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[15])) - ((u32)((u16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvhsubw_wu_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvhsubw.wu.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 16-bit elements in <code>a</code> by even-positioned unsigned 16-bit elements in <code>b</code> to get 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] - (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) - ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[3])) - ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[5])) - ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[7])) - ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[9])) - ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[11])) - ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[13])) - ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[15])) - ((u32)((u16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvilvh_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvilvh_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvilvh.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nInterleave 8-bit elements in higher half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2 + 8] : b.byte[i / 2 + 8];\n}\nfor (; i < 32; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2 + 16] : b.byte[i / 2 + 16];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[8];\n  dst.byte[1] = a.byte[8];\n  dst.byte[2] = b.byte[9];\n  dst.byte[3] = a.byte[9];\n  dst.byte[4] = b.byte[10];\n  dst.byte[5] = a.byte[10];\n  dst.byte[6] = b.byte[11];\n  dst.byte[7] = a.byte[11];\n  dst.byte[8] = b.byte[12];\n  dst.byte[9] = a.byte[12];\n  dst.byte[10] = b.byte[13];\n  dst.byte[11] = a.byte[13];\n  dst.byte[12] = b.byte[14];\n  dst.byte[13] = a.byte[14];\n  dst.byte[14] = b.byte[15];\n  dst.byte[15] = a.byte[15];\n  dst.byte[16] = b.byte[24];\n  dst.byte[17] = a.byte[24];\n  dst.byte[18] = b.byte[25];\n  dst.byte[19] = a.byte[25];\n  dst.byte[20] = b.byte[26];\n  dst.byte[21] = a.byte[26];\n  dst.byte[22] = b.byte[27];\n  dst.byte[23] = a.byte[27];\n  dst.byte[24] = b.byte[28];\n  dst.byte[25] = a.byte[28];\n  dst.byte[26] = b.byte[29];\n  dst.byte[27] = a.byte[29];\n  dst.byte[28] = b.byte[30];\n  dst.byte[29] = a.byte[30];\n  dst.byte[30] = b.byte[31];\n  dst.byte[31] = a.byte[31];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvilvh_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvilvh.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 8-bit elements in higher half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2 + 8] : b.byte[i / 2 + 8];\n}\nfor (; i &lt; 32; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2 + 16] : b.byte[i / 2 + 16];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[8];\n  dst.byte[1] = a.byte[8];\n  dst.byte[2] = b.byte[9];\n  dst.byte[3] = a.byte[9];\n  dst.byte[4] = b.byte[10];\n  dst.byte[5] = a.byte[10];\n  dst.byte[6] = b.byte[11];\n  dst.byte[7] = a.byte[11];\n  dst.byte[8] = b.byte[12];\n  dst.byte[9] = a.byte[12];\n  dst.byte[10] = b.byte[13];\n  dst.byte[11] = a.byte[13];\n  dst.byte[12] = b.byte[14];\n  dst.byte[13] = a.byte[14];\n  dst.byte[14] = b.byte[15];\n  dst.byte[15] = a.byte[15];\n  dst.byte[16] = b.byte[24];\n  dst.byte[17] = a.byte[24];\n  dst.byte[18] = b.byte[25];\n  dst.byte[19] = a.byte[25];\n  dst.byte[20] = b.byte[26];\n  dst.byte[21] = a.byte[26];\n  dst.byte[22] = b.byte[27];\n  dst.byte[23] = a.byte[27];\n  dst.byte[24] = b.byte[28];\n  dst.byte[25] = a.byte[28];\n  dst.byte[26] = b.byte[29];\n  dst.byte[27] = a.byte[29];\n  dst.byte[28] = b.byte[30];\n  dst.byte[29] = a.byte[30];\n  dst.byte[30] = b.byte[31];\n  dst.byte[31] = a.byte[31];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvilvh_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvilvh_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvilvh.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nInterleave 64-bit elements in higher half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2 + 1] : b.dword[i / 2 + 1];\n}\nfor (; i < 4; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2 + 2] : b.dword[i / 2 + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n  dst.dword[2] = b.dword[3];\n  dst.dword[3] = a.dword[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvilvh_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvilvh.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 64-bit elements in higher half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2 + 1] : b.dword[i / 2 + 1];\n}\nfor (; i &lt; 4; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2 + 2] : b.dword[i / 2 + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n  dst.dword[2] = b.dword[3];\n  dst.dword[3] = a.dword[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvilvh_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvilvh_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvilvh.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nInterleave 16-bit elements in higher half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2 + 4] : b.half[i / 2 + 4];\n}\nfor (; i < 16; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2 + 8] : b.half[i / 2 + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[4];\n  dst.half[1] = a.half[4];\n  dst.half[2] = b.half[5];\n  dst.half[3] = a.half[5];\n  dst.half[4] = b.half[6];\n  dst.half[5] = a.half[6];\n  dst.half[6] = b.half[7];\n  dst.half[7] = a.half[7];\n  dst.half[8] = b.half[12];\n  dst.half[9] = a.half[12];\n  dst.half[10] = b.half[13];\n  dst.half[11] = a.half[13];\n  dst.half[12] = b.half[14];\n  dst.half[13] = a.half[14];\n  dst.half[14] = b.half[15];\n  dst.half[15] = a.half[15];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvilvh_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvilvh.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 16-bit elements in higher half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2 + 4] : b.half[i / 2 + 4];\n}\nfor (; i &lt; 16; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2 + 8] : b.half[i / 2 + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[4];\n  dst.half[1] = a.half[4];\n  dst.half[2] = b.half[5];\n  dst.half[3] = a.half[5];\n  dst.half[4] = b.half[6];\n  dst.half[5] = a.half[6];\n  dst.half[6] = b.half[7];\n  dst.half[7] = a.half[7];\n  dst.half[8] = b.half[12];\n  dst.half[9] = a.half[12];\n  dst.half[10] = b.half[13];\n  dst.half[11] = a.half[13];\n  dst.half[12] = b.half[14];\n  dst.half[13] = a.half[14];\n  dst.half[14] = b.half[15];\n  dst.half[15] = a.half[15];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvilvh_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvilvh_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvilvh.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nInterleave 32-bit elements in higher half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2 + 2] : b.word[i / 2 + 2];\n}\nfor (; i < 8; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2 + 4] : b.word[i / 2 + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[2];\n  dst.word[1] = a.word[2];\n  dst.word[2] = b.word[3];\n  dst.word[3] = a.word[3];\n  dst.word[4] = b.word[6];\n  dst.word[5] = a.word[6];\n  dst.word[6] = b.word[7];\n  dst.word[7] = a.word[7];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvilvh_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvilvh.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 32-bit elements in higher half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2 + 2] : b.word[i / 2 + 2];\n}\nfor (; i &lt; 8; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2 + 4] : b.word[i / 2 + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[2];\n  dst.word[1] = a.word[2];\n  dst.word[2] = b.word[3];\n  dst.word[3] = a.word[3];\n  dst.word[4] = b.word[6];\n  dst.word[5] = a.word[6];\n  dst.word[6] = b.word[7];\n  dst.word[7] = a.word[7];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvilvl_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvilvl_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvilvl.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nInterleave 8-bit elements in lower half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2] : b.byte[i / 2];\n}\nfor (; i < 32; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2 + 8] : b.byte[i / 2 + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = a.byte[0];\n  dst.byte[2] = b.byte[1];\n  dst.byte[3] = a.byte[1];\n  dst.byte[4] = b.byte[2];\n  dst.byte[5] = a.byte[2];\n  dst.byte[6] = b.byte[3];\n  dst.byte[7] = a.byte[3];\n  dst.byte[8] = b.byte[4];\n  dst.byte[9] = a.byte[4];\n  dst.byte[10] = b.byte[5];\n  dst.byte[11] = a.byte[5];\n  dst.byte[12] = b.byte[6];\n  dst.byte[13] = a.byte[6];\n  dst.byte[14] = b.byte[7];\n  dst.byte[15] = a.byte[7];\n  dst.byte[16] = b.byte[16];\n  dst.byte[17] = a.byte[16];\n  dst.byte[18] = b.byte[17];\n  dst.byte[19] = a.byte[17];\n  dst.byte[20] = b.byte[18];\n  dst.byte[21] = a.byte[18];\n  dst.byte[22] = b.byte[19];\n  dst.byte[23] = a.byte[19];\n  dst.byte[24] = b.byte[20];\n  dst.byte[25] = a.byte[20];\n  dst.byte[26] = b.byte[21];\n  dst.byte[27] = a.byte[21];\n  dst.byte[28] = b.byte[22];\n  dst.byte[29] = a.byte[22];\n  dst.byte[30] = b.byte[23];\n  dst.byte[31] = a.byte[23];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvilvl_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvilvl.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 8-bit elements in lower half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2] : b.byte[i / 2];\n}\nfor (; i &lt; 32; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i / 2 + 8] : b.byte[i / 2 + 8];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = a.byte[0];\n  dst.byte[2] = b.byte[1];\n  dst.byte[3] = a.byte[1];\n  dst.byte[4] = b.byte[2];\n  dst.byte[5] = a.byte[2];\n  dst.byte[6] = b.byte[3];\n  dst.byte[7] = a.byte[3];\n  dst.byte[8] = b.byte[4];\n  dst.byte[9] = a.byte[4];\n  dst.byte[10] = b.byte[5];\n  dst.byte[11] = a.byte[5];\n  dst.byte[12] = b.byte[6];\n  dst.byte[13] = a.byte[6];\n  dst.byte[14] = b.byte[7];\n  dst.byte[15] = a.byte[7];\n  dst.byte[16] = b.byte[16];\n  dst.byte[17] = a.byte[16];\n  dst.byte[18] = b.byte[17];\n  dst.byte[19] = a.byte[17];\n  dst.byte[20] = b.byte[18];\n  dst.byte[21] = a.byte[18];\n  dst.byte[22] = b.byte[19];\n  dst.byte[23] = a.byte[19];\n  dst.byte[24] = b.byte[20];\n  dst.byte[25] = a.byte[20];\n  dst.byte[26] = b.byte[21];\n  dst.byte[27] = a.byte[21];\n  dst.byte[28] = b.byte[22];\n  dst.byte[29] = a.byte[22];\n  dst.byte[30] = b.byte[23];\n  dst.byte[31] = a.byte[23];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvilvl_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvilvl_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvilvl.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nInterleave 64-bit elements in lower half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2] : b.dword[i / 2];\n}\nfor (; i < 4; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2 + 1] : b.dword[i / 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n  dst.dword[2] = b.dword[2];\n  dst.dword[3] = a.dword[2];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvilvl_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvilvl.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 64-bit elements in lower half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2] : b.dword[i / 2];\n}\nfor (; i &lt; 4; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i / 2 + 1] : b.dword[i / 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n  dst.dword[2] = b.dword[2];\n  dst.dword[3] = a.dword[2];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvilvl_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvilvl_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvilvl.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nInterleave 16-bit elements in lower half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2] : b.half[i / 2];\n}\nfor (; i < 16; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2 + 4] : b.half[i / 2 + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = a.half[0];\n  dst.half[2] = b.half[1];\n  dst.half[3] = a.half[1];\n  dst.half[4] = b.half[2];\n  dst.half[5] = a.half[2];\n  dst.half[6] = b.half[3];\n  dst.half[7] = a.half[3];\n  dst.half[8] = b.half[8];\n  dst.half[9] = a.half[8];\n  dst.half[10] = b.half[9];\n  dst.half[11] = a.half[9];\n  dst.half[12] = b.half[10];\n  dst.half[13] = a.half[10];\n  dst.half[14] = b.half[11];\n  dst.half[15] = a.half[11];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvilvl_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvilvl.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 16-bit elements in lower half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2] : b.half[i / 2];\n}\nfor (; i &lt; 16; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i / 2 + 4] : b.half[i / 2 + 4];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = a.half[0];\n  dst.half[2] = b.half[1];\n  dst.half[3] = a.half[1];\n  dst.half[4] = b.half[2];\n  dst.half[5] = a.half[2];\n  dst.half[6] = b.half[3];\n  dst.half[7] = a.half[3];\n  dst.half[8] = b.half[8];\n  dst.half[9] = a.half[8];\n  dst.half[10] = b.half[9];\n  dst.half[11] = a.half[9];\n  dst.half[12] = b.half[10];\n  dst.half[13] = a.half[10];\n  dst.half[14] = b.half[11];\n  dst.half[15] = a.half[11];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvilvl_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvilvl_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvilvl.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nInterleave 32-bit elements in lower half of `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nint i;\nfor (i = 0; i < 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2] : b.word[i / 2];\n}\nfor (; i < 8; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2 + 2] : b.word[i / 2 + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = a.word[0];\n  dst.word[2] = b.word[1];\n  dst.word[3] = a.word[1];\n  dst.word[4] = b.word[4];\n  dst.word[5] = a.word[4];\n  dst.word[6] = b.word[5];\n  dst.word[7] = a.word[5];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvilvl_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvilvl.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Interleave 32-bit elements in lower half of <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int i;\nfor (i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2] : b.word[i / 2];\n}\nfor (; i &lt; 8; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i / 2 + 2] : b.word[i / 2 + 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = a.word[0];\n  dst.word[2] = b.word[1];\n  dst.word[3] = a.word[1];\n  dst.word[4] = b.word[4];\n  dst.word[5] = a.word[4];\n  dst.word[6] = b.word[5];\n  dst.word[7] = a.word[5];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvinsgr2vr_d (__m256i a, long int b, imm0_3 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvinsgr2vr_d (__m256i a, long int b, imm0_3 imm)\n#include <lasxintrin.h>\nInstruction: xvinsgr2vr.d xr, r, imm\nCPU Flags: LASX\n```\n\n### Description\n\nInsert 64-bit element into lane indexed `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (i == imm) ? b : a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvinsgr2vr_d (__m256i a, long int b, imm0_3 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvinsgr2vr.d xr, r, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Insert 64-bit element into lane indexed <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (i == imm) ? b : a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvinsgr2vr_w (__m256i a, int b, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvinsgr2vr_w (__m256i a, int b, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvinsgr2vr.w xr, r, imm\nCPU Flags: LASX\n```\n\n### Description\n\nInsert 32-bit element into lane indexed `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (i == imm) ? b : a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvinsgr2vr_w (__m256i a, int b, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvinsgr2vr.w xr, r, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Insert 32-bit element into lane indexed <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (i == imm) ? b : a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvinsve0_d (__m256i a, __m256i b, imm0_3 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvinsve0_d (__m256i a, __m256i b, imm0_3 imm)\n#include <lasxintrin.h>\nInstruction: xvinsve0.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nInsert the first 64-bit lane of `b` into lane indexed `imm` of `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (i == imm) ? b.dword[0] : a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvinsve0_d (__m256i a, __m256i b, imm0_3 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvinsve0.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Insert the first 64-bit lane of <code>b</code> into lane indexed <code>imm</code> of <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (i == imm) ? b.dword[0] : a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvinsve0_w (__m256i a, __m256i b, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvinsve0_w (__m256i a, __m256i b, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvinsve0.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nInsert the first 32-bit lane of `b` into lane indexed `imm` of `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (i == imm) ? b.word[0] : a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvinsve0_w (__m256i a, __m256i b, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvinsve0.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Insert the first 32-bit lane of <code>b</code> into lane indexed <code>imm</code> of <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (i == imm) ? b.word[0] : a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvld (void * addr, imm_n2048_2047 offset)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvld (void * addr, imm_n2048_2047 offset)\n#include <lasxintrin.h>\nInstruction: xvld xr, r, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRead whole vector from memory address `addr + offset`, save the data into `dst`. Note that you can use this intrinsic to load floating point vectors, even though the return type represents integer vectors.\n\n\n\n\n\n### Operation\n\n```c++\ndst = memory_load(256, addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvld (void * addr, imm_n2048_2047 offset)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvld xr, r, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read whole vector from memory address <code>addr + offset</code>, save the data into <code>dst</code>. Note that you can use this intrinsic to load floating point vectors, even though the return type represents integer vectors.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = memory_load(256, addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvldi (imm_n1024_1023 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvldi (imm_n1024_1023 imm)\n#include <lasxintrin.h>\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\n\nInitialize `dst` using predefined patterns:\n\n- `imm[12:10]=0b000`: broadcast `imm[7:0]` as 8-bit elements to all lanes\n- `imm[12:10]=0b001`: broadcast sign-extended `imm[9:0]` as 16-bit elements to all lanes\n- `imm[12:10]=0b010`: broadcast sign-extended `imm[9:0]` as 32-bit elements to all lanes\n- `imm[12:10]=0b011`: broadcast sign-extended `imm[9:0]` as 64-bit elements to all lanes\n- `imm[12:8]=0b10000`: broadcast `imm[7:0]` as 32-bit elements to all lanes\n- `imm[12:8]=0b10001`: broadcast `imm[7:0] << 8` as 32-bit elements to all lanes\n- `imm[12:8]=0b10010`: broadcast `imm[7:0] << 16` as 32-bit elements to all lanes\n- `imm[12:8]=0b10011`: broadcast `imm[7:0] << 24` as 32-bit elements to all lanes\n- `imm[12:8]=0b10100`: broadcast `imm[7:0]` as 16-bit elements to all lanes\n- `imm[12:8]=0b10101`: broadcast `imm[7:0] << 8` as 16-bit elements to all lanes\n- `imm[12:8]=0b10110`: broadcast `(imm[7:0] << 8) | 0xFF` as 32-bit elements to all lanes\n- `imm[12:8]=0b10111`: broadcast `(imm[7:0] << 16) | 0xFFFF` as 32-bit elements to all lanes\n- `imm[12:8]=0b11000`: broadcast `imm[7:0]` as 8-bit elements to all lanes\n- `imm[12:8]=0b11001`: repeat each bit of `imm[7:0]` eight times, and broadcast the result as 64-bit elements to all lanes\n- `imm[12:8]=0b11010`: broadcast `(imm[7] << 31) | ((1-imm[6]) << 30) | ((imm[6] * 0x1F) << 25) | (imm[5:0] << 19)` as 32-bit elements to all lanes\n- `imm[12:8]=0b11011`: broadcast `(imm[7] << 31) | ((1-imm[6]) << 30) | ((imm[6] * 0x1F) << 25) | (imm[5:0] << 19)` as 64-bit elements to all lanes\n- `imm[12:8]=0b11100`: broadcast `(imm[7] << 63) | ((1-imm[6]) << 62) | ((imm[6] * 0xFF) << 54) | (imm[5:0] << 48)` as 64-bit elements to all lanes\n\n\n\n\n\n\n### Operation\n\n```c++\nu64 imm12_10 = (imm >> 10) & 0b111;\nu64 imm12_8 = (imm >> 8) & 0b11111;\nu64 imm9_0 = imm & 0x3FF;\ns64 simm9_0 = ((s64)imm9_0 << 54) >> 54;\nu64 imm7_0 = imm & 0xFF;\nu64 imm7 = (imm >> 7) & 0x1;\nu64 imm6 = (imm >> 6) & 0x1;\nu64 imm5 = (imm >> 5) & 0x1;\nu64 imm5_0 = imm & 0x3F;\nu64 imm4 = (imm >> 4) & 0x1;\nu64 imm3 = (imm >> 3) & 0x1;\nu64 imm2 = (imm >> 2) & 0x1;\nu64 imm1 = (imm >> 1) & 0x1;\nu64 imm0 = imm & 0x1;\n\nu64 broadcast_value;\nu64 broadcast_width;\nif (imm12_10 == 0b000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 8;\n} else if (imm12_10 == 0b001) {\n  broadcast_value = simm9_0;\n  broadcast_width = 16;\n} else if (imm12_10 == 0b010) {\n  broadcast_value = simm9_0;\n  broadcast_width = 32;\n} else if (imm12_10 == 0b011) {\n  broadcast_value = simm9_0;\n  broadcast_width = 64;\n} else if (imm12_8 == 0b10000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10001) {\n  broadcast_value = imm7_0 << 8;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10010) {\n  broadcast_value = imm7_0 << 16;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10011) {\n  broadcast_value = imm7_0 << 24;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10100) {\n  broadcast_value = imm7_0;\n  broadcast_width = 16;\n} else if (imm12_8 == 0b10101) {\n  broadcast_value = imm7_0 << 8;\n  broadcast_width = 16;\n} else if (imm12_8 == 0b10110) {\n  broadcast_value = (imm7_0 << 8) | 0xFF;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10111) {\n  broadcast_value = (imm7_0 << 16) | 0xFFFF;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b11000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 8;\n} else if (imm12_8 == 0b11001) {\n  broadcast_value = imm0 * 0xFF + imm1 * 0xFF00 + imm2 * 0xFF0000 +\n                    imm3 * 0xFF000000 + imm4 * 0xFF00000000 +\n                    imm5 * 0xFF0000000000 + imm6 * 0xFF000000000000 +\n                    imm7 * 0xFF00000000000000;\n  broadcast_width = 64;\n} else if (imm12_8 == 0b11010) {\n  broadcast_value = (imm7 << 31) | ((1 - imm6) << 30) | ((imm6 * 0x1F) << 25) |\n                    (imm5_0 << 19);\n  broadcast_width = 32;\n} else if (imm12_8 == 0b11011) {\n  broadcast_value = (imm7 << 31) | ((1 - imm6) << 30) | ((imm6 * 0x1F) << 25) |\n                    (imm5_0 << 19);\n  broadcast_width = 64;\n} else if (imm12_8 == 0b11100) {\n  broadcast_value = (imm7 << 63) | ((1 - imm6) << 62) | ((imm6 * 0xFF) << 54) |\n                    (imm5_0 << 48);\n  broadcast_width = 64;\n}\n\nif (broadcast_width == 8) {\n  for (int i = 0; i < 32; i++) {\n    dst.byte[i] = broadcast_value;\n  }\n} else if (broadcast_width == 16) {\n  for (int i = 0; i < 16; i++) {\n    dst.half[i] = broadcast_value;\n  }\n} else if (broadcast_width == 32) {\n  for (int i = 0; i < 8; i++) {\n    dst.word[i] = broadcast_value;\n  }\n} else if (broadcast_width == 64) {\n  for (int i = 0; i < 4; i++) {\n    dst.dword[i] = broadcast_value;\n  }\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvldi (imm_n1024_1023 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Initialize <code>dst</code> using predefined patterns:</p>\n<ul>\n<li><code>imm[12:10]=0b000</code>: broadcast <code>imm[7:0]</code> as 8-bit elements to all lanes</li>\n<li><code>imm[12:10]=0b001</code>: broadcast sign-extended <code>imm[9:0]</code> as 16-bit elements to all lanes</li>\n<li><code>imm[12:10]=0b010</code>: broadcast sign-extended <code>imm[9:0]</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:10]=0b011</code>: broadcast sign-extended <code>imm[9:0]</code> as 64-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10000</code>: broadcast <code>imm[7:0]</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10001</code>: broadcast <code>imm[7:0] &lt;&lt; 8</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10010</code>: broadcast <code>imm[7:0] &lt;&lt; 16</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10011</code>: broadcast <code>imm[7:0] &lt;&lt; 24</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10100</code>: broadcast <code>imm[7:0]</code> as 16-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10101</code>: broadcast <code>imm[7:0] &lt;&lt; 8</code> as 16-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10110</code>: broadcast <code>(imm[7:0] &lt;&lt; 8) | 0xFF</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b10111</code>: broadcast <code>(imm[7:0] &lt;&lt; 16) | 0xFFFF</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11000</code>: broadcast <code>imm[7:0]</code> as 8-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11001</code>: repeat each bit of <code>imm[7:0]</code> eight times, and broadcast the result as 64-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11010</code>: broadcast <code>(imm[7] &lt;&lt; 31) | ((1-imm[6]) &lt;&lt; 30) | ((imm[6] * 0x1F) &lt;&lt; 25) | (imm[5:0] &lt;&lt; 19)</code> as 32-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11011</code>: broadcast <code>(imm[7] &lt;&lt; 31) | ((1-imm[6]) &lt;&lt; 30) | ((imm[6] * 0x1F) &lt;&lt; 25) | (imm[5:0] &lt;&lt; 19)</code> as 64-bit elements to all lanes</li>\n<li><code>imm[12:8]=0b11100</code>: broadcast <code>(imm[7] &lt;&lt; 63) | ((1-imm[6]) &lt;&lt; 62) | ((imm[6] * 0xFF) &lt;&lt; 54) | (imm[5:0] &lt;&lt; 48)</code> as 64-bit elements to all lanes</li>\n</ul>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 imm12_10 = (imm &gt;&gt; 10) &amp; 0b111;\nu64 imm12_8 = (imm &gt;&gt; 8) &amp; 0b11111;\nu64 imm9_0 = imm &amp; 0x3FF;\ns64 simm9_0 = ((s64)imm9_0 &lt;&lt; 54) &gt;&gt; 54;\nu64 imm7_0 = imm &amp; 0xFF;\nu64 imm7 = (imm &gt;&gt; 7) &amp; 0x1;\nu64 imm6 = (imm &gt;&gt; 6) &amp; 0x1;\nu64 imm5 = (imm &gt;&gt; 5) &amp; 0x1;\nu64 imm5_0 = imm &amp; 0x3F;\nu64 imm4 = (imm &gt;&gt; 4) &amp; 0x1;\nu64 imm3 = (imm &gt;&gt; 3) &amp; 0x1;\nu64 imm2 = (imm &gt;&gt; 2) &amp; 0x1;\nu64 imm1 = (imm &gt;&gt; 1) &amp; 0x1;\nu64 imm0 = imm &amp; 0x1;\n\nu64 broadcast_value;\nu64 broadcast_width;\nif (imm12_10 == 0b000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 8;\n} else if (imm12_10 == 0b001) {\n  broadcast_value = simm9_0;\n  broadcast_width = 16;\n} else if (imm12_10 == 0b010) {\n  broadcast_value = simm9_0;\n  broadcast_width = 32;\n} else if (imm12_10 == 0b011) {\n  broadcast_value = simm9_0;\n  broadcast_width = 64;\n} else if (imm12_8 == 0b10000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10001) {\n  broadcast_value = imm7_0 &lt;&lt; 8;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10010) {\n  broadcast_value = imm7_0 &lt;&lt; 16;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10011) {\n  broadcast_value = imm7_0 &lt;&lt; 24;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10100) {\n  broadcast_value = imm7_0;\n  broadcast_width = 16;\n} else if (imm12_8 == 0b10101) {\n  broadcast_value = imm7_0 &lt;&lt; 8;\n  broadcast_width = 16;\n} else if (imm12_8 == 0b10110) {\n  broadcast_value = (imm7_0 &lt;&lt; 8) | 0xFF;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b10111) {\n  broadcast_value = (imm7_0 &lt;&lt; 16) | 0xFFFF;\n  broadcast_width = 32;\n} else if (imm12_8 == 0b11000) {\n  broadcast_value = imm7_0;\n  broadcast_width = 8;\n} else if (imm12_8 == 0b11001) {\n  broadcast_value = imm0 * 0xFF + imm1 * 0xFF00 + imm2 * 0xFF0000 +\n                    imm3 * 0xFF000000 + imm4 * 0xFF00000000 +\n                    imm5 * 0xFF0000000000 + imm6 * 0xFF000000000000 +\n                    imm7 * 0xFF00000000000000;\n  broadcast_width = 64;\n} else if (imm12_8 == 0b11010) {\n  broadcast_value = (imm7 &lt;&lt; 31) | ((1 - imm6) &lt;&lt; 30) | ((imm6 * 0x1F) &lt;&lt; 25) |\n                    (imm5_0 &lt;&lt; 19);\n  broadcast_width = 32;\n} else if (imm12_8 == 0b11011) {\n  broadcast_value = (imm7 &lt;&lt; 31) | ((1 - imm6) &lt;&lt; 30) | ((imm6 * 0x1F) &lt;&lt; 25) |\n                    (imm5_0 &lt;&lt; 19);\n  broadcast_width = 64;\n} else if (imm12_8 == 0b11100) {\n  broadcast_value = (imm7 &lt;&lt; 63) | ((1 - imm6) &lt;&lt; 62) | ((imm6 * 0xFF) &lt;&lt; 54) |\n                    (imm5_0 &lt;&lt; 48);\n  broadcast_width = 64;\n}\n\nif (broadcast_width == 8) {\n  for (int i = 0; i &lt; 32; i++) {\n    dst.byte[i] = broadcast_value;\n  }\n} else if (broadcast_width == 16) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.half[i] = broadcast_value;\n  }\n} else if (broadcast_width == 32) {\n  for (int i = 0; i &lt; 8; i++) {\n    dst.word[i] = broadcast_value;\n  }\n} else if (broadcast_width == 64) {\n  for (int i = 0; i &lt; 4; i++) {\n    dst.dword[i] = broadcast_value;\n  }\n}\n</code></pre>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvldrepl_b (void * addr, imm_n2048_2047 offset)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvldrepl_b (void * addr, imm_n2048_2047 offset)\n#include <lasxintrin.h>\nInstruction: xvldrepl.b xr, r, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRead 8-bit data from memory address `addr + (offset << 0)`, replicate the data to all vector lanes and save into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nu8 data = memory_load(8, addr + offset);\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = data;\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvldrepl_b (void * addr, imm_n2048_2047 offset)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldrepl.b xr, r, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read 8-bit data from memory address <code>addr + (offset &lt;&lt; 0)</code>, replicate the data to all vector lanes and save into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u8 data = memory_load(8, addr + offset);\nfor (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = data;\n}\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvldrepl_d (void * addr, imm_n256_255 offset)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvldrepl_d (void * addr, imm_n256_255 offset)\n#include <lasxintrin.h>\nInstruction: xvldrepl.d xr, r, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRead 64-bit data from memory address `addr + (offset << 3)`, replicate the data to all vector lanes and save into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nu64 data = memory_load(64, addr + (offset << 3));\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = data;\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvldrepl_d (void * addr, imm_n256_255 offset)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldrepl.d xr, r, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read 64-bit data from memory address <code>addr + (offset &lt;&lt; 3)</code>, replicate the data to all vector lanes and save into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 data = memory_load(64, addr + (offset &lt;&lt; 3));\nfor (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = data;\n}\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvldrepl_h (void * addr, imm_n1024_1023 offset)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvldrepl_h (void * addr, imm_n1024_1023 offset)\n#include <lasxintrin.h>\nInstruction: xvldrepl.h xr, r, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRead 16-bit data from memory address `addr + (offset << 1)`, replicate the data to all vector lanes and save into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nu16 data = memory_load(16, addr + (offset << 1));\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = data;\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvldrepl_h (void * addr, imm_n1024_1023 offset)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldrepl.h xr, r, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read 16-bit data from memory address <code>addr + (offset &lt;&lt; 1)</code>, replicate the data to all vector lanes and save into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u16 data = memory_load(16, addr + (offset &lt;&lt; 1));\nfor (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = data;\n}\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvldrepl_w (void * addr, imm_n512_511 offset)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvldrepl_w (void * addr, imm_n512_511 offset)\n#include <lasxintrin.h>\nInstruction: xvldrepl.w xr, r, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRead 32-bit data from memory address `addr + (offset << 2)`, replicate the data to all vector lanes and save into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nu32 data = memory_load(32, addr + (offset << 2));\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = data;\n}\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvldrepl_w (void * addr, imm_n512_511 offset)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldrepl.w xr, r, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read 32-bit data from memory address <code>addr + (offset &lt;&lt; 2)</code>, replicate the data to all vector lanes and save into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u32 data = memory_load(32, addr + (offset &lt;&lt; 2));\nfor (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = data;\n}\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvldx (void * addr, long int offset)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvldx (void * addr, long int offset)\n#include <lasxintrin.h>\nInstruction: xvldx xr, r, r\nCPU Flags: LASX\n```\n\n### Description\n\nRead whole vector from memory address `addr + offset`, save the data into `dst`.  Note that you can use this intrinsic to load floating point vectors, even though the return type represents integer vectors.\n\n\n\n\n\n### Operation\n\n```c++\ndst = memory_load(256, addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvldx (void * addr, long int offset)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldx xr, r, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Read whole vector from memory address <code>addr + offset</code>, save the data into <code>dst</code>.  Note that you can use this intrinsic to load floating point vectors, even though the return type represents integer vectors.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = memory_load(256, addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmadd_b (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmadd_b (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmadd.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 8-bit elements in `b` and `c`, add to elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = b.byte[i] * c.byte[i] + a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmadd_b (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmadd.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 8-bit elements in <code>b</code> and <code>c</code>, add to elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = b.byte[i] * c.byte[i] + a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmadd_d (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmadd_d (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmadd.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 64-bit elements in `b` and `c`, add to elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = b.dword[i] * c.dword[i] + a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmadd_d (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmadd.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 64-bit elements in <code>b</code> and <code>c</code>, add to elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = b.dword[i] * c.dword[i] + a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmadd_h (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmadd_h (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmadd.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 16-bit elements in `b` and `c`, add to elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = b.half[i] * c.half[i] + a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmadd_h (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmadd.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 16-bit elements in <code>b</code> and <code>c</code>, add to elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = b.half[i] * c.half[i] + a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmadd_w (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmadd_w (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmadd.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 32-bit elements in `b` and `c`, add to elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = b.word[i] * c.word[i] + a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmadd_w (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmadd.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 32-bit elements in <code>b</code> and <code>c</code>, add to elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = b.word[i] * c.word[i] + a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_d_w (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_d_w (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned signed 32-bit elements in `b` and signed elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] =\n      (s64)(s32)b.word[2 * i] * (s64)(s32)c.word[2 * i] + (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((s64)((s32)b.word[0])) * ((s64)((s32)c.word[0]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((s64)((s32)b.word[2])) * ((s64)((s32)c.word[2]))) + ((s64)a.dword[1]);\n  dst.dword[2] =\n      (((s64)((s32)b.word[4])) * ((s64)((s32)c.word[4]))) + ((s64)a.dword[2]);\n  dst.dword[3] =\n      (((s64)((s32)b.word[6])) * ((s64)((s32)c.word[6]))) + ((s64)a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_d_w (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 32-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] =\n      (s64)(s32)b.word[2 * i] * (s64)(s32)c.word[2 * i] + (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((s64)((s32)b.word[0])) * ((s64)((s32)c.word[0]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((s64)((s32)b.word[2])) * ((s64)((s32)c.word[2]))) + ((s64)a.dword[1]);\n  dst.dword[2] =\n      (((s64)((s32)b.word[4])) * ((s64)((s32)c.word[4]))) + ((s64)a.dword[2]);\n  dst.dword[3] =\n      (((s64)((s32)b.word[6])) * ((s64)((s32)c.word[6]))) + ((s64)a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_d_wu (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_d_wu (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.d.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 32-bit elements in `b` and unsigned elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] =\n      (u64)(u32)b.word[2 * i] * (u64)(u32)c.word[2 * i] + (u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[0])) * ((u64)((u32)c.word[0]))) + ((u64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[2])) * ((u64)((u32)c.word[2]))) + ((u64)a.dword[1]);\n  dst.dword[2] =\n      (((u64)((u32)b.word[4])) * ((u64)((u32)c.word[4]))) + ((u64)a.dword[2]);\n  dst.dword[3] =\n      (((u64)((u32)b.word[6])) * ((u64)((u32)c.word[6]))) + ((u64)a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_d_wu (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.d.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 32-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] =\n      (u64)(u32)b.word[2 * i] * (u64)(u32)c.word[2 * i] + (u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[0])) * ((u64)((u32)c.word[0]))) + ((u64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[2])) * ((u64)((u32)c.word[2]))) + ((u64)a.dword[1]);\n  dst.dword[2] =\n      (((u64)((u32)b.word[4])) * ((u64)((u32)c.word[4]))) + ((u64)a.dword[2]);\n  dst.dword[3] =\n      (((u64)((u32)b.word[6])) * ((u64)((u32)c.word[6]))) + ((u64)a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_d_wu_w (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_d_wu_w (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.d.wu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 32-bit elements in `b` and signed elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] =\n      (u64)(u32)b.word[2 * i] * (s64)(s32)c.word[2 * i] + (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[0])) * ((s64)((s32)c.word[0]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[2])) * ((s64)((s32)c.word[2]))) + ((s64)a.dword[1]);\n  dst.dword[2] =\n      (((u64)((u32)b.word[4])) * ((s64)((s32)c.word[4]))) + ((s64)a.dword[2]);\n  dst.dword[3] =\n      (((u64)((u32)b.word[6])) * ((s64)((s32)c.word[6]))) + ((s64)a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_d_wu_w (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.d.wu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 32-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] =\n      (u64)(u32)b.word[2 * i] * (s64)(s32)c.word[2 * i] + (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[0])) * ((s64)((s32)c.word[0]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[2])) * ((s64)((s32)c.word[2]))) + ((s64)a.dword[1]);\n  dst.dword[2] =\n      (((u64)((u32)b.word[4])) * ((s64)((s32)c.word[4]))) + ((s64)a.dword[2]);\n  dst.dword[3] =\n      (((u64)((u32)b.word[6])) * ((s64)((s32)c.word[6]))) + ((s64)a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_h_b (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_h_b (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned signed 8-bit elements in `b` and signed elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] =\n      (s16)(s8)b.byte[2 * i] * (s16)(s8)c.byte[2 * i] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((s16)((s8)b.byte[0])) * ((s16)((s8)c.byte[0]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((s16)((s8)b.byte[2])) * ((s16)((s8)c.byte[2]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((s16)((s8)b.byte[4])) * ((s16)((s8)c.byte[4]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((s16)((s8)b.byte[6])) * ((s16)((s8)c.byte[6]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((s16)((s8)b.byte[8])) * ((s16)((s8)c.byte[8]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((s16)((s8)b.byte[10])) * ((s16)((s8)c.byte[10]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((s16)((s8)b.byte[12])) * ((s16)((s8)c.byte[12]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((s16)((s8)b.byte[14])) * ((s16)((s8)c.byte[14]))) + ((s16)a.half[7]);\n  dst.half[8] =\n      (((s16)((s8)b.byte[16])) * ((s16)((s8)c.byte[16]))) + ((s16)a.half[8]);\n  dst.half[9] =\n      (((s16)((s8)b.byte[18])) * ((s16)((s8)c.byte[18]))) + ((s16)a.half[9]);\n  dst.half[10] =\n      (((s16)((s8)b.byte[20])) * ((s16)((s8)c.byte[20]))) + ((s16)a.half[10]);\n  dst.half[11] =\n      (((s16)((s8)b.byte[22])) * ((s16)((s8)c.byte[22]))) + ((s16)a.half[11]);\n  dst.half[12] =\n      (((s16)((s8)b.byte[24])) * ((s16)((s8)c.byte[24]))) + ((s16)a.half[12]);\n  dst.half[13] =\n      (((s16)((s8)b.byte[26])) * ((s16)((s8)c.byte[26]))) + ((s16)a.half[13]);\n  dst.half[14] =\n      (((s16)((s8)b.byte[28])) * ((s16)((s8)c.byte[28]))) + ((s16)a.half[14]);\n  dst.half[15] =\n      (((s16)((s8)b.byte[30])) * ((s16)((s8)c.byte[30]))) + ((s16)a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_h_b (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 8-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] =\n      (s16)(s8)b.byte[2 * i] * (s16)(s8)c.byte[2 * i] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((s16)((s8)b.byte[0])) * ((s16)((s8)c.byte[0]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((s16)((s8)b.byte[2])) * ((s16)((s8)c.byte[2]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((s16)((s8)b.byte[4])) * ((s16)((s8)c.byte[4]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((s16)((s8)b.byte[6])) * ((s16)((s8)c.byte[6]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((s16)((s8)b.byte[8])) * ((s16)((s8)c.byte[8]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((s16)((s8)b.byte[10])) * ((s16)((s8)c.byte[10]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((s16)((s8)b.byte[12])) * ((s16)((s8)c.byte[12]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((s16)((s8)b.byte[14])) * ((s16)((s8)c.byte[14]))) + ((s16)a.half[7]);\n  dst.half[8] =\n      (((s16)((s8)b.byte[16])) * ((s16)((s8)c.byte[16]))) + ((s16)a.half[8]);\n  dst.half[9] =\n      (((s16)((s8)b.byte[18])) * ((s16)((s8)c.byte[18]))) + ((s16)a.half[9]);\n  dst.half[10] =\n      (((s16)((s8)b.byte[20])) * ((s16)((s8)c.byte[20]))) + ((s16)a.half[10]);\n  dst.half[11] =\n      (((s16)((s8)b.byte[22])) * ((s16)((s8)c.byte[22]))) + ((s16)a.half[11]);\n  dst.half[12] =\n      (((s16)((s8)b.byte[24])) * ((s16)((s8)c.byte[24]))) + ((s16)a.half[12]);\n  dst.half[13] =\n      (((s16)((s8)b.byte[26])) * ((s16)((s8)c.byte[26]))) + ((s16)a.half[13]);\n  dst.half[14] =\n      (((s16)((s8)b.byte[28])) * ((s16)((s8)c.byte[28]))) + ((s16)a.half[14]);\n  dst.half[15] =\n      (((s16)((s8)b.byte[30])) * ((s16)((s8)c.byte[30]))) + ((s16)a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_h_bu (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_h_bu (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.h.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 8-bit elements in `b` and unsigned elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i] * (u16)(u8)c.byte[2 * i] + (u16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[0])) * ((u16)((u8)c.byte[0]))) + ((u16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[2])) * ((u16)((u8)c.byte[2]))) + ((u16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[4])) * ((u16)((u8)c.byte[4]))) + ((u16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[6])) * ((u16)((u8)c.byte[6]))) + ((u16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[8])) * ((u16)((u8)c.byte[8]))) + ((u16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[10])) * ((u16)((u8)c.byte[10]))) + ((u16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[12])) * ((u16)((u8)c.byte[12]))) + ((u16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[14])) * ((u16)((u8)c.byte[14]))) + ((u16)a.half[7]);\n  dst.half[8] =\n      (((u16)((u8)b.byte[16])) * ((u16)((u8)c.byte[16]))) + ((u16)a.half[8]);\n  dst.half[9] =\n      (((u16)((u8)b.byte[18])) * ((u16)((u8)c.byte[18]))) + ((u16)a.half[9]);\n  dst.half[10] =\n      (((u16)((u8)b.byte[20])) * ((u16)((u8)c.byte[20]))) + ((u16)a.half[10]);\n  dst.half[11] =\n      (((u16)((u8)b.byte[22])) * ((u16)((u8)c.byte[22]))) + ((u16)a.half[11]);\n  dst.half[12] =\n      (((u16)((u8)b.byte[24])) * ((u16)((u8)c.byte[24]))) + ((u16)a.half[12]);\n  dst.half[13] =\n      (((u16)((u8)b.byte[26])) * ((u16)((u8)c.byte[26]))) + ((u16)a.half[13]);\n  dst.half[14] =\n      (((u16)((u8)b.byte[28])) * ((u16)((u8)c.byte[28]))) + ((u16)a.half[14]);\n  dst.half[15] =\n      (((u16)((u8)b.byte[30])) * ((u16)((u8)c.byte[30]))) + ((u16)a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_h_bu (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.h.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 8-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i] * (u16)(u8)c.byte[2 * i] + (u16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[0])) * ((u16)((u8)c.byte[0]))) + ((u16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[2])) * ((u16)((u8)c.byte[2]))) + ((u16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[4])) * ((u16)((u8)c.byte[4]))) + ((u16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[6])) * ((u16)((u8)c.byte[6]))) + ((u16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[8])) * ((u16)((u8)c.byte[8]))) + ((u16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[10])) * ((u16)((u8)c.byte[10]))) + ((u16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[12])) * ((u16)((u8)c.byte[12]))) + ((u16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[14])) * ((u16)((u8)c.byte[14]))) + ((u16)a.half[7]);\n  dst.half[8] =\n      (((u16)((u8)b.byte[16])) * ((u16)((u8)c.byte[16]))) + ((u16)a.half[8]);\n  dst.half[9] =\n      (((u16)((u8)b.byte[18])) * ((u16)((u8)c.byte[18]))) + ((u16)a.half[9]);\n  dst.half[10] =\n      (((u16)((u8)b.byte[20])) * ((u16)((u8)c.byte[20]))) + ((u16)a.half[10]);\n  dst.half[11] =\n      (((u16)((u8)b.byte[22])) * ((u16)((u8)c.byte[22]))) + ((u16)a.half[11]);\n  dst.half[12] =\n      (((u16)((u8)b.byte[24])) * ((u16)((u8)c.byte[24]))) + ((u16)a.half[12]);\n  dst.half[13] =\n      (((u16)((u8)b.byte[26])) * ((u16)((u8)c.byte[26]))) + ((u16)a.half[13]);\n  dst.half[14] =\n      (((u16)((u8)b.byte[28])) * ((u16)((u8)c.byte[28]))) + ((u16)a.half[14]);\n  dst.half[15] =\n      (((u16)((u8)b.byte[30])) * ((u16)((u8)c.byte[30]))) + ((u16)a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_h_bu_b (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_h_bu_b (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.h.bu.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 8-bit elements in `b` and signed elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i] * (s16)(s8)c.byte[2 * i] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[0])) * ((s16)((s8)c.byte[0]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[2])) * ((s16)((s8)c.byte[2]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[4])) * ((s16)((s8)c.byte[4]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[6])) * ((s16)((s8)c.byte[6]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[8])) * ((s16)((s8)c.byte[8]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[10])) * ((s16)((s8)c.byte[10]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[12])) * ((s16)((s8)c.byte[12]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[14])) * ((s16)((s8)c.byte[14]))) + ((s16)a.half[7]);\n  dst.half[8] =\n      (((u16)((u8)b.byte[16])) * ((s16)((s8)c.byte[16]))) + ((s16)a.half[8]);\n  dst.half[9] =\n      (((u16)((u8)b.byte[18])) * ((s16)((s8)c.byte[18]))) + ((s16)a.half[9]);\n  dst.half[10] =\n      (((u16)((u8)b.byte[20])) * ((s16)((s8)c.byte[20]))) + ((s16)a.half[10]);\n  dst.half[11] =\n      (((u16)((u8)b.byte[22])) * ((s16)((s8)c.byte[22]))) + ((s16)a.half[11]);\n  dst.half[12] =\n      (((u16)((u8)b.byte[24])) * ((s16)((s8)c.byte[24]))) + ((s16)a.half[12]);\n  dst.half[13] =\n      (((u16)((u8)b.byte[26])) * ((s16)((s8)c.byte[26]))) + ((s16)a.half[13]);\n  dst.half[14] =\n      (((u16)((u8)b.byte[28])) * ((s16)((s8)c.byte[28]))) + ((s16)a.half[14]);\n  dst.half[15] =\n      (((u16)((u8)b.byte[30])) * ((s16)((s8)c.byte[30]))) + ((s16)a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_h_bu_b (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.h.bu.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 8-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i] * (s16)(s8)c.byte[2 * i] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[0])) * ((s16)((s8)c.byte[0]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[2])) * ((s16)((s8)c.byte[2]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[4])) * ((s16)((s8)c.byte[4]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[6])) * ((s16)((s8)c.byte[6]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[8])) * ((s16)((s8)c.byte[8]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[10])) * ((s16)((s8)c.byte[10]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[12])) * ((s16)((s8)c.byte[12]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[14])) * ((s16)((s8)c.byte[14]))) + ((s16)a.half[7]);\n  dst.half[8] =\n      (((u16)((u8)b.byte[16])) * ((s16)((s8)c.byte[16]))) + ((s16)a.half[8]);\n  dst.half[9] =\n      (((u16)((u8)b.byte[18])) * ((s16)((s8)c.byte[18]))) + ((s16)a.half[9]);\n  dst.half[10] =\n      (((u16)((u8)b.byte[20])) * ((s16)((s8)c.byte[20]))) + ((s16)a.half[10]);\n  dst.half[11] =\n      (((u16)((u8)b.byte[22])) * ((s16)((s8)c.byte[22]))) + ((s16)a.half[11]);\n  dst.half[12] =\n      (((u16)((u8)b.byte[24])) * ((s16)((s8)c.byte[24]))) + ((s16)a.half[12]);\n  dst.half[13] =\n      (((u16)((u8)b.byte[26])) * ((s16)((s8)c.byte[26]))) + ((s16)a.half[13]);\n  dst.half[14] =\n      (((u16)((u8)b.byte[28])) * ((s16)((s8)c.byte[28]))) + ((s16)a.half[14]);\n  dst.half[15] =\n      (((u16)((u8)b.byte[30])) * ((s16)((s8)c.byte[30]))) + ((s16)a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_q_d (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_q_d (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned signed 64-bit elements in `b` and signed elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] =\n      (s128)(s64)b.dword[2 * i] * (s128)(s64)c.dword[2 * i] + (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((s128)((s64)b.dword[0])) * ((s128)((s64)c.dword[0]))) +\n                 ((s128)a.qword[0]);\n  dst.qword[1] = (((s128)((s64)b.dword[2])) * ((s128)((s64)c.dword[2]))) +\n                 ((s128)a.qword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_q_d (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 64-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] =\n      (s128)(s64)b.dword[2 * i] * (s128)(s64)c.dword[2 * i] + (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((s128)((s64)b.dword[0])) * ((s128)((s64)c.dword[0]))) +\n                 ((s128)a.qword[0]);\n  dst.qword[1] = (((s128)((s64)b.dword[2])) * ((s128)((s64)c.dword[2]))) +\n                 ((s128)a.qword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_q_du (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_q_du (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.q.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 64-bit elements in `b` and unsigned elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] =\n      (u128)(u64)b.dword[2 * i] * (u128)(u64)c.dword[2 * i] + (u128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[0])) * ((u128)((u64)c.dword[0]))) +\n                 ((u128)a.qword[0]);\n  dst.qword[1] = (((u128)((u64)b.dword[2])) * ((u128)((u64)c.dword[2]))) +\n                 ((u128)a.qword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_q_du (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.q.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 64-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] =\n      (u128)(u64)b.dword[2 * i] * (u128)(u64)c.dword[2 * i] + (u128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[0])) * ((u128)((u64)c.dword[0]))) +\n                 ((u128)a.qword[0]);\n  dst.qword[1] = (((u128)((u64)b.dword[2])) * ((u128)((u64)c.dword[2]))) +\n                 ((u128)a.qword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_q_du_d (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_q_du_d (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.q.du.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 64-bit elements in `b` and signed elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] =\n      (u128)(u64)b.dword[2 * i] * (s128)(s64)c.dword[2 * i] + (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[0])) * ((s128)((s64)c.dword[0]))) +\n                 ((s128)a.qword[0]);\n  dst.qword[1] = (((u128)((u64)b.dword[2])) * ((s128)((s64)c.dword[2]))) +\n                 ((s128)a.qword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_q_du_d (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.q.du.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 64-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] =\n      (u128)(u64)b.dword[2 * i] * (s128)(s64)c.dword[2 * i] + (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[0])) * ((s128)((s64)c.dword[0]))) +\n                 ((s128)a.qword[0]);\n  dst.qword[1] = (((u128)((u64)b.dword[2])) * ((s128)((s64)c.dword[2]))) +\n                 ((s128)a.qword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_w_h (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_w_h (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned signed 16-bit elements in `b` and signed elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] =\n      (s32)(s16)b.half[2 * i] * (s32)(s16)c.half[2 * i] + (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((s32)((s16)b.half[0])) * ((s32)((s16)c.half[0]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((s32)((s16)b.half[2])) * ((s32)((s16)c.half[2]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((s32)((s16)b.half[4])) * ((s32)((s16)c.half[4]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((s32)((s16)b.half[6])) * ((s32)((s16)c.half[6]))) + ((s32)a.word[3]);\n  dst.word[4] =\n      (((s32)((s16)b.half[8])) * ((s32)((s16)c.half[8]))) + ((s32)a.word[4]);\n  dst.word[5] =\n      (((s32)((s16)b.half[10])) * ((s32)((s16)c.half[10]))) + ((s32)a.word[5]);\n  dst.word[6] =\n      (((s32)((s16)b.half[12])) * ((s32)((s16)c.half[12]))) + ((s32)a.word[6]);\n  dst.word[7] =\n      (((s32)((s16)b.half[14])) * ((s32)((s16)c.half[14]))) + ((s32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_w_h (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 16-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] =\n      (s32)(s16)b.half[2 * i] * (s32)(s16)c.half[2 * i] + (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((s32)((s16)b.half[0])) * ((s32)((s16)c.half[0]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((s32)((s16)b.half[2])) * ((s32)((s16)c.half[2]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((s32)((s16)b.half[4])) * ((s32)((s16)c.half[4]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((s32)((s16)b.half[6])) * ((s32)((s16)c.half[6]))) + ((s32)a.word[3]);\n  dst.word[4] =\n      (((s32)((s16)b.half[8])) * ((s32)((s16)c.half[8]))) + ((s32)a.word[4]);\n  dst.word[5] =\n      (((s32)((s16)b.half[10])) * ((s32)((s16)c.half[10]))) + ((s32)a.word[5]);\n  dst.word[6] =\n      (((s32)((s16)b.half[12])) * ((s32)((s16)c.half[12]))) + ((s32)a.word[6]);\n  dst.word[7] =\n      (((s32)((s16)b.half[14])) * ((s32)((s16)c.half[14]))) + ((s32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_w_hu (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_w_hu (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.w.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 16-bit elements in `b` and unsigned elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] =\n      (u32)(u16)b.half[2 * i] * (u32)(u16)c.half[2 * i] + (u32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[0])) * ((u32)((u16)c.half[0]))) + ((u32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[2])) * ((u32)((u16)c.half[2]))) + ((u32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[4])) * ((u32)((u16)c.half[4]))) + ((u32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[6])) * ((u32)((u16)c.half[6]))) + ((u32)a.word[3]);\n  dst.word[4] =\n      (((u32)((u16)b.half[8])) * ((u32)((u16)c.half[8]))) + ((u32)a.word[4]);\n  dst.word[5] =\n      (((u32)((u16)b.half[10])) * ((u32)((u16)c.half[10]))) + ((u32)a.word[5]);\n  dst.word[6] =\n      (((u32)((u16)b.half[12])) * ((u32)((u16)c.half[12]))) + ((u32)a.word[6]);\n  dst.word[7] =\n      (((u32)((u16)b.half[14])) * ((u32)((u16)c.half[14]))) + ((u32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_w_hu (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.w.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 16-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] =\n      (u32)(u16)b.half[2 * i] * (u32)(u16)c.half[2 * i] + (u32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[0])) * ((u32)((u16)c.half[0]))) + ((u32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[2])) * ((u32)((u16)c.half[2]))) + ((u32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[4])) * ((u32)((u16)c.half[4]))) + ((u32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[6])) * ((u32)((u16)c.half[6]))) + ((u32)a.word[3]);\n  dst.word[4] =\n      (((u32)((u16)b.half[8])) * ((u32)((u16)c.half[8]))) + ((u32)a.word[4]);\n  dst.word[5] =\n      (((u32)((u16)b.half[10])) * ((u32)((u16)c.half[10]))) + ((u32)a.word[5]);\n  dst.word[6] =\n      (((u32)((u16)b.half[12])) * ((u32)((u16)c.half[12]))) + ((u32)a.word[6]);\n  dst.word[7] =\n      (((u32)((u16)b.half[14])) * ((u32)((u16)c.half[14]))) + ((u32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwev_w_hu_h (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwev_w_hu_h (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwev.w.hu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 16-bit elements in `b` and signed elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] =\n      (u32)(u16)b.half[2 * i] * (s32)(s16)c.half[2 * i] + (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[0])) * ((s32)((s16)c.half[0]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[2])) * ((s32)((s16)c.half[2]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[4])) * ((s32)((s16)c.half[4]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[6])) * ((s32)((s16)c.half[6]))) + ((s32)a.word[3]);\n  dst.word[4] =\n      (((u32)((u16)b.half[8])) * ((s32)((s16)c.half[8]))) + ((s32)a.word[4]);\n  dst.word[5] =\n      (((u32)((u16)b.half[10])) * ((s32)((s16)c.half[10]))) + ((s32)a.word[5]);\n  dst.word[6] =\n      (((u32)((u16)b.half[12])) * ((s32)((s16)c.half[12]))) + ((s32)a.word[6]);\n  dst.word[7] =\n      (((u32)((u16)b.half[14])) * ((s32)((s16)c.half[14]))) + ((s32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwev_w_hu_h (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwev.w.hu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 16-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] =\n      (u32)(u16)b.half[2 * i] * (s32)(s16)c.half[2 * i] + (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[0])) * ((s32)((s16)c.half[0]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[2])) * ((s32)((s16)c.half[2]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[4])) * ((s32)((s16)c.half[4]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[6])) * ((s32)((s16)c.half[6]))) + ((s32)a.word[3]);\n  dst.word[4] =\n      (((u32)((u16)b.half[8])) * ((s32)((s16)c.half[8]))) + ((s32)a.word[4]);\n  dst.word[5] =\n      (((u32)((u16)b.half[10])) * ((s32)((s16)c.half[10]))) + ((s32)a.word[5]);\n  dst.word[6] =\n      (((u32)((u16)b.half[12])) * ((s32)((s16)c.half[12]))) + ((s32)a.word[6]);\n  dst.word[7] =\n      (((u32)((u16)b.half[14])) * ((s32)((s16)c.half[14]))) + ((s32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_d_w (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_d_w (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned signed 32-bit elements in `b` and signed elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)b.word[2 * i + 1] * (s64)(s32)c.word[2 * i + 1] +\n                 (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((s64)((s32)b.word[1])) * ((s64)((s32)c.word[1]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((s64)((s32)b.word[3])) * ((s64)((s32)c.word[3]))) + ((s64)a.dword[1]);\n  dst.dword[2] =\n      (((s64)((s32)b.word[5])) * ((s64)((s32)c.word[5]))) + ((s64)a.dword[2]);\n  dst.dword[3] =\n      (((s64)((s32)b.word[7])) * ((s64)((s32)c.word[7]))) + ((s64)a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_d_w (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 32-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)b.word[2 * i + 1] * (s64)(s32)c.word[2 * i + 1] +\n                 (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((s64)((s32)b.word[1])) * ((s64)((s32)c.word[1]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((s64)((s32)b.word[3])) * ((s64)((s32)c.word[3]))) + ((s64)a.dword[1]);\n  dst.dword[2] =\n      (((s64)((s32)b.word[5])) * ((s64)((s32)c.word[5]))) + ((s64)a.dword[2]);\n  dst.dword[3] =\n      (((s64)((s32)b.word[7])) * ((s64)((s32)c.word[7]))) + ((s64)a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_d_wu (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_d_wu (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.d.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 32-bit elements in `b` and unsigned elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)b.word[2 * i + 1] * (u64)(u32)c.word[2 * i + 1] +\n                 (u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[1])) * ((u64)((u32)c.word[1]))) + ((u64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[3])) * ((u64)((u32)c.word[3]))) + ((u64)a.dword[1]);\n  dst.dword[2] =\n      (((u64)((u32)b.word[5])) * ((u64)((u32)c.word[5]))) + ((u64)a.dword[2]);\n  dst.dword[3] =\n      (((u64)((u32)b.word[7])) * ((u64)((u32)c.word[7]))) + ((u64)a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_d_wu (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.d.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 32-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)b.word[2 * i + 1] * (u64)(u32)c.word[2 * i + 1] +\n                 (u64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[1])) * ((u64)((u32)c.word[1]))) + ((u64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[3])) * ((u64)((u32)c.word[3]))) + ((u64)a.dword[1]);\n  dst.dword[2] =\n      (((u64)((u32)b.word[5])) * ((u64)((u32)c.word[5]))) + ((u64)a.dword[2]);\n  dst.dword[3] =\n      (((u64)((u32)b.word[7])) * ((u64)((u32)c.word[7]))) + ((u64)a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_d_wu_w (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_d_wu_w (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.d.wu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 32-bit elements in `b` and signed elements in `c`, add to 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)b.word[2 * i + 1] * (s64)(s32)c.word[2 * i + 1] +\n                 (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[1])) * ((s64)((s32)c.word[1]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[3])) * ((s64)((s32)c.word[3]))) + ((s64)a.dword[1]);\n  dst.dword[2] =\n      (((u64)((u32)b.word[5])) * ((s64)((s32)c.word[5]))) + ((s64)a.dword[2]);\n  dst.dword[3] =\n      (((u64)((u32)b.word[7])) * ((s64)((s32)c.word[7]))) + ((s64)a.dword[3]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_d_wu_w (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.d.wu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 32-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)b.word[2 * i + 1] * (s64)(s32)c.word[2 * i + 1] +\n                 (s64)a.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] =\n      (((u64)((u32)b.word[1])) * ((s64)((s32)c.word[1]))) + ((s64)a.dword[0]);\n  dst.dword[1] =\n      (((u64)((u32)b.word[3])) * ((s64)((s32)c.word[3]))) + ((s64)a.dword[1]);\n  dst.dword[2] =\n      (((u64)((u32)b.word[5])) * ((s64)((s32)c.word[5]))) + ((s64)a.dword[2]);\n  dst.dword[3] =\n      (((u64)((u32)b.word[7])) * ((s64)((s32)c.word[7]))) + ((s64)a.dword[3]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_h_b (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_h_b (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned signed 8-bit elements in `b` and signed elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] =\n      (s16)(s8)b.byte[2 * i + 1] * (s16)(s8)c.byte[2 * i + 1] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((s16)((s8)b.byte[1])) * ((s16)((s8)c.byte[1]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((s16)((s8)b.byte[3])) * ((s16)((s8)c.byte[3]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((s16)((s8)b.byte[5])) * ((s16)((s8)c.byte[5]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((s16)((s8)b.byte[7])) * ((s16)((s8)c.byte[7]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((s16)((s8)b.byte[9])) * ((s16)((s8)c.byte[9]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((s16)((s8)b.byte[11])) * ((s16)((s8)c.byte[11]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((s16)((s8)b.byte[13])) * ((s16)((s8)c.byte[13]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((s16)((s8)b.byte[15])) * ((s16)((s8)c.byte[15]))) + ((s16)a.half[7]);\n  dst.half[8] =\n      (((s16)((s8)b.byte[17])) * ((s16)((s8)c.byte[17]))) + ((s16)a.half[8]);\n  dst.half[9] =\n      (((s16)((s8)b.byte[19])) * ((s16)((s8)c.byte[19]))) + ((s16)a.half[9]);\n  dst.half[10] =\n      (((s16)((s8)b.byte[21])) * ((s16)((s8)c.byte[21]))) + ((s16)a.half[10]);\n  dst.half[11] =\n      (((s16)((s8)b.byte[23])) * ((s16)((s8)c.byte[23]))) + ((s16)a.half[11]);\n  dst.half[12] =\n      (((s16)((s8)b.byte[25])) * ((s16)((s8)c.byte[25]))) + ((s16)a.half[12]);\n  dst.half[13] =\n      (((s16)((s8)b.byte[27])) * ((s16)((s8)c.byte[27]))) + ((s16)a.half[13]);\n  dst.half[14] =\n      (((s16)((s8)b.byte[29])) * ((s16)((s8)c.byte[29]))) + ((s16)a.half[14]);\n  dst.half[15] =\n      (((s16)((s8)b.byte[31])) * ((s16)((s8)c.byte[31]))) + ((s16)a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_h_b (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 8-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] =\n      (s16)(s8)b.byte[2 * i + 1] * (s16)(s8)c.byte[2 * i + 1] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((s16)((s8)b.byte[1])) * ((s16)((s8)c.byte[1]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((s16)((s8)b.byte[3])) * ((s16)((s8)c.byte[3]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((s16)((s8)b.byte[5])) * ((s16)((s8)c.byte[5]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((s16)((s8)b.byte[7])) * ((s16)((s8)c.byte[7]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((s16)((s8)b.byte[9])) * ((s16)((s8)c.byte[9]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((s16)((s8)b.byte[11])) * ((s16)((s8)c.byte[11]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((s16)((s8)b.byte[13])) * ((s16)((s8)c.byte[13]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((s16)((s8)b.byte[15])) * ((s16)((s8)c.byte[15]))) + ((s16)a.half[7]);\n  dst.half[8] =\n      (((s16)((s8)b.byte[17])) * ((s16)((s8)c.byte[17]))) + ((s16)a.half[8]);\n  dst.half[9] =\n      (((s16)((s8)b.byte[19])) * ((s16)((s8)c.byte[19]))) + ((s16)a.half[9]);\n  dst.half[10] =\n      (((s16)((s8)b.byte[21])) * ((s16)((s8)c.byte[21]))) + ((s16)a.half[10]);\n  dst.half[11] =\n      (((s16)((s8)b.byte[23])) * ((s16)((s8)c.byte[23]))) + ((s16)a.half[11]);\n  dst.half[12] =\n      (((s16)((s8)b.byte[25])) * ((s16)((s8)c.byte[25]))) + ((s16)a.half[12]);\n  dst.half[13] =\n      (((s16)((s8)b.byte[27])) * ((s16)((s8)c.byte[27]))) + ((s16)a.half[13]);\n  dst.half[14] =\n      (((s16)((s8)b.byte[29])) * ((s16)((s8)c.byte[29]))) + ((s16)a.half[14]);\n  dst.half[15] =\n      (((s16)((s8)b.byte[31])) * ((s16)((s8)c.byte[31]))) + ((s16)a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_h_bu (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_h_bu (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.h.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 8-bit elements in `b` and unsigned elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i + 1] * (u16)(u8)c.byte[2 * i + 1] + (u16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[1])) * ((u16)((u8)c.byte[1]))) + ((u16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[3])) * ((u16)((u8)c.byte[3]))) + ((u16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[5])) * ((u16)((u8)c.byte[5]))) + ((u16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[7])) * ((u16)((u8)c.byte[7]))) + ((u16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[9])) * ((u16)((u8)c.byte[9]))) + ((u16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[11])) * ((u16)((u8)c.byte[11]))) + ((u16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[13])) * ((u16)((u8)c.byte[13]))) + ((u16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[15])) * ((u16)((u8)c.byte[15]))) + ((u16)a.half[7]);\n  dst.half[8] =\n      (((u16)((u8)b.byte[17])) * ((u16)((u8)c.byte[17]))) + ((u16)a.half[8]);\n  dst.half[9] =\n      (((u16)((u8)b.byte[19])) * ((u16)((u8)c.byte[19]))) + ((u16)a.half[9]);\n  dst.half[10] =\n      (((u16)((u8)b.byte[21])) * ((u16)((u8)c.byte[21]))) + ((u16)a.half[10]);\n  dst.half[11] =\n      (((u16)((u8)b.byte[23])) * ((u16)((u8)c.byte[23]))) + ((u16)a.half[11]);\n  dst.half[12] =\n      (((u16)((u8)b.byte[25])) * ((u16)((u8)c.byte[25]))) + ((u16)a.half[12]);\n  dst.half[13] =\n      (((u16)((u8)b.byte[27])) * ((u16)((u8)c.byte[27]))) + ((u16)a.half[13]);\n  dst.half[14] =\n      (((u16)((u8)b.byte[29])) * ((u16)((u8)c.byte[29]))) + ((u16)a.half[14]);\n  dst.half[15] =\n      (((u16)((u8)b.byte[31])) * ((u16)((u8)c.byte[31]))) + ((u16)a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_h_bu (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.h.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 8-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i + 1] * (u16)(u8)c.byte[2 * i + 1] + (u16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[1])) * ((u16)((u8)c.byte[1]))) + ((u16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[3])) * ((u16)((u8)c.byte[3]))) + ((u16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[5])) * ((u16)((u8)c.byte[5]))) + ((u16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[7])) * ((u16)((u8)c.byte[7]))) + ((u16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[9])) * ((u16)((u8)c.byte[9]))) + ((u16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[11])) * ((u16)((u8)c.byte[11]))) + ((u16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[13])) * ((u16)((u8)c.byte[13]))) + ((u16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[15])) * ((u16)((u8)c.byte[15]))) + ((u16)a.half[7]);\n  dst.half[8] =\n      (((u16)((u8)b.byte[17])) * ((u16)((u8)c.byte[17]))) + ((u16)a.half[8]);\n  dst.half[9] =\n      (((u16)((u8)b.byte[19])) * ((u16)((u8)c.byte[19]))) + ((u16)a.half[9]);\n  dst.half[10] =\n      (((u16)((u8)b.byte[21])) * ((u16)((u8)c.byte[21]))) + ((u16)a.half[10]);\n  dst.half[11] =\n      (((u16)((u8)b.byte[23])) * ((u16)((u8)c.byte[23]))) + ((u16)a.half[11]);\n  dst.half[12] =\n      (((u16)((u8)b.byte[25])) * ((u16)((u8)c.byte[25]))) + ((u16)a.half[12]);\n  dst.half[13] =\n      (((u16)((u8)b.byte[27])) * ((u16)((u8)c.byte[27]))) + ((u16)a.half[13]);\n  dst.half[14] =\n      (((u16)((u8)b.byte[29])) * ((u16)((u8)c.byte[29]))) + ((u16)a.half[14]);\n  dst.half[15] =\n      (((u16)((u8)b.byte[31])) * ((u16)((u8)c.byte[31]))) + ((u16)a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_h_bu_b (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_h_bu_b (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.h.bu.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 8-bit elements in `b` and signed elements in `c`, add to 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i + 1] * (s16)(s8)c.byte[2 * i + 1] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[1])) * ((s16)((s8)c.byte[1]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[3])) * ((s16)((s8)c.byte[3]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[5])) * ((s16)((s8)c.byte[5]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[7])) * ((s16)((s8)c.byte[7]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[9])) * ((s16)((s8)c.byte[9]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[11])) * ((s16)((s8)c.byte[11]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[13])) * ((s16)((s8)c.byte[13]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[15])) * ((s16)((s8)c.byte[15]))) + ((s16)a.half[7]);\n  dst.half[8] =\n      (((u16)((u8)b.byte[17])) * ((s16)((s8)c.byte[17]))) + ((s16)a.half[8]);\n  dst.half[9] =\n      (((u16)((u8)b.byte[19])) * ((s16)((s8)c.byte[19]))) + ((s16)a.half[9]);\n  dst.half[10] =\n      (((u16)((u8)b.byte[21])) * ((s16)((s8)c.byte[21]))) + ((s16)a.half[10]);\n  dst.half[11] =\n      (((u16)((u8)b.byte[23])) * ((s16)((s8)c.byte[23]))) + ((s16)a.half[11]);\n  dst.half[12] =\n      (((u16)((u8)b.byte[25])) * ((s16)((s8)c.byte[25]))) + ((s16)a.half[12]);\n  dst.half[13] =\n      (((u16)((u8)b.byte[27])) * ((s16)((s8)c.byte[27]))) + ((s16)a.half[13]);\n  dst.half[14] =\n      (((u16)((u8)b.byte[29])) * ((s16)((s8)c.byte[29]))) + ((s16)a.half[14]);\n  dst.half[15] =\n      (((u16)((u8)b.byte[31])) * ((s16)((s8)c.byte[31]))) + ((s16)a.half[15]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_h_bu_b (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.h.bu.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 8-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] =\n      (u16)(u8)b.byte[2 * i + 1] * (s16)(s8)c.byte[2 * i + 1] + (s16)a.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] =\n      (((u16)((u8)b.byte[1])) * ((s16)((s8)c.byte[1]))) + ((s16)a.half[0]);\n  dst.half[1] =\n      (((u16)((u8)b.byte[3])) * ((s16)((s8)c.byte[3]))) + ((s16)a.half[1]);\n  dst.half[2] =\n      (((u16)((u8)b.byte[5])) * ((s16)((s8)c.byte[5]))) + ((s16)a.half[2]);\n  dst.half[3] =\n      (((u16)((u8)b.byte[7])) * ((s16)((s8)c.byte[7]))) + ((s16)a.half[3]);\n  dst.half[4] =\n      (((u16)((u8)b.byte[9])) * ((s16)((s8)c.byte[9]))) + ((s16)a.half[4]);\n  dst.half[5] =\n      (((u16)((u8)b.byte[11])) * ((s16)((s8)c.byte[11]))) + ((s16)a.half[5]);\n  dst.half[6] =\n      (((u16)((u8)b.byte[13])) * ((s16)((s8)c.byte[13]))) + ((s16)a.half[6]);\n  dst.half[7] =\n      (((u16)((u8)b.byte[15])) * ((s16)((s8)c.byte[15]))) + ((s16)a.half[7]);\n  dst.half[8] =\n      (((u16)((u8)b.byte[17])) * ((s16)((s8)c.byte[17]))) + ((s16)a.half[8]);\n  dst.half[9] =\n      (((u16)((u8)b.byte[19])) * ((s16)((s8)c.byte[19]))) + ((s16)a.half[9]);\n  dst.half[10] =\n      (((u16)((u8)b.byte[21])) * ((s16)((s8)c.byte[21]))) + ((s16)a.half[10]);\n  dst.half[11] =\n      (((u16)((u8)b.byte[23])) * ((s16)((s8)c.byte[23]))) + ((s16)a.half[11]);\n  dst.half[12] =\n      (((u16)((u8)b.byte[25])) * ((s16)((s8)c.byte[25]))) + ((s16)a.half[12]);\n  dst.half[13] =\n      (((u16)((u8)b.byte[27])) * ((s16)((s8)c.byte[27]))) + ((s16)a.half[13]);\n  dst.half[14] =\n      (((u16)((u8)b.byte[29])) * ((s16)((s8)c.byte[29]))) + ((s16)a.half[14]);\n  dst.half[15] =\n      (((u16)((u8)b.byte[31])) * ((s16)((s8)c.byte[31]))) + ((s16)a.half[15]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_q_d (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_q_d (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned signed 64-bit elements in `b` and signed elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)b.dword[2 * i + 1] * (s128)(s64)c.dword[2 * i + 1] +\n                 (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((s128)((s64)b.dword[1])) * ((s128)((s64)c.dword[1]))) +\n                 ((s128)a.qword[0]);\n  dst.qword[1] = (((s128)((s64)b.dword[3])) * ((s128)((s64)c.dword[3]))) +\n                 ((s128)a.qword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_q_d (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 64-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)b.dword[2 * i + 1] * (s128)(s64)c.dword[2 * i + 1] +\n                 (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((s128)((s64)b.dword[1])) * ((s128)((s64)c.dword[1]))) +\n                 ((s128)a.qword[0]);\n  dst.qword[1] = (((s128)((s64)b.dword[3])) * ((s128)((s64)c.dword[3]))) +\n                 ((s128)a.qword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_q_du (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_q_du (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.q.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 64-bit elements in `b` and unsigned elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)b.dword[2 * i + 1] * (u128)(u64)c.dword[2 * i + 1] +\n                 (u128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[1])) * ((u128)((u64)c.dword[1]))) +\n                 ((u128)a.qword[0]);\n  dst.qword[1] = (((u128)((u64)b.dword[3])) * ((u128)((u64)c.dword[3]))) +\n                 ((u128)a.qword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_q_du (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.q.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 64-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)b.dword[2 * i + 1] * (u128)(u64)c.dword[2 * i + 1] +\n                 (u128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[1])) * ((u128)((u64)c.dword[1]))) +\n                 ((u128)a.qword[0]);\n  dst.qword[1] = (((u128)((u64)b.dword[3])) * ((u128)((u64)c.dword[3]))) +\n                 ((u128)a.qword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_q_du_d (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_q_du_d (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.q.du.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 64-bit elements in `b` and signed elements in `c`, add to 128-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)b.dword[2 * i + 1] * (s128)(s64)c.dword[2 * i + 1] +\n                 (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[1])) * ((s128)((s64)c.dword[1]))) +\n                 ((s128)a.qword[0]);\n  dst.qword[1] = (((u128)((u64)b.dword[3])) * ((s128)((s64)c.dword[3]))) +\n                 ((s128)a.qword[1]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 1.14 |\n| 3A6000 | LA664 | 7 | 1.14 |\n| 3C6000 | LA664 | 7 | 1.14 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_q_du_d (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.q.du.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 64-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 128-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)b.dword[2 * i + 1] * (s128)(s64)c.dword[2 * i + 1] +\n                 (s128)a.qword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = (((u128)((u64)b.dword[1])) * ((s128)((s64)c.dword[1]))) +\n                 ((s128)a.qword[0]);\n  dst.qword[1] = (((u128)((u64)b.dword[3])) * ((s128)((s64)c.dword[3]))) +\n                 ((s128)a.qword[1]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>1.14</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_w_h (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_w_h (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned signed 16-bit elements in `b` and signed elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)b.half[2 * i + 1] * (s32)(s16)c.half[2 * i + 1] +\n                (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((s32)((s16)b.half[1])) * ((s32)((s16)c.half[1]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((s32)((s16)b.half[3])) * ((s32)((s16)c.half[3]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((s32)((s16)b.half[5])) * ((s32)((s16)c.half[5]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((s32)((s16)b.half[7])) * ((s32)((s16)c.half[7]))) + ((s32)a.word[3]);\n  dst.word[4] =\n      (((s32)((s16)b.half[9])) * ((s32)((s16)c.half[9]))) + ((s32)a.word[4]);\n  dst.word[5] =\n      (((s32)((s16)b.half[11])) * ((s32)((s16)c.half[11]))) + ((s32)a.word[5]);\n  dst.word[6] =\n      (((s32)((s16)b.half[13])) * ((s32)((s16)c.half[13]))) + ((s32)a.word[6]);\n  dst.word[7] =\n      (((s32)((s16)b.half[15])) * ((s32)((s16)c.half[15]))) + ((s32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_w_h (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 16-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)b.half[2 * i + 1] * (s32)(s16)c.half[2 * i + 1] +\n                (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((s32)((s16)b.half[1])) * ((s32)((s16)c.half[1]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((s32)((s16)b.half[3])) * ((s32)((s16)c.half[3]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((s32)((s16)b.half[5])) * ((s32)((s16)c.half[5]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((s32)((s16)b.half[7])) * ((s32)((s16)c.half[7]))) + ((s32)a.word[3]);\n  dst.word[4] =\n      (((s32)((s16)b.half[9])) * ((s32)((s16)c.half[9]))) + ((s32)a.word[4]);\n  dst.word[5] =\n      (((s32)((s16)b.half[11])) * ((s32)((s16)c.half[11]))) + ((s32)a.word[5]);\n  dst.word[6] =\n      (((s32)((s16)b.half[13])) * ((s32)((s16)c.half[13]))) + ((s32)a.word[6]);\n  dst.word[7] =\n      (((s32)((s16)b.half[15])) * ((s32)((s16)c.half[15]))) + ((s32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_w_hu (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_w_hu (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.w.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 16-bit elements in `b` and unsigned elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)b.half[2 * i + 1] * (u32)(u16)c.half[2 * i + 1] +\n                (u32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[1])) * ((u32)((u16)c.half[1]))) + ((u32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[3])) * ((u32)((u16)c.half[3]))) + ((u32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[5])) * ((u32)((u16)c.half[5]))) + ((u32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[7])) * ((u32)((u16)c.half[7]))) + ((u32)a.word[3]);\n  dst.word[4] =\n      (((u32)((u16)b.half[9])) * ((u32)((u16)c.half[9]))) + ((u32)a.word[4]);\n  dst.word[5] =\n      (((u32)((u16)b.half[11])) * ((u32)((u16)c.half[11]))) + ((u32)a.word[5]);\n  dst.word[6] =\n      (((u32)((u16)b.half[13])) * ((u32)((u16)c.half[13]))) + ((u32)a.word[6]);\n  dst.word[7] =\n      (((u32)((u16)b.half[15])) * ((u32)((u16)c.half[15]))) + ((u32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_w_hu (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.w.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 16-bit elements in <code>b</code> and unsigned elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)b.half[2 * i + 1] * (u32)(u16)c.half[2 * i + 1] +\n                (u32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[1])) * ((u32)((u16)c.half[1]))) + ((u32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[3])) * ((u32)((u16)c.half[3]))) + ((u32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[5])) * ((u32)((u16)c.half[5]))) + ((u32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[7])) * ((u32)((u16)c.half[7]))) + ((u32)a.word[3]);\n  dst.word[4] =\n      (((u32)((u16)b.half[9])) * ((u32)((u16)c.half[9]))) + ((u32)a.word[4]);\n  dst.word[5] =\n      (((u32)((u16)b.half[11])) * ((u32)((u16)c.half[11]))) + ((u32)a.word[5]);\n  dst.word[6] =\n      (((u32)((u16)b.half[13])) * ((u32)((u16)c.half[13]))) + ((u32)a.word[6]);\n  dst.word[7] =\n      (((u32)((u16)b.half[15])) * ((u32)((u16)c.half[15]))) + ((u32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaddwod_w_hu_h (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaddwod_w_hu_h (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmaddwod.w.hu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 16-bit elements in `b` and signed elements in `c`, add to 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)b.half[2 * i + 1] * (s32)(s16)c.half[2 * i + 1] +\n                (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[1])) * ((s32)((s16)c.half[1]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[3])) * ((s32)((s16)c.half[3]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[5])) * ((s32)((s16)c.half[5]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[7])) * ((s32)((s16)c.half[7]))) + ((s32)a.word[3]);\n  dst.word[4] =\n      (((u32)((u16)b.half[9])) * ((s32)((s16)c.half[9]))) + ((s32)a.word[4]);\n  dst.word[5] =\n      (((u32)((u16)b.half[11])) * ((s32)((s16)c.half[11]))) + ((s32)a.word[5]);\n  dst.word[6] =\n      (((u32)((u16)b.half[13])) * ((s32)((s16)c.half[13]))) + ((s32)a.word[6]);\n  dst.word[7] =\n      (((u32)((u16)b.half[15])) * ((s32)((s16)c.half[15]))) + ((s32)a.word[7]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaddwod_w_hu_h (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaddwod.w.hu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 16-bit elements in <code>b</code> and signed elements in <code>c</code>, add to 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)b.half[2 * i + 1] * (s32)(s16)c.half[2 * i + 1] +\n                (s32)a.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] =\n      (((u32)((u16)b.half[1])) * ((s32)((s16)c.half[1]))) + ((s32)a.word[0]);\n  dst.word[1] =\n      (((u32)((u16)b.half[3])) * ((s32)((s16)c.half[3]))) + ((s32)a.word[1]);\n  dst.word[2] =\n      (((u32)((u16)b.half[5])) * ((s32)((s16)c.half[5]))) + ((s32)a.word[2]);\n  dst.word[3] =\n      (((u32)((u16)b.half[7])) * ((s32)((s16)c.half[7]))) + ((s32)a.word[3]);\n  dst.word[4] =\n      (((u32)((u16)b.half[9])) * ((s32)((s16)c.half[9]))) + ((s32)a.word[4]);\n  dst.word[5] =\n      (((u32)((u16)b.half[11])) * ((s32)((s16)c.half[11]))) + ((s32)a.word[5]);\n  dst.word[6] =\n      (((u32)((u16)b.half[13])) * ((s32)((s16)c.half[13]))) + ((s32)a.word[6]);\n  dst.word[7] =\n      (((u32)((u16)b.half[15])) * ((s32)((s16)c.half[15]))) + ((s32)a.word[7]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmax_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmax_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmax.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for signed 8-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = max((s8)a.byte[i], (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmax_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmax.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 8-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = max((s8)a.byte[i], (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmax_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmax_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmax.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 8-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = max((u8)a.byte[i], (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmax_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmax.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 8-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = max((u8)a.byte[i], (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmax_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmax_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmax.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for signed 64-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = max((s64)a.dword[i], (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmax_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmax.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 64-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = max((s64)a.dword[i], (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmax_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmax_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmax.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 64-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = max((u64)a.dword[i], (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmax_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmax.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 64-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = max((u64)a.dword[i], (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmax_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmax_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmax.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for signed 16-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = max((s16)a.half[i], (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmax_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmax.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 16-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = max((s16)a.half[i], (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmax_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmax_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmax.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 16-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = max((u16)a.half[i], (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmax_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmax.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 16-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = max((u16)a.half[i], (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmax_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmax_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmax.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for signed 32-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = max((s32)a.word[i], (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmax_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmax.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 32-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = max((s32)a.word[i], (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmax_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmax_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmax.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 32-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = max((u32)a.word[i], (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmax_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmax.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 32-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = max((u32)a.word[i], (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaxi_b (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaxi_b (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvmaxi.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for signed 8-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = max((s8)a.byte[i], (s8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaxi_b (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaxi.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 8-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = max((s8)a.byte[i], (s8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaxi_bu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaxi_bu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvmaxi.bu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 8-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = max((u8)a.byte[i], (u8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaxi_bu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaxi.bu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 8-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = max((u8)a.byte[i], (u8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaxi_d (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaxi_d (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvmaxi.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for signed 64-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = max((s64)a.dword[i], (s64)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaxi_d (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaxi.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 64-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = max((s64)a.dword[i], (s64)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaxi_du (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaxi_du (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvmaxi.du xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 64-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = max((u64)a.dword[i], (u64)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaxi_du (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaxi.du xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 64-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = max((u64)a.dword[i], (u64)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaxi_h (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaxi_h (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvmaxi.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for signed 16-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = max((s16)a.half[i], (s16)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaxi_h (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaxi.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 16-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = max((s16)a.half[i], (s16)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaxi_hu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaxi_hu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvmaxi.hu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 16-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = max((u16)a.half[i], (u16)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaxi_hu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaxi.hu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 16-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = max((u16)a.half[i], (u16)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaxi_w (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaxi_w (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvmaxi.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for signed 32-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = max((s32)a.word[i], (s32)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaxi_w (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaxi.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for signed 32-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = max((s32)a.word[i], (s32)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmaxi_wu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmaxi_wu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvmaxi.wu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise maximum for unsigned 32-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = max((u32)a.word[i], (u32)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmaxi_wu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmaxi.wu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise maximum for unsigned 32-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = max((u32)a.word[i], (u32)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmepatmsk_v (int mode, int uimm5)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmepatmsk_v (int mode, int uimm5)\n#include <lasxintrin.h>\nInstruction: xvmepatmsk.v xr, mode, uimm5\nCPU Flags: LASX\n```\n\n### Description\n\nCompute pattern according to `mode`, then add `uimm5` to each element.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvmepatmsk_v(3, 1)\n= 0x0807060504030201 0x100f0e0d0c0b0a09 0x0807060504030201 0x100f0e0d0c0b0a09\n```\n\n\n### Operation\n\n```c++\nif (mode == 0b00) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i + 16] = dst.byte[i] =\n        uimm5 + (i % 4); // [0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3]\n  }\n} else if (mode == 0b01) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i + 16] = dst.byte[i] =\n        uimm5 + (i / 4) + (i % 4); // [0 1 2 3 1 2 3 4 2 3 4 5 3 4 5 6]\n  }\n} else if (mode == 0b10) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i + 16] = dst.byte[i] =\n        uimm5 + (i / 4) + (i % 4) + 4; // [4 5 6 7 5 6 7 8 6 7 8 9 7 8 9 10]\n  }\n} else if (mode == 0b11) {\n  for (int i = 0; i < 16; i++) {\n    dst.byte[i + 16] = dst.byte[i] =\n        uimm5 + i; // [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]\n  }\n} else {\n  // illegal instruction\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C6000 | LA664 | N/A | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmepatmsk_v (int mode, int uimm5)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmepatmsk.v xr, mode, uimm5\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute pattern according to <code>mode</code>, then add <code>uimm5</code> to each element.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmepatmsk_v(3, 1)\n= 0x0807060504030201 0x100f0e0d0c0b0a09 0x0807060504030201 0x100f0e0d0c0b0a09\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">if (mode == 0b00) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i + 16] = dst.byte[i] =\n        uimm5 + (i % 4); // [0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3]\n  }\n} else if (mode == 0b01) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i + 16] = dst.byte[i] =\n        uimm5 + (i / 4) + (i % 4); // [0 1 2 3 1 2 3 4 2 3 4 5 3 4 5 6]\n  }\n} else if (mode == 0b10) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i + 16] = dst.byte[i] =\n        uimm5 + (i / 4) + (i % 4) + 4; // [4 5 6 7 5 6 7 8 6 7 8 9 7 8 9 10]\n  }\n} else if (mode == 0b11) {\n  for (int i = 0; i &lt; 16; i++) {\n    dst.byte[i + 16] = dst.byte[i] =\n        uimm5 + i; // [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]\n  }\n} else {\n  // illegal instruction\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Undocumented Intrinsics", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmin_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmin_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmin.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for signed 8-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = min((s8)a.byte[i], (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmin_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmin.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 8-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = min((s8)a.byte[i], (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmin_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmin_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmin.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 8-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = min((u8)a.byte[i], (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmin_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmin.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 8-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = min((u8)a.byte[i], (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmin_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmin_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmin.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for signed 64-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = min((s64)a.dword[i], (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmin_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmin.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 64-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = min((s64)a.dword[i], (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmin_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmin_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmin.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 64-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = min((u64)a.dword[i], (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmin_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmin.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 64-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = min((u64)a.dword[i], (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmin_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmin_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmin.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for signed 16-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = min((s16)a.half[i], (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmin_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmin.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 16-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = min((s16)a.half[i], (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmin_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmin_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmin.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 16-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = min((u16)a.half[i], (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmin_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmin.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 16-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = min((u16)a.half[i], (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmin_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmin_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmin.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for signed 32-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = min((s32)a.word[i], (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmin_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmin.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 32-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = min((s32)a.word[i], (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmin_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmin_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmin.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 32-bit elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = min((u32)a.word[i], (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmin_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmin.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 32-bit elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = min((u32)a.word[i], (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmini_b (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmini_b (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvmini.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for signed 8-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = min((s8)a.byte[i], (s8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmini_b (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmini.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 8-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = min((s8)a.byte[i], (s8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmini_bu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmini_bu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvmini.bu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 8-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = min((u8)a.byte[i], (u8)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmini_bu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmini.bu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 8-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = min((u8)a.byte[i], (u8)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmini_d (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmini_d (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvmini.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for signed 64-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = min((s64)a.dword[i], (s64)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmini_d (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmini.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 64-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = min((s64)a.dword[i], (s64)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmini_du (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmini_du (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvmini.du xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 64-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = min((u64)a.dword[i], (u64)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmini_du (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmini.du xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 64-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = min((u64)a.dword[i], (u64)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmini_h (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmini_h (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvmini.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for signed 16-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = min((s16)a.half[i], (s16)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmini_h (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmini.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 16-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = min((s16)a.half[i], (s16)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmini_hu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmini_hu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvmini.hu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 16-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = min((u16)a.half[i], (u16)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmini_hu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmini.hu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 16-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = min((u16)a.half[i], (u16)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmini_w (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmini_w (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvmini.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for signed 32-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = min((s32)a.word[i], (s32)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmini_w (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmini.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for signed 32-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = min((s32)a.word[i], (s32)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmini_wu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmini_wu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvmini.wu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute elementwise minimum for unsigned 32-bit elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = min((u32)a.word[i], (u32)imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmini_wu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmini.wu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute elementwise minimum for unsigned 32-bit elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = min((u32)a.word[i], (u32)imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmod_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmod_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmod.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nModulo residual signed 8-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((s8)a.byte[i] % (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 29, 33 | 0.05(1/21.5) |\n| 3A6000 | LA664 | 29, 41 | 0.06(1/15.5) |\n| 3C6000 | LA664 | 29 | 0.07(1/13.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmod_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmod.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual signed 8-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((s8)a.byte[i] % (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>29, 33</td>\n<td>0.05(1/21.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>29, 41</td>\n<td>0.06(1/15.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>29</td>\n<td>0.07(1/13.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmod_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmod_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmod.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nModulo residual unsigned 8-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((u8)a.byte[i] % (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 29, 37 | 0.05(1/22) |\n| 3A6000 | LA664 | 29, 37 | 0.06(1/17.5) |\n| 3C6000 | LA664 | 29 | 0.07(1/13.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmod_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmod.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (b.byte[i] == 0) ? 0 : ((u8)a.byte[i] % (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>29, 37</td>\n<td>0.05(1/22)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>29, 37</td>\n<td>0.06(1/17.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>29</td>\n<td>0.07(1/13.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmod_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmod_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmod.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nModulo residual signed 64-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((s64)a.dword[i] % (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 10 | 0.11(1/9.5) |\n| 3A6000 | LA664 | 8, 10 | 0.25(1/4) |\n| 3C6000 | LA664 | 8 | 0.33(1/3) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmod_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmod.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual signed 64-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((s64)a.dword[i] % (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 10</td>\n<td>0.11(1/9.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8, 10</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.33(1/3)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmod_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmod_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmod.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nModulo residual unsigned 64-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((u64)a.dword[i] % (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 8, 10 | 0.11(1/9.5) |\n| 3A6000 | LA664 | 8, 10 | 0.25(1/4) |\n| 3C6000 | LA664 | 8 | 0.33(1/3) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmod_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmod.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (b.dword[i] == 0) ? 0 : ((u64)a.dword[i] % (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>8, 10</td>\n<td>0.11(1/9.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>8, 10</td>\n<td>0.25(1/4)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>8</td>\n<td>0.33(1/3)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmod_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmod_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmod.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nModulo residual signed 16-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((s16)a.half[i] % (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 17, 21 | 0.07(1/13.5) |\n| 3A6000 | LA664 | 17, 21 | 0.12(1/8.5) |\n| 3C6000 | LA664 | 17 | 0.13(1/7.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmod_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmod.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual signed 16-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((s16)a.half[i] % (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>17, 21</td>\n<td>0.07(1/13.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17, 21</td>\n<td>0.12(1/8.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>17</td>\n<td>0.13(1/7.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmod_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmod_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmod.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nModulo residual unsigned 16-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((u16)a.half[i] % (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 17, 23 | 0.06(1/16) |\n| 3A6000 | LA664 | 17, 25 | 0.11(1/9.5) |\n| 3C6000 | LA664 | 17 | 0.13(1/7.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmod_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmod.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (b.half[i] == 0) ? 0 : ((u16)a.half[i] % (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>17, 23</td>\n<td>0.06(1/16)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>17, 25</td>\n<td>0.11(1/9.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>17</td>\n<td>0.13(1/7.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmod_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmod_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmod.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nModulo residual signed 32-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((s32)a.word[i] % (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 15 | 0.07(1/13.5) |\n| 3A6000 | LA664 | 11, 13 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11 | 0.22(1/4.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmod_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmod.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual signed 32-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((s32)a.word[i] % (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 15</td>\n<td>0.07(1/13.5)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11, 13</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.22(1/4.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmod_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmod_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmod.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nModulo residual unsigned 32-bit elements in `a` by elements in `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((u32)a.word[i] % (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 11, 15 | 0.06(1/16) |\n| 3A6000 | LA664 | 11, 13 | 0.18(1/5.5) |\n| 3C6000 | LA664 | 11 | 0.22(1/4.5) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmod_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmod.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Modulo residual unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (b.word[i] == 0) ? 0 : ((u32)a.word[i] % (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>11, 15</td>\n<td>0.06(1/16)</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>11, 13</td>\n<td>0.18(1/5.5)</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>11</td>\n<td>0.22(1/4.5)</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmskgez_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmskgez_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvmskgez.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nFor each 8-bit element in `a`, if the element is greater than or equal to zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvmskgez_b(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x00000000000001fe 0x0000000000000000 0x000000000000ff0f 0x0000000000000000\n__m256i __lasx_xvmskgez_b(__m256i{0x0000191100000000, 0x00a1000011b11c11, 0x1181000008010101, 0x0000000000000000})\n= 0x000000000000bbff 0x0000000000000000 0x000000000000ffbf 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8080808080808080;\nu64 c = m & a.dword[0];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] |= c << 8;\ndst.dword[0] = (u16)~dst.dword[0];\ndst.dword[1] = 0;\n\nc = m & a.dword[2];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[2] = c;\nc = m & a.dword[3];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[2] |= c << 8;\ndst.dword[2] = (u16)~dst.dword[2];\ndst.dword[3] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskgez_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmskgez.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 8-bit element in <code>a</code>, if the element is greater than or equal to zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskgez_b(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x00000000000001fe 0x0000000000000000 0x000000000000ff0f 0x0000000000000000\n__m256i __lasx_xvmskgez_b(__m256i{0x0000191100000000, 0x00a1000011b11c11, 0x1181000008010101, 0x0000000000000000})\n= 0x000000000000bbff 0x0000000000000000 0x000000000000ffbf 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8080808080808080;\nu64 c = m &amp; a.dword[0];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] |= c &lt;&lt; 8;\ndst.dword[0] = (u16)~dst.dword[0];\ndst.dword[1] = 0;\n\nc = m &amp; a.dword[2];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[2] = c;\nc = m &amp; a.dword[3];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[2] |= c &lt;&lt; 8;\ndst.dword[2] = (u16)~dst.dword[2];\ndst.dword[3] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmskltz_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmskltz_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvmskltz.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nFor each 8-bit element in `a`, if the element is less than zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvmskltz_b(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x000000000000fe01 0x0000000000000000 0x00000000000000f0 0x0000000000000000\n__m256i __lasx_xvmskltz_b(__m256i{0x0000118100000000, 0x0081000081111118, 0x1181000001010801, 0x0000000000000000})\n= 0x0000000000004810 0x0000000000000000 0x0000000000000040 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8080808080808080;\nu64 c = m & a.dword[0];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] |= c << 8;\ndst.dword[1] = 0;\n\nc = m & a.dword[2];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[2] = c;\nc = m & a.dword[3];\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[2] |= c << 8;\ndst.dword[3] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskltz_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmskltz.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 8-bit element in <code>a</code>, if the element is less than zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskltz_b(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x000000000000fe01 0x0000000000000000 0x00000000000000f0 0x0000000000000000\n__m256i __lasx_xvmskltz_b(__m256i{0x0000118100000000, 0x0081000081111118, 0x1181000001010801, 0x0000000000000000})\n= 0x0000000000004810 0x0000000000000000 0x0000000000000040 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8080808080808080;\nu64 c = m &amp; a.dword[0];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] |= c &lt;&lt; 8;\ndst.dword[1] = 0;\n\nc = m &amp; a.dword[2];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[2] = c;\nc = m &amp; a.dword[3];\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[2] |= c &lt;&lt; 8;\ndst.dword[3] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmskltz_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmskltz_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvmskltz.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nFor each 64-bit element in `a`, if the element is less than zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvmskltz_d(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x0000000000000002 0x0000000000000000 0x0000000000000001 0x0000000000000000\n__m256i __lasx_xvmskltz_d(__m256i{0x0000111800000000, 0x0081000081111111, 0x8111000008010101, 0x0000000000000000})\n= 0x0000000000000000 0x0000000000000000 0x0000000000000001 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8000000000000000;\nu64 c = m & a.dword[0];\nc >>= 63;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc >>= 63;\ndst.dword[0] |= c << 1;\ndst.dword[1] = 0;\n\nc = m & a.dword[2];\nc >>= 63;\ndst.dword[2] = c;\nc = m & a.dword[3];\nc >>= 63;\ndst.dword[2] |= c << 1;\ndst.dword[3] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskltz_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmskltz.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 64-bit element in <code>a</code>, if the element is less than zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskltz_d(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x0000000000000002 0x0000000000000000 0x0000000000000001 0x0000000000000000\n__m256i __lasx_xvmskltz_d(__m256i{0x0000111800000000, 0x0081000081111111, 0x8111000008010101, 0x0000000000000000})\n= 0x0000000000000000 0x0000000000000000 0x0000000000000001 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8000000000000000;\nu64 c = m &amp; a.dword[0];\nc &gt;&gt;= 63;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc &gt;&gt;= 63;\ndst.dword[0] |= c &lt;&lt; 1;\ndst.dword[1] = 0;\n\nc = m &amp; a.dword[2];\nc &gt;&gt;= 63;\ndst.dword[2] = c;\nc = m &amp; a.dword[3];\nc &gt;&gt;= 63;\ndst.dword[2] |= c &lt;&lt; 1;\ndst.dword[3] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmskltz_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmskltz_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvmskltz.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nFor each 16-bit element in `a`, if the element is less than zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvmskltz_h(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x00000000000000f0 0x0000000000000000 0x000000000000000c 0x0000000000000000\n__m256i __lasx_xvmskltz_h(__m256i{0x0000818100000000, 0x0018000018181881, 0x1181000008080808, 0x0000000000000000})\n= 0x0000000000000004 0x0000000000000000 0x0000000000000000 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8000800080008000;\nu64 c = m & a.dword[0];\nc |= c << 15;\nc |= c << 30;\nc >>= 60;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc |= c << 15;\nc |= c << 30;\nc >>= 60;\ndst.dword[0] |= c << 4;\ndst.dword[1] = 0;\n\nc = m & a.dword[2];\nc |= c << 15;\nc |= c << 30;\nc >>= 60;\ndst.dword[2] = c;\nc = m & a.dword[3];\nc |= c << 15;\nc |= c << 30;\nc >>= 60;\ndst.dword[2] |= c << 4;\ndst.dword[3] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskltz_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmskltz.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 16-bit element in <code>a</code>, if the element is less than zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskltz_h(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x00000000000000f0 0x0000000000000000 0x000000000000000c 0x0000000000000000\n__m256i __lasx_xvmskltz_h(__m256i{0x0000818100000000, 0x0018000018181881, 0x1181000008080808, 0x0000000000000000})\n= 0x0000000000000004 0x0000000000000000 0x0000000000000000 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8000800080008000;\nu64 c = m &amp; a.dword[0];\nc |= c &lt;&lt; 15;\nc |= c &lt;&lt; 30;\nc &gt;&gt;= 60;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc |= c &lt;&lt; 15;\nc |= c &lt;&lt; 30;\nc &gt;&gt;= 60;\ndst.dword[0] |= c &lt;&lt; 4;\ndst.dword[1] = 0;\n\nc = m &amp; a.dword[2];\nc |= c &lt;&lt; 15;\nc |= c &lt;&lt; 30;\nc &gt;&gt;= 60;\ndst.dword[2] = c;\nc = m &amp; a.dword[3];\nc |= c &lt;&lt; 15;\nc |= c &lt;&lt; 30;\nc &gt;&gt;= 60;\ndst.dword[2] |= c &lt;&lt; 4;\ndst.dword[3] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmskltz_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmskltz_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvmskltz.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nFor each 32-bit element in `a`, if the element is less than zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvmskltz_w(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x000000000000000c 0x0000000000000000 0x0000000000000002 0x0000000000000000\n__m256i __lasx_xvmskltz_w(__m256i{0x0000811100000000, 0x0018000081111111, 0x8111000001010108, 0x0000000000000000})\n= 0x0000000000000004 0x0000000000000000 0x0000000000000002 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x8000000080000000;\nu64 c = m & a.dword[0];\nc |= c << 31;\nc >>= 62;\ndst.dword[0] = c;\nc = m & a.dword[1];\nc |= c << 31;\nc >>= 62;\ndst.dword[0] |= c << 2;\ndst.dword[1] = 0;\n\nc = m & a.dword[2];\nc |= c << 31;\nc >>= 62;\ndst.dword[2] = c;\nc = m & a.dword[3];\nc |= c << 31;\nc >>= 62;\ndst.dword[2] |= c << 2;\ndst.dword[3] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskltz_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmskltz.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 32-bit element in <code>a</code>, if the element is less than zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmskltz_w(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x000000000000000c 0x0000000000000000 0x0000000000000002 0x0000000000000000\n__m256i __lasx_xvmskltz_w(__m256i{0x0000811100000000, 0x0018000081111111, 0x8111000001010108, 0x0000000000000000})\n= 0x0000000000000004 0x0000000000000000 0x0000000000000002 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x8000000080000000;\nu64 c = m &amp; a.dword[0];\nc |= c &lt;&lt; 31;\nc &gt;&gt;= 62;\ndst.dword[0] = c;\nc = m &amp; a.dword[1];\nc |= c &lt;&lt; 31;\nc &gt;&gt;= 62;\ndst.dword[0] |= c &lt;&lt; 2;\ndst.dword[1] = 0;\n\nc = m &amp; a.dword[2];\nc |= c &lt;&lt; 31;\nc &gt;&gt;= 62;\ndst.dword[2] = c;\nc = m &amp; a.dword[3];\nc |= c &lt;&lt; 31;\nc &gt;&gt;= 62;\ndst.dword[2] |= c &lt;&lt; 2;\ndst.dword[3] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmsknz_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmsknz_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvmsknz.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nFor each 8-bit element in `a`, if the element is non-zero, set one bit in `dst`, otherwise clear it.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvmsknz_b(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x000000000000feff 0x0000000000000000 0x000000000000ffff 0x0000000000000000\n__m256i __lasx_xvmsknz_b(__m256i{0x0000111100000000, 0x0011000011111111, 0x1111000001010101, 0x0000000000000000})\n= 0x0000000000004f30 0x0000000000000000 0x00000000000000cf 0x0000000000000000\n```\n\n\n### Operation\n\n```c++\nu64 m = 0x7F7F7F7F7F7F7F7F;\nu64 c = ~(((a.dword[0] & m) + m) | a.dword[0] | m);\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] = c;\nc = ~(((a.dword[1] & m) + m) | a.dword[1] | m);\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[0] |= c << 8;\ndst.dword[0] = (u16)~dst.dword[0];\ndst.dword[1] = 0;\n\nc = ~(((a.dword[2] & m) + m) | a.dword[2] | m);\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[2] = c;\nc = ~(((a.dword[3] & m) + m) | a.dword[3] | m);\nc |= c << 7;\nc |= c << 14;\nc |= c << 28;\nc >>= 56;\ndst.dword[2] |= c << 8;\ndst.dword[2] = (u16)~dst.dword[2];\ndst.dword[3] = 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmsknz_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmsknz.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>For each 8-bit element in <code>a</code>, if the element is non-zero, set one bit in <code>dst</code>, otherwise clear it.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmsknz_b(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabababab12121212, 0x1234567812345678})\n= 0x000000000000feff 0x0000000000000000 0x000000000000ffff 0x0000000000000000\n__m256i __lasx_xvmsknz_b(__m256i{0x0000111100000000, 0x0011000011111111, 0x1111000001010101, 0x0000000000000000})\n= 0x0000000000004f30 0x0000000000000000 0x00000000000000cf 0x0000000000000000\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">u64 m = 0x7F7F7F7F7F7F7F7F;\nu64 c = ~(((a.dword[0] &amp; m) + m) | a.dword[0] | m);\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] = c;\nc = ~(((a.dword[1] &amp; m) + m) | a.dword[1] | m);\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[0] |= c &lt;&lt; 8;\ndst.dword[0] = (u16)~dst.dword[0];\ndst.dword[1] = 0;\n\nc = ~(((a.dword[2] &amp; m) + m) | a.dword[2] | m);\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[2] = c;\nc = ~(((a.dword[3] &amp; m) + m) | a.dword[3] | m);\nc |= c &lt;&lt; 7;\nc |= c &lt;&lt; 14;\nc |= c &lt;&lt; 28;\nc &gt;&gt;= 56;\ndst.dword[2] |= c &lt;&lt; 8;\ndst.dword[2] = (u16)~dst.dword[2];\ndst.dword[3] = 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmsub_b (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmsub_b (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmsub.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 8-bit elements in `b` and `c`, negate and add elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = -b.byte[i] * c.byte[i] + a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmsub_b (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmsub.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 8-bit elements in <code>b</code> and <code>c</code>, negate and add elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = -b.byte[i] * c.byte[i] + a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmsub_d (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmsub_d (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmsub.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 64-bit elements in `b` and `c`, negate and add elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = -b.dword[i] * c.dword[i] + a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmsub_d (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmsub.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 64-bit elements in <code>b</code> and <code>c</code>, negate and add elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = -b.dword[i] * c.dword[i] + a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmsub_h (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmsub_h (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmsub.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 16-bit elements in `b` and `c`, negate and add elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = -b.half[i] * c.half[i] + a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmsub_h (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmsub.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 16-bit elements in <code>b</code> and <code>c</code>, negate and add elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = -b.half[i] * c.half[i] + a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmsub_w (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmsub_w (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvmsub.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 32-bit elements in `b` and `c`, negate and add elements in `a`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = -b.word[i] * c.word[i] + a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmsub_w (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmsub.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 32-bit elements in <code>b</code> and <code>c</code>, negate and add elements in <code>a</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = -b.word[i] * c.word[i] + a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmuh_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmuh_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmuh.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply signed 8-bit elements in `a` and `b`, save the high 8-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (((s16)(s8)a.byte[i] * (s16)(s8)b.byte[i])) >> 8;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmuh_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmuh.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply signed 8-bit elements in <code>a</code> and <code>b</code>, save the high 8-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (((s16)(s8)a.byte[i] * (s16)(s8)b.byte[i])) &gt;&gt; 8;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmuh_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmuh_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmuh.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply unsigned 8-bit elements in `a` and `b`, save the high 8-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (((u16)(u8)a.byte[i] * (u16)(u8)b.byte[i])) >> 8;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmuh_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmuh.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply unsigned 8-bit elements in <code>a</code> and <code>b</code>, save the high 8-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (((u16)(u8)a.byte[i] * (u16)(u8)b.byte[i])) &gt;&gt; 8;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmuh_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmuh_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmuh.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply signed 64-bit elements in `a` and `b`, save the high 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (((s128)(s64)a.dword[i] * (s128)(s64)b.dword[i])) >> 64;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmuh_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmuh.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply signed 64-bit elements in <code>a</code> and <code>b</code>, save the high 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (((s128)(s64)a.dword[i] * (s128)(s64)b.dword[i])) &gt;&gt; 64;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmuh_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmuh_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmuh.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply unsigned 64-bit elements in `a` and `b`, save the high 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (((u128)(u64)a.dword[i] * (u128)(u64)b.dword[i])) >> 64;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmuh_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmuh.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply unsigned 64-bit elements in <code>a</code> and <code>b</code>, save the high 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (((u128)(u64)a.dword[i] * (u128)(u64)b.dword[i])) &gt;&gt; 64;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmuh_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmuh_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmuh.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply signed 16-bit elements in `a` and `b`, save the high 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (((s32)(s16)a.half[i] * (s32)(s16)b.half[i])) >> 16;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmuh_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmuh.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply signed 16-bit elements in <code>a</code> and <code>b</code>, save the high 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (((s32)(s16)a.half[i] * (s32)(s16)b.half[i])) &gt;&gt; 16;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmuh_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmuh_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmuh.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply unsigned 16-bit elements in `a` and `b`, save the high 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (((u32)(u16)a.half[i] * (u32)(u16)b.half[i])) >> 16;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmuh_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmuh.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply unsigned 16-bit elements in <code>a</code> and <code>b</code>, save the high 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (((u32)(u16)a.half[i] * (u32)(u16)b.half[i])) &gt;&gt; 16;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmuh_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmuh_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmuh.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply signed 32-bit elements in `a` and `b`, save the high 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (((s64)(s32)a.word[i] * (s64)(s32)b.word[i])) >> 32;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmuh_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmuh.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply signed 32-bit elements in <code>a</code> and <code>b</code>, save the high 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (((s64)(s32)a.word[i] * (s64)(s32)b.word[i])) &gt;&gt; 32;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmuh_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmuh_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmuh.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply unsigned 32-bit elements in `a` and `b`, save the high 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (((u64)(u32)a.word[i] * (u64)(u32)b.word[i])) >> 32;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmuh_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmuh.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply unsigned 32-bit elements in <code>a</code> and <code>b</code>, save the high 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (((u64)(u32)a.word[i] * (u64)(u32)b.word[i])) &gt;&gt; 32;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmul_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmul_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmul.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] * b.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmul_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmul.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] * b.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmul_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmul_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmul.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] * b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmul_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmul.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] * b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmul_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmul_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmul.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] * b.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmul_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmul.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] * b.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmul_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmul_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmul.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] * b.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmul_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmul.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] * b.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_d_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_d_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] * (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) * ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) * ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[4])) * ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[6])) * ((s64)((s32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_d_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] * (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) * ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) * ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[4])) * ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[6])) * ((s64)((s32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_d_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_d_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.d.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] * (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) * ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) * ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) * ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) * ((u64)((u32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_d_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.d.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] * (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) * ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) * ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) * ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) * ((u64)((u32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_d_wu_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_d_wu_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.d.wu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] * (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) * ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) * ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) * ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) * ((s64)((s32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_d_wu_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.d.wu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] * (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) * ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) * ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) * ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) * ((s64)((s32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_h_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_h_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] * (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) * ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) * ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) * ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) * ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) * ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) * ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) * ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) * ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[16])) * ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[18])) * ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[20])) * ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[22])) * ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[24])) * ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[26])) * ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[28])) * ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[30])) * ((s16)((s8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_h_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] * (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) * ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) * ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) * ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) * ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) * ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) * ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) * ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) * ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[16])) * ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[18])) * ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[20])) * ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[22])) * ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[24])) * ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[26])) * ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[28])) * ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[30])) * ((s16)((s8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_h_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_h_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.h.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] * (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) * ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) * ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) * ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) * ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) * ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) * ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) * ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) * ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) * ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) * ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) * ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) * ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) * ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) * ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) * ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) * ((u16)((u8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_h_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.h.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] * (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) * ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) * ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) * ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) * ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) * ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) * ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) * ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) * ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) * ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) * ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) * ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) * ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) * ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) * ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) * ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) * ((u16)((u8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_h_bu_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_h_bu_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.h.bu.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] * (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) * ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) * ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) * ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) * ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) * ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) * ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) * ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) * ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) * ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) * ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) * ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) * ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) * ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) * ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) * ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) * ((s16)((s8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_h_bu_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.h.bu.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] * (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) * ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) * ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) * ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) * ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) * ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) * ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) * ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) * ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) * ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) * ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) * ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) * ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) * ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) * ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) * ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) * ((s16)((s8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_q_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_q_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] * (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) * ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[2])) * ((s128)((s64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_q_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] * (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) * ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[2])) * ((s128)((s64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_q_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_q_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.q.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] * (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) * ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) * ((u128)((u64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_q_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.q.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] * (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) * ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) * ((u128)((u64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_q_du_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_q_du_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.q.du.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] * (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) * ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) * ((s128)((s64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_q_du_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.q.du.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] * (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) * ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) * ((s128)((s64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_w_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_w_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] * (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) * ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) * ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) * ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) * ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[8])) * ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[10])) * ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[12])) * ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[14])) * ((s32)((s16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_w_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] * (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) * ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) * ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) * ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) * ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[8])) * ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[10])) * ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[12])) * ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[14])) * ((s32)((s16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_w_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_w_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.w.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] * (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) * ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) * ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) * ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) * ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) * ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) * ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) * ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) * ((u32)((u16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_w_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.w.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] * (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) * ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) * ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) * ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) * ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) * ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) * ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) * ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) * ((u32)((u16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwev_w_hu_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwev_w_hu_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwev.w.hu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply even-positioned unsigned 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] * (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) * ((s32)((s16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) * ((s32)((s16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) * ((s32)((s16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) * ((s32)((s16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) * ((s32)((s16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) * ((s32)((s16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) * ((s32)((s16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) * ((s32)((s16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwev_w_hu_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwev.w.hu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply even-positioned unsigned 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] * (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) * ((s32)((s16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) * ((s32)((s16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) * ((s32)((s16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) * ((s32)((s16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) * ((s32)((s16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) * ((s32)((s16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) * ((s32)((s16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) * ((s32)((s16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_d_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_d_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] * (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) * ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) * ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) * ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) * ((s64)((s32)b.word[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_d_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] * (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) * ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) * ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) * ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) * ((s64)((s32)b.word[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_d_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_d_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.d.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] * (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) * ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) * ((u64)((u32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) * ((u64)((u32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) * ((u64)((u32)b.word[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_d_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.d.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] * (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) * ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) * ((u64)((u32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) * ((u64)((u32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) * ((u64)((u32)b.word[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_d_wu_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_d_wu_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.d.wu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] * (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) * ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) * ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) * ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) * ((s64)((s32)b.word[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_d_wu_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.d.wu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] * (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) * ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) * ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) * ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) * ((s64)((s32)b.word[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_h_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_h_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] * (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) * ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) * ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) * ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) * ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) * ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) * ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) * ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) * ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) * ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) * ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) * ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) * ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) * ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) * ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) * ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) * ((s16)((s8)b.byte[31]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_h_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] * (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) * ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) * ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) * ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) * ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) * ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) * ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) * ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) * ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) * ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) * ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) * ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) * ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) * ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) * ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) * ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) * ((s16)((s8)b.byte[31]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_h_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_h_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.h.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] * (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) * ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) * ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) * ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) * ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) * ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) * ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) * ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) * ((u16)((u8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) * ((u16)((u8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) * ((u16)((u8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) * ((u16)((u8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) * ((u16)((u8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) * ((u16)((u8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) * ((u16)((u8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) * ((u16)((u8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) * ((u16)((u8)b.byte[31]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_h_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.h.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] * (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) * ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) * ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) * ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) * ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) * ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) * ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) * ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) * ((u16)((u8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) * ((u16)((u8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) * ((u16)((u8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) * ((u16)((u8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) * ((u16)((u8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) * ((u16)((u8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) * ((u16)((u8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) * ((u16)((u8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) * ((u16)((u8)b.byte[31]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_h_bu_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_h_bu_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.h.bu.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] * (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) * ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) * ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) * ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) * ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) * ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) * ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) * ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) * ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) * ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) * ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) * ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) * ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) * ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) * ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) * ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) * ((s16)((s8)b.byte[31]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_h_bu_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.h.bu.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] * (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) * ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) * ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) * ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) * ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) * ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) * ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) * ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) * ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) * ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) * ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) * ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) * ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) * ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) * ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) * ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) * ((s16)((s8)b.byte[31]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_q_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_q_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] * (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) * ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) * ((s128)((s64)b.dword[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_q_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] * (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) * ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) * ((s128)((s64)b.dword[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_q_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_q_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.q.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] * (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) * ((u128)((u64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) * ((u128)((u64)b.dword[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_q_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.q.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] * (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) * ((u128)((u64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) * ((u128)((u64)b.dword[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_q_du_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_q_du_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.q.du.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] * (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) * ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) * ((s128)((s64)b.dword[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 7 | 2 |\n| 3A6000 | LA664 | 7 | 2 |\n| 3C6000 | LA664 | 7 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_q_du_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.q.du.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] * (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) * ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) * ((s128)((s64)b.dword[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>7</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_w_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_w_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] * (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) * ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) * ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) * ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) * ((s32)((s16)b.half[7]));\n  dst.word[4] = ((s32)((s16)a.half[9])) * ((s32)((s16)b.half[9]));\n  dst.word[5] = ((s32)((s16)a.half[11])) * ((s32)((s16)b.half[11]));\n  dst.word[6] = ((s32)((s16)a.half[13])) * ((s32)((s16)b.half[13]));\n  dst.word[7] = ((s32)((s16)a.half[15])) * ((s32)((s16)b.half[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_w_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] * (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) * ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) * ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) * ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) * ((s32)((s16)b.half[7]));\n  dst.word[4] = ((s32)((s16)a.half[9])) * ((s32)((s16)b.half[9]));\n  dst.word[5] = ((s32)((s16)a.half[11])) * ((s32)((s16)b.half[11]));\n  dst.word[6] = ((s32)((s16)a.half[13])) * ((s32)((s16)b.half[13]));\n  dst.word[7] = ((s32)((s16)a.half[15])) * ((s32)((s16)b.half[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_w_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_w_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.w.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] * (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) * ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) * ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) * ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) * ((u32)((u16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) * ((u32)((u16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) * ((u32)((u16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) * ((u32)((u16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) * ((u32)((u16)b.half[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_w_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.w.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] * (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) * ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) * ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) * ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) * ((u32)((u16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) * ((u32)((u16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) * ((u32)((u16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) * ((u32)((u16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) * ((u32)((u16)b.half[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvmulwod_w_hu_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvmulwod_w_hu_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvmulwod.w.hu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nMultiply odd-positioned unsigned 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] * (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) * ((s32)((s16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) * ((s32)((s16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) * ((s32)((s16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) * ((s32)((s16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) * ((s32)((s16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) * ((s32)((s16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) * ((s32)((s16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) * ((s32)((s16)b.half[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 2 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvmulwod_w_hu_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvmulwod.w.hu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Multiply odd-positioned unsigned 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] * (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) * ((s32)((s16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) * ((s32)((s16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) * ((s32)((s16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) * ((s32)((s16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) * ((s32)((s16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) * ((s32)((s16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) * ((s32)((s16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) * ((s32)((s16)b.half[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvneg_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvneg_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvneg.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nNegate 8-bit elements in `a` and save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = -a.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvneg_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvneg.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Negate 8-bit elements in <code>a</code> and save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = -a.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvneg_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvneg_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvneg.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nNegate 64-bit elements in `a` and save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = -a.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvneg_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvneg.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Negate 64-bit elements in <code>a</code> and save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = -a.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvneg_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvneg_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvneg.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nNegate 16-bit elements in `a` and save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = -a.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvneg_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvneg.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Negate 16-bit elements in <code>a</code> and save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = -a.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvneg_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvneg_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvneg.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nNegate 32-bit elements in `a` and save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = -a.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvneg_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvneg.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Negate 32-bit elements in <code>a</code> and save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = -a.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvnor_v (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvnor_v (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvnor.v xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise NOR between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ~(a.dword[i] | b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvnor_v (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvnor.v xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise NOR between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ~(a.dword[i] | b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvnori_b (__m256i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvnori_b (__m256i a, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvnori.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise NOR between elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ~(a.byte[i] | imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvnori_b (__m256i a, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvnori.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise NOR between elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ~(a.byte[i] | imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvor_v (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvor_v (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvor.v xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise OR between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] | b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvor_v (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvor.v xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise OR between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] | b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvori_b (__m256i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvori_b (__m256i a, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvori.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise OR between elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] | imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvori_b (__m256i a, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvori.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise OR between elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] | imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvorn_v (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvorn_v (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvorn.v xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise ORN between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] | (~b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvorn_v (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvorn.v xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise ORN between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] | (~b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpackev_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpackev_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpackev.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCollect and pack even-positioned 8-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i - 1] : b.byte[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = a.byte[0];\n  dst.byte[2] = b.byte[2];\n  dst.byte[3] = a.byte[2];\n  dst.byte[4] = b.byte[4];\n  dst.byte[5] = a.byte[4];\n  dst.byte[6] = b.byte[6];\n  dst.byte[7] = a.byte[6];\n  dst.byte[8] = b.byte[8];\n  dst.byte[9] = a.byte[8];\n  dst.byte[10] = b.byte[10];\n  dst.byte[11] = a.byte[10];\n  dst.byte[12] = b.byte[12];\n  dst.byte[13] = a.byte[12];\n  dst.byte[14] = b.byte[14];\n  dst.byte[15] = a.byte[14];\n  dst.byte[16] = b.byte[16];\n  dst.byte[17] = a.byte[16];\n  dst.byte[18] = b.byte[18];\n  dst.byte[19] = a.byte[18];\n  dst.byte[20] = b.byte[20];\n  dst.byte[21] = a.byte[20];\n  dst.byte[22] = b.byte[22];\n  dst.byte[23] = a.byte[22];\n  dst.byte[24] = b.byte[24];\n  dst.byte[25] = a.byte[24];\n  dst.byte[26] = b.byte[26];\n  dst.byte[27] = a.byte[26];\n  dst.byte[28] = b.byte[28];\n  dst.byte[29] = a.byte[28];\n  dst.byte[30] = b.byte[30];\n  dst.byte[31] = a.byte[30];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpackev_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpackev.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack even-positioned 8-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i - 1] : b.byte[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = a.byte[0];\n  dst.byte[2] = b.byte[2];\n  dst.byte[3] = a.byte[2];\n  dst.byte[4] = b.byte[4];\n  dst.byte[5] = a.byte[4];\n  dst.byte[6] = b.byte[6];\n  dst.byte[7] = a.byte[6];\n  dst.byte[8] = b.byte[8];\n  dst.byte[9] = a.byte[8];\n  dst.byte[10] = b.byte[10];\n  dst.byte[11] = a.byte[10];\n  dst.byte[12] = b.byte[12];\n  dst.byte[13] = a.byte[12];\n  dst.byte[14] = b.byte[14];\n  dst.byte[15] = a.byte[14];\n  dst.byte[16] = b.byte[16];\n  dst.byte[17] = a.byte[16];\n  dst.byte[18] = b.byte[18];\n  dst.byte[19] = a.byte[18];\n  dst.byte[20] = b.byte[20];\n  dst.byte[21] = a.byte[20];\n  dst.byte[22] = b.byte[22];\n  dst.byte[23] = a.byte[22];\n  dst.byte[24] = b.byte[24];\n  dst.byte[25] = a.byte[24];\n  dst.byte[26] = b.byte[26];\n  dst.byte[27] = a.byte[26];\n  dst.byte[28] = b.byte[28];\n  dst.byte[29] = a.byte[28];\n  dst.byte[30] = b.byte[30];\n  dst.byte[31] = a.byte[30];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpackev_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpackev_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpackev.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCollect and pack even-positioned 64-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i - 1] : b.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n  dst.dword[2] = b.dword[2];\n  dst.dword[3] = a.dword[2];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpackev_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpackev.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack even-positioned 64-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i - 1] : b.dword[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n  dst.dword[2] = b.dword[2];\n  dst.dword[3] = a.dword[2];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpackev_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpackev_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpackev.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCollect and pack even-positioned 16-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i - 1] : b.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = a.half[0];\n  dst.half[2] = b.half[2];\n  dst.half[3] = a.half[2];\n  dst.half[4] = b.half[4];\n  dst.half[5] = a.half[4];\n  dst.half[6] = b.half[6];\n  dst.half[7] = a.half[6];\n  dst.half[8] = b.half[8];\n  dst.half[9] = a.half[8];\n  dst.half[10] = b.half[10];\n  dst.half[11] = a.half[10];\n  dst.half[12] = b.half[12];\n  dst.half[13] = a.half[12];\n  dst.half[14] = b.half[14];\n  dst.half[15] = a.half[14];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpackev_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpackev.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack even-positioned 16-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i - 1] : b.half[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = a.half[0];\n  dst.half[2] = b.half[2];\n  dst.half[3] = a.half[2];\n  dst.half[4] = b.half[4];\n  dst.half[5] = a.half[4];\n  dst.half[6] = b.half[6];\n  dst.half[7] = a.half[6];\n  dst.half[8] = b.half[8];\n  dst.half[9] = a.half[8];\n  dst.half[10] = b.half[10];\n  dst.half[11] = a.half[10];\n  dst.half[12] = b.half[12];\n  dst.half[13] = a.half[12];\n  dst.half[14] = b.half[14];\n  dst.half[15] = a.half[14];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpackev_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpackev_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpackev.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCollect and pack even-positioned 32-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i - 1] : b.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = a.word[0];\n  dst.word[2] = b.word[2];\n  dst.word[3] = a.word[2];\n  dst.word[4] = b.word[4];\n  dst.word[5] = a.word[4];\n  dst.word[6] = b.word[6];\n  dst.word[7] = a.word[6];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpackev_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpackev.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack even-positioned 32-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i - 1] : b.word[i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = a.word[0];\n  dst.word[2] = b.word[2];\n  dst.word[3] = a.word[2];\n  dst.word[4] = b.word[4];\n  dst.word[5] = a.word[4];\n  dst.word[6] = b.word[6];\n  dst.word[7] = a.word[6];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpackod_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpackod_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpackod.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCollect and pack odd-positioned 8-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i] : b.byte[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[1];\n  dst.byte[1] = a.byte[1];\n  dst.byte[2] = b.byte[3];\n  dst.byte[3] = a.byte[3];\n  dst.byte[4] = b.byte[5];\n  dst.byte[5] = a.byte[5];\n  dst.byte[6] = b.byte[7];\n  dst.byte[7] = a.byte[7];\n  dst.byte[8] = b.byte[9];\n  dst.byte[9] = a.byte[9];\n  dst.byte[10] = b.byte[11];\n  dst.byte[11] = a.byte[11];\n  dst.byte[12] = b.byte[13];\n  dst.byte[13] = a.byte[13];\n  dst.byte[14] = b.byte[15];\n  dst.byte[15] = a.byte[15];\n  dst.byte[16] = b.byte[17];\n  dst.byte[17] = a.byte[17];\n  dst.byte[18] = b.byte[19];\n  dst.byte[19] = a.byte[19];\n  dst.byte[20] = b.byte[21];\n  dst.byte[21] = a.byte[21];\n  dst.byte[22] = b.byte[23];\n  dst.byte[23] = a.byte[23];\n  dst.byte[24] = b.byte[25];\n  dst.byte[25] = a.byte[25];\n  dst.byte[26] = b.byte[27];\n  dst.byte[27] = a.byte[27];\n  dst.byte[28] = b.byte[29];\n  dst.byte[29] = a.byte[29];\n  dst.byte[30] = b.byte[31];\n  dst.byte[31] = a.byte[31];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpackod_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpackod.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack odd-positioned 8-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (i % 2 == 1) ? a.byte[i] : b.byte[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[1];\n  dst.byte[1] = a.byte[1];\n  dst.byte[2] = b.byte[3];\n  dst.byte[3] = a.byte[3];\n  dst.byte[4] = b.byte[5];\n  dst.byte[5] = a.byte[5];\n  dst.byte[6] = b.byte[7];\n  dst.byte[7] = a.byte[7];\n  dst.byte[8] = b.byte[9];\n  dst.byte[9] = a.byte[9];\n  dst.byte[10] = b.byte[11];\n  dst.byte[11] = a.byte[11];\n  dst.byte[12] = b.byte[13];\n  dst.byte[13] = a.byte[13];\n  dst.byte[14] = b.byte[15];\n  dst.byte[15] = a.byte[15];\n  dst.byte[16] = b.byte[17];\n  dst.byte[17] = a.byte[17];\n  dst.byte[18] = b.byte[19];\n  dst.byte[19] = a.byte[19];\n  dst.byte[20] = b.byte[21];\n  dst.byte[21] = a.byte[21];\n  dst.byte[22] = b.byte[23];\n  dst.byte[23] = a.byte[23];\n  dst.byte[24] = b.byte[25];\n  dst.byte[25] = a.byte[25];\n  dst.byte[26] = b.byte[27];\n  dst.byte[27] = a.byte[27];\n  dst.byte[28] = b.byte[29];\n  dst.byte[29] = a.byte[29];\n  dst.byte[30] = b.byte[31];\n  dst.byte[31] = a.byte[31];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpackod_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpackod_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpackod.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCollect and pack odd-positioned 64-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i] : b.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n  dst.dword[2] = b.dword[3];\n  dst.dword[3] = a.dword[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpackod_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpackod.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack odd-positioned 64-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (i % 2 == 1) ? a.dword[i] : b.dword[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n  dst.dword[2] = b.dword[3];\n  dst.dword[3] = a.dword[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpackod_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpackod_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpackod.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCollect and pack odd-positioned 16-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i] : b.half[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[1];\n  dst.half[1] = a.half[1];\n  dst.half[2] = b.half[3];\n  dst.half[3] = a.half[3];\n  dst.half[4] = b.half[5];\n  dst.half[5] = a.half[5];\n  dst.half[6] = b.half[7];\n  dst.half[7] = a.half[7];\n  dst.half[8] = b.half[9];\n  dst.half[9] = a.half[9];\n  dst.half[10] = b.half[11];\n  dst.half[11] = a.half[11];\n  dst.half[12] = b.half[13];\n  dst.half[13] = a.half[13];\n  dst.half[14] = b.half[15];\n  dst.half[15] = a.half[15];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpackod_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpackod.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack odd-positioned 16-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (i % 2 == 1) ? a.half[i] : b.half[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[1];\n  dst.half[1] = a.half[1];\n  dst.half[2] = b.half[3];\n  dst.half[3] = a.half[3];\n  dst.half[4] = b.half[5];\n  dst.half[5] = a.half[5];\n  dst.half[6] = b.half[7];\n  dst.half[7] = a.half[7];\n  dst.half[8] = b.half[9];\n  dst.half[9] = a.half[9];\n  dst.half[10] = b.half[11];\n  dst.half[11] = a.half[11];\n  dst.half[12] = b.half[13];\n  dst.half[13] = a.half[13];\n  dst.half[14] = b.half[15];\n  dst.half[15] = a.half[15];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpackod_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpackod_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpackod.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCollect and pack odd-positioned 32-bit elements in `a` and `b` and store `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i] : b.word[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[1];\n  dst.word[1] = a.word[1];\n  dst.word[2] = b.word[3];\n  dst.word[3] = a.word[3];\n  dst.word[4] = b.word[5];\n  dst.word[5] = a.word[5];\n  dst.word[6] = b.word[7];\n  dst.word[7] = a.word[7];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpackod_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpackod.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Collect and pack odd-positioned 32-bit elements in <code>a</code> and <code>b</code> and store <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (i % 2 == 1) ? a.word[i] : b.word[i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[1];\n  dst.word[1] = a.word[1];\n  dst.word[2] = b.word[3];\n  dst.word[3] = a.word[3];\n  dst.word[4] = b.word[5];\n  dst.word[5] = a.word[5];\n  dst.word[6] = b.word[7];\n  dst.word[7] = a.word[7];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpcnt_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpcnt_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvpcnt.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount the number of ones (population, popcount) in 8-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvpcnt_b(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0202040204040602 0x0404060406060800 0x0505070202030203 0x0406040606060606\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = popcount(a.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpcnt_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpcnt.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count the number of ones (population, popcount) in 8-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpcnt_b(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0202040204040602 0x0404060406060800 0x0505070202030203 0x0406040606060606\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = popcount(a.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpcnt_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpcnt_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvpcnt.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount the number of ones (population, popcount) in 64-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvpcnt_d(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x000000000000001a 0x0000000000000026 0x000000000000001d 0x000000000000002c\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = popcount(a.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpcnt_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpcnt.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count the number of ones (population, popcount) in 64-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpcnt_d(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x000000000000001a 0x0000000000000026 0x000000000000001d 0x000000000000002c\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = popcount(a.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpcnt_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpcnt_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvpcnt.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount the number of ones (population, popcount) in 16-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvpcnt_h(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0004000600080008 0x0008000a000c0008 0x000a000900050005 0x000a000a000c000c\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = popcount(a.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpcnt_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpcnt.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count the number of ones (population, popcount) in 16-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpcnt_h(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0004000600080008 0x0008000a000c0008 0x000a000900050005 0x000a000a000c000c\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = popcount(a.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpcnt_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpcnt_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvpcnt.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCount the number of ones (population, popcount) in 32-bit elements in `a`.\n\n\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvpcnt_w(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000a00000010 0x0000001200000014 0x000000130000000a 0x0000001400000018\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = popcount(a.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpcnt_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpcnt.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Count the number of ones (population, popcount) in 32-bit elements in <code>a</code>.</p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpcnt_w(__m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee})\n= 0x0000000a00000010 0x0000001200000014 0x000000130000000a 0x0000001400000018\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = popcount(a.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Bitwise Operations", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvperm_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvperm_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvperm.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPermute words from `a` with indices recorded in `b` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[b.word[i] % 0x8];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvperm_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvperm.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Permute words from <code>a</code> with indices recorded in <code>b</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[b.word[i] % 0x8];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Permutation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpermi_d (__m256i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpermi_d (__m256i a, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvpermi.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nPermute double words from `a` with indices recorded in `imm` and store into `dst`.\n\n![](../diagram/xvpermi_d.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvpermi_d( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 0x12)\n= 0xabcdef1212341234 0x1122334455667788 0x99aabbccddeeff00 0x1122334455667788\n```\n\n\n### Operation\n\n```c++\ndst.dword[0] = a.dword[imm & 0x3];\ndst.dword[1] = a.dword[(imm >> 2) & 0x3];\ndst.dword[2] = a.dword[(imm >> 4) & 0x3];\ndst.dword[3] = a.dword[(imm >> 6) & 0x3];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpermi_d (__m256i a, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpermi.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Permute double words from <code>a</code> with indices recorded in <code>imm</code> and store into <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvpermi_d.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpermi_d( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, 0x12)\n= 0xabcdef1212341234 0x1122334455667788 0x99aabbccddeeff00 0x1122334455667788\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst.dword[0] = a.dword[imm &amp; 0x3];\ndst.dword[1] = a.dword[(imm &gt;&gt; 2) &amp; 0x3];\ndst.dword[2] = a.dword[(imm &gt;&gt; 4) &amp; 0x3];\ndst.dword[3] = a.dword[(imm &gt;&gt; 6) &amp; 0x3];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Permutation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpermi_q (__m256i a, __m256i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpermi_q (__m256i a, __m256i b, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvpermi.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nPermute quad words from `a` and `b` with indices recorded in `imm` and store into `dst`.\n\n![](../diagram/xvpermi_q.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvpermi_q( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{ 0xababababbbbbbbbb, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0x1122334455667788 0x99aabbccddeeff00 0x1234123443214321 0x5678567856785678\n```\n\n\n### Operation\n\n```c++\nif ((imm & 0x4) && (UARCH_LA264 || UARCH_LA464)) {\n  // Caveat: observed in LA264 and LA464\n  dst.qword[0] = 0;\n} else {\n  dst.qword[0] = (imm & 2) ? a.qword[imm & 0x1] : b.qword[imm & 0x1];\n}\nif ((imm & 0x80) && (UARCH_LA264 || UARCH_LA464)) {\n  // Caveat: observed in LA264 and LA464\n  dst.qword[1] = 0;\n} else {\n  dst.qword[1] =\n      (imm & 0x20) ? a.qword[(imm >> 4) & 0x1] : b.qword[(imm >> 4) & 0x1];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2.67 |\n| 3C6000 | LA664 | 3 | 2.67 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpermi_q (__m256i a, __m256i b, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpermi.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Permute quad words from <code>a</code> and <code>b</code> with indices recorded in <code>imm</code> and store into <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvpermi_q.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpermi_q( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{ 0xababababbbbbbbbb, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0x1122334455667788 0x99aabbccddeeff00 0x1234123443214321 0x5678567856785678\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">if ((imm &amp; 0x4) &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n  // Caveat: observed in LA264 and LA464\n  dst.qword[0] = 0;\n} else {\n  dst.qword[0] = (imm &amp; 2) ? a.qword[imm &amp; 0x1] : b.qword[imm &amp; 0x1];\n}\nif ((imm &amp; 0x80) &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n  // Caveat: observed in LA264 and LA464\n  dst.qword[1] = 0;\n} else {\n  dst.qword[1] =\n      (imm &amp; 0x20) ? a.qword[(imm &gt;&gt; 4) &amp; 0x1] : b.qword[(imm &gt;&gt; 4) &amp; 0x1];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2.67</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2.67</td>\n</tr>\n</tbody>\n</table>", "group": "Permutation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpermi_w (__m256i a, __m256i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpermi_w (__m256i a, __m256i b, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvpermi.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nPermute words from `a` and `b` with indices recorded in `imm` and store into `dst`.\n\n![](../diagram/xvpermi_w.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvpermi_w( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{ 0xababababbbbbbbbb, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0xbbbbbbbb43214321 0x5566778811223344 0x4321432156785678 0x12341234abcdef12\n```\n\n\n### Operation\n\n```c++\ndst.word[0] = b.word[imm & 0x3];\ndst.word[1] = b.word[(imm >> 2) & 0x3];\ndst.word[2] = a.word[(imm >> 4) & 0x3];\ndst.word[3] = a.word[(imm >> 6) & 0x3];\ndst.word[4] = b.word[4 + (imm & 0x3)];\ndst.word[5] = b.word[4 + ((imm >> 2) & 0x3)];\ndst.word[6] = a.word[4 + ((imm >> 4) & 0x3)];\ndst.word[7] = a.word[4 + ((imm >> 6) & 0x3)];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpermi_w (__m256i a, __m256i b, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpermi.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Permute words from <code>a</code> and <code>b</code> with indices recorded in <code>imm</code> and store into <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvpermi_w.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpermi_w( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{ 0xababababbbbbbbbb, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0xbbbbbbbb43214321 0x5566778811223344 0x4321432156785678 0x12341234abcdef12\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst.word[0] = b.word[imm &amp; 0x3];\ndst.word[1] = b.word[(imm &gt;&gt; 2) &amp; 0x3];\ndst.word[2] = a.word[(imm &gt;&gt; 4) &amp; 0x3];\ndst.word[3] = a.word[(imm &gt;&gt; 6) &amp; 0x3];\ndst.word[4] = b.word[4 + (imm &amp; 0x3)];\ndst.word[5] = b.word[4 + ((imm &gt;&gt; 2) &amp; 0x3)];\ndst.word[6] = a.word[4 + ((imm &gt;&gt; 4) &amp; 0x3)];\ndst.word[7] = a.word[4 + ((imm &gt;&gt; 6) &amp; 0x3)];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Permutation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickev_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickev_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpickev.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPick even-positioned 8-bit elements in `b` first, then pick even-positioned 8-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i < 8) ? b.byte[i * 2] : a.byte[(i - 8) * 2];\n}\nfor (int i = 16; i < 32; i++) {\n  dst.byte[i] = (i < 24) ? b.byte[(i - 8) * 2] : a.byte[(i - 16) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = b.byte[2];\n  dst.byte[2] = b.byte[4];\n  dst.byte[3] = b.byte[6];\n  dst.byte[4] = b.byte[8];\n  dst.byte[5] = b.byte[10];\n  dst.byte[6] = b.byte[12];\n  dst.byte[7] = b.byte[14];\n  dst.byte[8] = a.byte[0];\n  dst.byte[9] = a.byte[2];\n  dst.byte[10] = a.byte[4];\n  dst.byte[11] = a.byte[6];\n  dst.byte[12] = a.byte[8];\n  dst.byte[13] = a.byte[10];\n  dst.byte[14] = a.byte[12];\n  dst.byte[15] = a.byte[14];\n  dst.byte[16] = b.byte[16];\n  dst.byte[17] = b.byte[18];\n  dst.byte[18] = b.byte[20];\n  dst.byte[19] = b.byte[22];\n  dst.byte[20] = b.byte[24];\n  dst.byte[21] = b.byte[26];\n  dst.byte[22] = b.byte[28];\n  dst.byte[23] = b.byte[30];\n  dst.byte[24] = a.byte[16];\n  dst.byte[25] = a.byte[18];\n  dst.byte[26] = a.byte[20];\n  dst.byte[27] = a.byte[22];\n  dst.byte[28] = a.byte[24];\n  dst.byte[29] = a.byte[26];\n  dst.byte[30] = a.byte[28];\n  dst.byte[31] = a.byte[30];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickev_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickev.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick even-positioned 8-bit elements in <code>b</code> first, then pick even-positioned 8-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i &lt; 8) ? b.byte[i * 2] : a.byte[(i - 8) * 2];\n}\nfor (int i = 16; i &lt; 32; i++) {\n  dst.byte[i] = (i &lt; 24) ? b.byte[(i - 8) * 2] : a.byte[(i - 16) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[0];\n  dst.byte[1] = b.byte[2];\n  dst.byte[2] = b.byte[4];\n  dst.byte[3] = b.byte[6];\n  dst.byte[4] = b.byte[8];\n  dst.byte[5] = b.byte[10];\n  dst.byte[6] = b.byte[12];\n  dst.byte[7] = b.byte[14];\n  dst.byte[8] = a.byte[0];\n  dst.byte[9] = a.byte[2];\n  dst.byte[10] = a.byte[4];\n  dst.byte[11] = a.byte[6];\n  dst.byte[12] = a.byte[8];\n  dst.byte[13] = a.byte[10];\n  dst.byte[14] = a.byte[12];\n  dst.byte[15] = a.byte[14];\n  dst.byte[16] = b.byte[16];\n  dst.byte[17] = b.byte[18];\n  dst.byte[18] = b.byte[20];\n  dst.byte[19] = b.byte[22];\n  dst.byte[20] = b.byte[24];\n  dst.byte[21] = b.byte[26];\n  dst.byte[22] = b.byte[28];\n  dst.byte[23] = b.byte[30];\n  dst.byte[24] = a.byte[16];\n  dst.byte[25] = a.byte[18];\n  dst.byte[26] = a.byte[20];\n  dst.byte[27] = a.byte[22];\n  dst.byte[28] = a.byte[24];\n  dst.byte[29] = a.byte[26];\n  dst.byte[30] = a.byte[28];\n  dst.byte[31] = a.byte[30];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickev_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickev_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpickev.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPick even-positioned 64-bit elements in `b` first, then pick even-positioned 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i < 1) ? b.dword[i * 2] : a.dword[(i - 1) * 2];\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (i < 3) ? b.dword[(i - 1) * 2] : a.dword[(i - 2) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n  dst.dword[2] = b.dword[2];\n  dst.dword[3] = a.dword[2];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickev_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickev.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick even-positioned 64-bit elements in <code>b</code> first, then pick even-positioned 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i &lt; 1) ? b.dword[i * 2] : a.dword[(i - 1) * 2];\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (i &lt; 3) ? b.dword[(i - 1) * 2] : a.dword[(i - 2) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[0];\n  dst.dword[1] = a.dword[0];\n  dst.dword[2] = b.dword[2];\n  dst.dword[3] = a.dword[2];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickev_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickev_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpickev.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPick even-positioned 16-bit elements in `b` first, then pick even-positioned 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i < 4) ? b.half[i * 2] : a.half[(i - 4) * 2];\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] = (i < 12) ? b.half[(i - 4) * 2] : a.half[(i - 8) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = b.half[2];\n  dst.half[2] = b.half[4];\n  dst.half[3] = b.half[6];\n  dst.half[4] = a.half[0];\n  dst.half[5] = a.half[2];\n  dst.half[6] = a.half[4];\n  dst.half[7] = a.half[6];\n  dst.half[8] = b.half[8];\n  dst.half[9] = b.half[10];\n  dst.half[10] = b.half[12];\n  dst.half[11] = b.half[14];\n  dst.half[12] = a.half[8];\n  dst.half[13] = a.half[10];\n  dst.half[14] = a.half[12];\n  dst.half[15] = a.half[14];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickev_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickev.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick even-positioned 16-bit elements in <code>b</code> first, then pick even-positioned 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i &lt; 4) ? b.half[i * 2] : a.half[(i - 4) * 2];\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] = (i &lt; 12) ? b.half[(i - 4) * 2] : a.half[(i - 8) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[0];\n  dst.half[1] = b.half[2];\n  dst.half[2] = b.half[4];\n  dst.half[3] = b.half[6];\n  dst.half[4] = a.half[0];\n  dst.half[5] = a.half[2];\n  dst.half[6] = a.half[4];\n  dst.half[7] = a.half[6];\n  dst.half[8] = b.half[8];\n  dst.half[9] = b.half[10];\n  dst.half[10] = b.half[12];\n  dst.half[11] = b.half[14];\n  dst.half[12] = a.half[8];\n  dst.half[13] = a.half[10];\n  dst.half[14] = a.half[12];\n  dst.half[15] = a.half[14];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickev_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickev_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpickev.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPick even-positioned 32-bit elements in `b` first, then pick even-positioned 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? b.word[i * 2] : a.word[(i - 2) * 2];\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6) ? b.word[(i - 2) * 2] : a.word[(i - 4) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = b.word[2];\n  dst.word[2] = a.word[0];\n  dst.word[3] = a.word[2];\n  dst.word[4] = b.word[4];\n  dst.word[5] = b.word[6];\n  dst.word[6] = a.word[4];\n  dst.word[7] = a.word[6];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickev_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickev.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick even-positioned 32-bit elements in <code>b</code> first, then pick even-positioned 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? b.word[i * 2] : a.word[(i - 2) * 2];\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6) ? b.word[(i - 2) * 2] : a.word[(i - 4) * 2];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[0];\n  dst.word[1] = b.word[2];\n  dst.word[2] = a.word[0];\n  dst.word[3] = a.word[2];\n  dst.word[4] = b.word[4];\n  dst.word[5] = b.word[6];\n  dst.word[6] = a.word[4];\n  dst.word[7] = a.word[6];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickod_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickod_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpickod.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPick odd-positioned 8-bit elements in `b` first, then pick odd-positioned 8-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i < 8) ? b.byte[i * 2 + 1] : a.byte[(i - 8) * 2 + 1];\n}\nfor (int i = 16; i < 32; i++) {\n  dst.byte[i] = (i < 24) ? b.byte[(i - 8) * 2 + 1] : a.byte[(i - 16) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[1];\n  dst.byte[1] = b.byte[3];\n  dst.byte[2] = b.byte[5];\n  dst.byte[3] = b.byte[7];\n  dst.byte[4] = b.byte[9];\n  dst.byte[5] = b.byte[11];\n  dst.byte[6] = b.byte[13];\n  dst.byte[7] = b.byte[15];\n  dst.byte[8] = a.byte[1];\n  dst.byte[9] = a.byte[3];\n  dst.byte[10] = a.byte[5];\n  dst.byte[11] = a.byte[7];\n  dst.byte[12] = a.byte[9];\n  dst.byte[13] = a.byte[11];\n  dst.byte[14] = a.byte[13];\n  dst.byte[15] = a.byte[15];\n  dst.byte[16] = b.byte[17];\n  dst.byte[17] = b.byte[19];\n  dst.byte[18] = b.byte[21];\n  dst.byte[19] = b.byte[23];\n  dst.byte[20] = b.byte[25];\n  dst.byte[21] = b.byte[27];\n  dst.byte[22] = b.byte[29];\n  dst.byte[23] = b.byte[31];\n  dst.byte[24] = a.byte[17];\n  dst.byte[25] = a.byte[19];\n  dst.byte[26] = a.byte[21];\n  dst.byte[27] = a.byte[23];\n  dst.byte[28] = a.byte[25];\n  dst.byte[29] = a.byte[27];\n  dst.byte[30] = a.byte[29];\n  dst.byte[31] = a.byte[31];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickod_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickod.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick odd-positioned 8-bit elements in <code>b</code> first, then pick odd-positioned 8-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i &lt; 8) ? b.byte[i * 2 + 1] : a.byte[(i - 8) * 2 + 1];\n}\nfor (int i = 16; i &lt; 32; i++) {\n  dst.byte[i] = (i &lt; 24) ? b.byte[(i - 8) * 2 + 1] : a.byte[(i - 16) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = b.byte[1];\n  dst.byte[1] = b.byte[3];\n  dst.byte[2] = b.byte[5];\n  dst.byte[3] = b.byte[7];\n  dst.byte[4] = b.byte[9];\n  dst.byte[5] = b.byte[11];\n  dst.byte[6] = b.byte[13];\n  dst.byte[7] = b.byte[15];\n  dst.byte[8] = a.byte[1];\n  dst.byte[9] = a.byte[3];\n  dst.byte[10] = a.byte[5];\n  dst.byte[11] = a.byte[7];\n  dst.byte[12] = a.byte[9];\n  dst.byte[13] = a.byte[11];\n  dst.byte[14] = a.byte[13];\n  dst.byte[15] = a.byte[15];\n  dst.byte[16] = b.byte[17];\n  dst.byte[17] = b.byte[19];\n  dst.byte[18] = b.byte[21];\n  dst.byte[19] = b.byte[23];\n  dst.byte[20] = b.byte[25];\n  dst.byte[21] = b.byte[27];\n  dst.byte[22] = b.byte[29];\n  dst.byte[23] = b.byte[31];\n  dst.byte[24] = a.byte[17];\n  dst.byte[25] = a.byte[19];\n  dst.byte[26] = a.byte[21];\n  dst.byte[27] = a.byte[23];\n  dst.byte[28] = a.byte[25];\n  dst.byte[29] = a.byte[27];\n  dst.byte[30] = a.byte[29];\n  dst.byte[31] = a.byte[31];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickod_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickod_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpickod.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPick odd-positioned 64-bit elements in `b` first, then pick odd-positioned 64-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i < 1) ? b.dword[i * 2 + 1] : a.dword[(i - 1) * 2 + 1];\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (i < 3) ? b.dword[(i - 1) * 2 + 1] : a.dword[(i - 2) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n  dst.dword[2] = b.dword[3];\n  dst.dword[3] = a.dword[3];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickod_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickod.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick odd-positioned 64-bit elements in <code>b</code> first, then pick odd-positioned 64-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i &lt; 1) ? b.dword[i * 2 + 1] : a.dword[(i - 1) * 2 + 1];\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (i &lt; 3) ? b.dword[(i - 1) * 2 + 1] : a.dword[(i - 2) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = b.dword[1];\n  dst.dword[1] = a.dword[1];\n  dst.dword[2] = b.dword[3];\n  dst.dword[3] = a.dword[3];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickod_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickod_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpickod.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPick odd-positioned 16-bit elements in `b` first, then pick odd-positioned 16-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i < 4) ? b.half[i * 2 + 1] : a.half[(i - 4) * 2 + 1];\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] = (i < 12) ? b.half[(i - 4) * 2 + 1] : a.half[(i - 8) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[1];\n  dst.half[1] = b.half[3];\n  dst.half[2] = b.half[5];\n  dst.half[3] = b.half[7];\n  dst.half[4] = a.half[1];\n  dst.half[5] = a.half[3];\n  dst.half[6] = a.half[5];\n  dst.half[7] = a.half[7];\n  dst.half[8] = b.half[9];\n  dst.half[9] = b.half[11];\n  dst.half[10] = b.half[13];\n  dst.half[11] = b.half[15];\n  dst.half[12] = a.half[9];\n  dst.half[13] = a.half[11];\n  dst.half[14] = a.half[13];\n  dst.half[15] = a.half[15];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickod_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickod.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick odd-positioned 16-bit elements in <code>b</code> first, then pick odd-positioned 16-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i &lt; 4) ? b.half[i * 2 + 1] : a.half[(i - 4) * 2 + 1];\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] = (i &lt; 12) ? b.half[(i - 4) * 2 + 1] : a.half[(i - 8) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = b.half[1];\n  dst.half[1] = b.half[3];\n  dst.half[2] = b.half[5];\n  dst.half[3] = b.half[7];\n  dst.half[4] = a.half[1];\n  dst.half[5] = a.half[3];\n  dst.half[6] = a.half[5];\n  dst.half[7] = a.half[7];\n  dst.half[8] = b.half[9];\n  dst.half[9] = b.half[11];\n  dst.half[10] = b.half[13];\n  dst.half[11] = b.half[15];\n  dst.half[12] = a.half[9];\n  dst.half[13] = a.half[11];\n  dst.half[14] = a.half[13];\n  dst.half[15] = a.half[15];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickod_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickod_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvpickod.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nPick odd-positioned 32-bit elements in `b` first, then pick odd-positioned 32-bit elements in `a`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? b.word[i * 2 + 1] : a.word[(i - 2) * 2 + 1];\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6) ? b.word[(i - 2) * 2 + 1] : a.word[(i - 4) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[1];\n  dst.word[1] = b.word[3];\n  dst.word[2] = a.word[1];\n  dst.word[3] = a.word[3];\n  dst.word[4] = b.word[5];\n  dst.word[5] = b.word[7];\n  dst.word[6] = a.word[5];\n  dst.word[7] = a.word[7];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickod_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickod.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick odd-positioned 32-bit elements in <code>b</code> first, then pick odd-positioned 32-bit elements in <code>a</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? b.word[i * 2 + 1] : a.word[(i - 2) * 2 + 1];\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6) ? b.word[(i - 2) * 2 + 1] : a.word[(i - 4) * 2 + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = b.word[1];\n  dst.word[1] = b.word[3];\n  dst.word[2] = a.word[1];\n  dst.word[3] = a.word[3];\n  dst.word[4] = b.word[5];\n  dst.word[5] = b.word[7];\n  dst.word[6] = a.word[5];\n  dst.word[7] = a.word[7];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickve_d (__m256i a, imm0_3 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickve_d (__m256i a, imm0_3 imm)\n#include <lasxintrin.h>\nInstruction: xvpickve.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCopy one 64-bit lane from `a` specified by `imm` to the first lane of `dst`, and set the other lanes to zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (i == 0) ? a.dword[imm] : 0;\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = a.dword[imm];\n  dst.dword[1] = 0;\n  dst.dword[2] = 0;\n  dst.dword[3] = 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickve_d (__m256i a, imm0_3 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickve.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Copy one 64-bit lane from <code>a</code> specified by <code>imm</code> to the first lane of <code>dst</code>, and set the other lanes to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (i == 0) ? a.dword[imm] : 0;\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = a.dword[imm];\n  dst.dword[1] = 0;\n  dst.dword[2] = 0;\n  dst.dword[3] = 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvpickve_w (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvpickve_w (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvpickve.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCopy one 32-bit lane from `a` specified by `imm` to the first lane of `dst`, and set the other lanes to zero.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (i == 0) ? a.word[imm] : 0;\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = a.word[imm];\n  dst.word[1] = 0;\n  dst.word[2] = 0;\n  dst.word[3] = 0;\n  dst.word[4] = 0;\n  dst.word[5] = 0;\n  dst.word[6] = 0;\n  dst.word[7] = 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvpickve_w (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickve.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Copy one 32-bit lane from <code>a</code> specified by <code>imm</code> to the first lane of <code>dst</code>, and set the other lanes to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (i == 0) ? a.word[imm] : 0;\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = a.word[imm];\n  dst.word[1] = 0;\n  dst.word[2] = 0;\n  dst.word[3] = 0;\n  dst.word[4] = 0;\n  dst.word[5] = 0;\n  dst.word[6] = 0;\n  dst.word[7] = 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrepl128vei_b (__m256i a, imm0_15 idx)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrepl128vei_b (__m256i a, imm0_15 idx)\n#include <lasxintrin.h>\nInstruction: xvrepl128vei.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[idx];\n}\nfor (int i = 16; i < 32; i++) {\n  dst.byte[i] = a.byte[idx + 16];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrepl128vei_b (__m256i a, imm0_15 idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrepl128vei.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[idx];\n}\nfor (int i = 16; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[idx + 16];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrepl128vei_d (__m256i a, imm0_1 idx)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrepl128vei_d (__m256i a, imm0_1 idx)\n#include <lasxintrin.h>\nInstruction: xvrepl128vei.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[idx];\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = a.dword[idx + 2];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrepl128vei_d (__m256i a, imm0_1 idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrepl128vei.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[idx];\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[idx + 2];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrepl128vei_h (__m256i a, imm0_7 idx)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrepl128vei_h (__m256i a, imm0_7 idx)\n#include <lasxintrin.h>\nInstruction: xvrepl128vei.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[idx];\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] = a.half[idx + 8];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrepl128vei_h (__m256i a, imm0_7 idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrepl128vei.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[idx];\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] = a.half[idx + 8];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrepl128vei_w (__m256i a, imm0_3 idx)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrepl128vei_w (__m256i a, imm0_3 idx)\n#include <lasxintrin.h>\nInstruction: xvrepl128vei.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[idx];\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = a.word[idx + 4];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrepl128vei_w (__m256i a, imm0_3 idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrepl128vei.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[idx];\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = a.word[idx + 4];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplgr2vr_b (int val)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplgr2vr_b (int val)\n#include <lasxintrin.h>\nInstruction: xvreplgr2vr.b xr, r\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat `val` to whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = val;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 1 |\n| 3A6000 | LA664 | N/A | 1 |\n| 3C6000 | LA664 | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplgr2vr_b (int val)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplgr2vr.b xr, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>val</code> to whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = val;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplgr2vr_d (long int val)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplgr2vr_d (long int val)\n#include <lasxintrin.h>\nInstruction: xvreplgr2vr.d xr, r\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat `val` to whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = val;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 1 |\n| 3A6000 | LA664 | N/A | 1 |\n| 3C6000 | LA664 | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplgr2vr_d (long int val)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplgr2vr.d xr, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>val</code> to whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = val;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplgr2vr_h (int val)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplgr2vr_h (int val)\n#include <lasxintrin.h>\nInstruction: xvreplgr2vr.h xr, r\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat `val` to whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = val;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 1 |\n| 3A6000 | LA664 | N/A | 1 |\n| 3C6000 | LA664 | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplgr2vr_h (int val)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplgr2vr.h xr, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>val</code> to whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = val;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplgr2vr_w (int val)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplgr2vr_w (int val)\n#include <lasxintrin.h>\nInstruction: xvreplgr2vr.w xr, r\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat `val` to whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = val;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 1 |\n| 3A6000 | LA664 | N/A | 1 |\n| 3C6000 | LA664 | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplgr2vr_w (int val)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplgr2vr.w xr, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>val</code> to whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = val;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrepli_b (imm_n512_511 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrepli_b (imm_n512_511 imm)\n#include <lasxintrin.h>\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat `imm` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = imm;\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrepli_b (imm_n512_511 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>imm</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrepli_d (imm_n512_511 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrepli_d (imm_n512_511 imm)\n#include <lasxintrin.h>\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat `imm` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = imm;\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrepli_d (imm_n512_511 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>imm</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrepli_h (imm_n512_511 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrepli_h (imm_n512_511 imm)\n#include <lasxintrin.h>\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat `imm` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = imm;\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrepli_h (imm_n512_511 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>imm</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrepli_w (imm_n512_511 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrepli_w (imm_n512_511 imm)\n#include <lasxintrin.h>\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat `imm` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = imm;\n}\n```\n\nTested on real machine.", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrepli_w (imm_n512_511 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvldi xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat <code>imm</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve0_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve0_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvreplve0.b xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the first 8-bit lane from `a` to all lanes of `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[0];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve0_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve0.b xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the first 8-bit lane from <code>a</code> to all lanes of <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[0];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve0_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve0_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvreplve0.d xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the first 64-bit lane from `a` to all lanes of `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[0];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve0_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve0.d xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the first 64-bit lane from <code>a</code> to all lanes of <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[0];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve0_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve0_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvreplve0.h xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the first 16-bit lane from `a` to all lanes of `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[0];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve0_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve0.h xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the first 16-bit lane from <code>a</code> to all lanes of <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[0];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve0_q (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve0_q (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvreplve0.q xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the first 128-bit lane from `a` to all lanes of `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = a.qword[0];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve0_q (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve0.q xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the first 128-bit lane from <code>a</code> to all lanes of <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = a.qword[0];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve0_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve0_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvreplve0.w xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the first 32-bit lane from `a` to all lanes of `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[0];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 4 |\n| 3C6000 | LA664 | 3 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve0_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve0.w xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the first 32-bit lane from <code>a</code> to all lanes of <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[0];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve_b (__m256i a, int idx)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve_b (__m256i a, int idx)\n#include <lasxintrin.h>\nInstruction: xvreplve.b xr, xr, r\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = a.byte[idx % 16];\n}\nfor (int i = 16; i < 32; i++) {\n  dst.byte[i] = a.byte[(idx % 16) + 16];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve_b (__m256i a, int idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve.b xr, xr, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = a.byte[idx % 16];\n}\nfor (int i = 16; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[(idx % 16) + 16];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve_d (__m256i a, int idx)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve_d (__m256i a, int idx)\n#include <lasxintrin.h>\nInstruction: xvreplve.d xr, xr, r\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = a.dword[idx % 2];\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = a.dword[(idx % 2) + 2];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve_d (__m256i a, int idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve.d xr, xr, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = a.dword[idx % 2];\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[(idx % 2) + 2];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve_h (__m256i a, int idx)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve_h (__m256i a, int idx)\n#include <lasxintrin.h>\nInstruction: xvreplve.h xr, xr, r\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = a.half[idx % 8];\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] = a.half[(idx % 8) + 8];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve_h (__m256i a, int idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve.h xr, xr, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = a.half[idx % 8];\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] = a.half[(idx % 8) + 8];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvreplve_w (__m256i a, int idx)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvreplve_w (__m256i a, int idx)\n#include <lasxintrin.h>\nInstruction: xvreplve.w xr, xr, r\nCPU Flags: LASX\n```\n\n### Description\n\nRepeat the element in lane `idx` of `a` to fill whole vector.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = a.word[idx % 4];\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = a.word[(idx % 4) + 4];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvreplve_w (__m256i a, int idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvreplve.w xr, xr, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Repeat the element in lane <code>idx</code> of <code>a</code> to fill whole vector.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = a.word[idx % 4];\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = a.word[(idx % 4) + 4];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrotr_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrotr_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvrotr.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRotate right the unsigned 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] =\n      (a.byte[i] >> (b.byte[i] & 0x7)) | (a.byte[i] << (8 - (b.byte[i] & 0x7)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrotr_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrotr.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] =\n      (a.byte[i] &gt;&gt; (b.byte[i] &amp; 0x7)) | (a.byte[i] &lt;&lt; (8 - (b.byte[i] &amp; 0x7)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrotr_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrotr_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvrotr.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRotate right the unsigned 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (a.dword[i] >> (b.dword[i] & 0x3f)) |\n                 (a.dword[i] << (64 - (b.dword[i] & 0x3f)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrotr_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrotr.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (a.dword[i] &gt;&gt; (b.dword[i] &amp; 0x3f)) |\n                 (a.dword[i] &lt;&lt; (64 - (b.dword[i] &amp; 0x3f)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrotr_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrotr_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvrotr.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRotate right the unsigned 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (a.half[i] >> (b.half[i] & 0xf)) |\n                (a.half[i] << (16 - (b.half[i] & 0xf)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrotr_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrotr.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (a.half[i] &gt;&gt; (b.half[i] &amp; 0xf)) |\n                (a.half[i] &lt;&lt; (16 - (b.half[i] &amp; 0xf)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrotr_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrotr_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvrotr.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nRotate right the unsigned 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (a.word[i] >> (b.word[i] & 0x1f)) |\n                (a.word[i] << (32 - (b.word[i] & 0x1f)));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrotr_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrotr.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (a.word[i] &gt;&gt; (b.word[i] &amp; 0x1f)) |\n                (a.word[i] &lt;&lt; (32 - (b.word[i] &amp; 0x1f)));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrotri_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrotri_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvrotri.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRotate right the unsigned 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (a.byte[i] >> imm) | (a.byte[i] << (8 - imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrotri_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrotri.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (a.byte[i] &gt;&gt; imm) | (a.byte[i] &lt;&lt; (8 - imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrotri_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrotri_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvrotri.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRotate right the unsigned 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (a.dword[i] >> imm) | (a.dword[i] << (64 - imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrotri_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrotri.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (a.dword[i] &gt;&gt; imm) | (a.dword[i] &lt;&lt; (64 - imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrotri_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrotri_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvrotri.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRotate right the unsigned 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (a.half[i] >> imm) | (a.half[i] << (16 - imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrotri_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrotri.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (a.half[i] &gt;&gt; imm) | (a.half[i] &lt;&lt; (16 - imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvrotri_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvrotri_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvrotri.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nRotate right the unsigned 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (a.word[i] >> imm) | (a.word[i] << (32 - imm));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvrotri_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvrotri.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Rotate right the unsigned 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (a.word[i] &gt;&gt; imm) | (a.word[i] &lt;&lt; (32 - imm));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsadd_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsadd_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsadd.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating add the signed 8-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (s8)sadd((s8)a.byte[i], (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsadd_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsadd.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the signed 8-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (s8)sadd((s8)a.byte[i], (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsadd_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsadd_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsadd.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating add the unsigned 8-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (u8)sadd((u8)a.byte[i], (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsadd_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsadd.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the unsigned 8-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (u8)sadd((u8)a.byte[i], (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsadd_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsadd_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsadd.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating add the signed 64-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)sadd((s64)a.dword[i], (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsadd_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsadd.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the signed 64-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)sadd((s64)a.dword[i], (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsadd_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsadd_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsadd.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating add the unsigned 64-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)sadd((u64)a.dword[i], (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsadd_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsadd.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the unsigned 64-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)sadd((u64)a.dword[i], (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsadd_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsadd_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsadd.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating add the signed 16-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)sadd((s16)a.half[i], (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsadd_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsadd.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the signed 16-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)sadd((s16)a.half[i], (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsadd_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsadd_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsadd.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating add the unsigned 16-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)sadd((u16)a.half[i], (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsadd_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsadd.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the unsigned 16-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)sadd((u16)a.half[i], (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsadd_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsadd_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsadd.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating add the signed 32-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)sadd((s32)a.word[i], (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsadd_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsadd.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the signed 32-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)sadd((s32)a.word[i], (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsadd_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsadd_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsadd.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating add the unsigned 32-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)sadd((u32)a.word[i], (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsadd_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsadd.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating add the unsigned 32-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)sadd((u32)a.word[i], (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsat_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsat_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvsat.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClamp signed 8-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = clamp<s8>(a.byte[i], -(1 << imm), (1 << imm) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsat_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsat.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp signed 8-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = clamp&lt;s8&gt;(a.byte[i], -(1 &lt;&lt; imm), (1 &lt;&lt; imm) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsat_bu (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsat_bu (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvsat.bu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClamp unsigned 8-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = clamp<u8>(a.byte[i], 0, (1 << (imm + 1)) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsat_bu (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsat.bu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp unsigned 8-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = clamp&lt;u8&gt;(a.byte[i], 0, (1 &lt;&lt; (imm + 1)) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsat_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsat_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsat.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClamp signed 64-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = clamp<s64>(a.dword[i], -(1 << imm), (1 << imm) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsat_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsat.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp signed 64-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = clamp&lt;s64&gt;(a.dword[i], -(1 &lt;&lt; imm), (1 &lt;&lt; imm) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsat_du (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsat_du (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsat.du xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClamp unsigned 64-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = clamp<u64>(a.dword[i], 0, (1 << (imm + 1)) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsat_du (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsat.du xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp unsigned 64-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = clamp&lt;u64&gt;(a.dword[i], 0, (1 &lt;&lt; (imm + 1)) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsat_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsat_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsat.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClamp signed 16-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = clamp<s16>(a.half[i], -(1 << imm), (1 << imm) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsat_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsat.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp signed 16-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = clamp&lt;s16&gt;(a.half[i], -(1 &lt;&lt; imm), (1 &lt;&lt; imm) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsat_hu (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsat_hu (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsat.hu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClamp unsigned 16-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = clamp<u16>(a.half[i], 0, (1 << (imm + 1)) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsat_hu (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsat.hu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp unsigned 16-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = clamp&lt;u16&gt;(a.half[i], 0, (1 &lt;&lt; (imm + 1)) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsat_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsat_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsat.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClamp signed 32-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = clamp<s32>(a.word[i], -(1 << imm), (1 << imm) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsat_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsat.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp signed 32-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = clamp&lt;s32&gt;(a.word[i], -(1 &lt;&lt; imm), (1 &lt;&lt; imm) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsat_wu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsat_wu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsat.wu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nClamp unsigned 32-bit elements in `a` to range specified by `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = clamp<u32>(a.word[i], 0, (1 << (imm + 1)) - 1);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsat_wu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsat.wu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Clamp unsigned 32-bit elements in <code>a</code> to range specified by <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = clamp&lt;u32&gt;(a.word[i], 0, (1 &lt;&lt; (imm + 1)) - 1);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvseq_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvseq_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvseq.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the 8-bit elements in `a` and `b`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (a.byte[i] == b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvseq_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseq.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (a.byte[i] == b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvseq_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvseq_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvseq.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the 64-bit elements in `a` and `b`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (a.dword[i] == b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvseq_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseq.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (a.dword[i] == b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvseq_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvseq_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvseq.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the 16-bit elements in `a` and `b`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (a.half[i] == b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvseq_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseq.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (a.half[i] == b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvseq_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvseq_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvseq.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the 32-bit elements in `a` and `b`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (a.word[i] == b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvseq_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseq.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (a.word[i] == b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvseqi_b (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvseqi_b (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvseqi.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the 8-bit elements in `a` and `imm`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] == imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvseqi_b (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseqi.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] == imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvseqi_d (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvseqi_d (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvseqi.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the 64-bit elements in `a` and `imm`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] == imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvseqi_d (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseqi.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] == imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvseqi_h (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvseqi_h (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvseqi.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the 16-bit elements in `a` and `imm`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i] == imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvseqi_h (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseqi.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i] == imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvseqi_w (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvseqi_w (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvseqi.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the 32-bit elements in `a` and `imm`, store all-ones to `dst` if equal, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i] == imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvseqi_w (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseqi.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if equal, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i] == imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvshuf4i_b (__m256i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvshuf4i_b (__m256i a, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvshuf4i.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nShuffle every four 8-bit elements in `a` with indices packed in `imm`, save the result to `dst`.\n\n![](../diagram/xvshuf4i_b.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvshuf4i_b( __m256i{ 0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0x13ef13cd78667815 0x3412343421432121 0x3412343421432121 0x7856787878567878\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[(i & ~0x3) + ((imm >> (2 * (i & 0x3))) & 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = a.byte[0 + ((imm >> 0) & 0x3)];\n  dst.byte[1] = a.byte[0 + ((imm >> 2) & 0x3)];\n  dst.byte[2] = a.byte[0 + ((imm >> 4) & 0x3)];\n  dst.byte[3] = a.byte[0 + ((imm >> 6) & 0x3)];\n  dst.byte[4] = a.byte[4 + ((imm >> 0) & 0x3)];\n  dst.byte[5] = a.byte[4 + ((imm >> 2) & 0x3)];\n  dst.byte[6] = a.byte[4 + ((imm >> 4) & 0x3)];\n  dst.byte[7] = a.byte[4 + ((imm >> 6) & 0x3)];\n  dst.byte[8] = a.byte[8 + ((imm >> 0) & 0x3)];\n  dst.byte[9] = a.byte[8 + ((imm >> 2) & 0x3)];\n  dst.byte[10] = a.byte[8 + ((imm >> 4) & 0x3)];\n  dst.byte[11] = a.byte[8 + ((imm >> 6) & 0x3)];\n  dst.byte[12] = a.byte[12 + ((imm >> 0) & 0x3)];\n  dst.byte[13] = a.byte[12 + ((imm >> 2) & 0x3)];\n  dst.byte[14] = a.byte[12 + ((imm >> 4) & 0x3)];\n  dst.byte[15] = a.byte[12 + ((imm >> 6) & 0x3)];\n  dst.byte[16] = a.byte[16 + ((imm >> 0) & 0x3)];\n  dst.byte[17] = a.byte[16 + ((imm >> 2) & 0x3)];\n  dst.byte[18] = a.byte[16 + ((imm >> 4) & 0x3)];\n  dst.byte[19] = a.byte[16 + ((imm >> 6) & 0x3)];\n  dst.byte[20] = a.byte[20 + ((imm >> 0) & 0x3)];\n  dst.byte[21] = a.byte[20 + ((imm >> 2) & 0x3)];\n  dst.byte[22] = a.byte[20 + ((imm >> 4) & 0x3)];\n  dst.byte[23] = a.byte[20 + ((imm >> 6) & 0x3)];\n  dst.byte[24] = a.byte[24 + ((imm >> 0) & 0x3)];\n  dst.byte[25] = a.byte[24 + ((imm >> 2) & 0x3)];\n  dst.byte[26] = a.byte[24 + ((imm >> 4) & 0x3)];\n  dst.byte[27] = a.byte[24 + ((imm >> 6) & 0x3)];\n  dst.byte[28] = a.byte[28 + ((imm >> 0) & 0x3)];\n  dst.byte[29] = a.byte[28 + ((imm >> 2) & 0x3)];\n  dst.byte[30] = a.byte[28 + ((imm >> 4) & 0x3)];\n  dst.byte[31] = a.byte[28 + ((imm >> 6) & 0x3)];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf4i_b (__m256i a, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvshuf4i.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle every four 8-bit elements in <code>a</code> with indices packed in <code>imm</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvshuf4i_b.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf4i_b( __m256i{ 0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0x13ef13cd78667815 0x3412343421432121 0x3412343421432121 0x7856787878567878\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[(i &amp; ~0x3) + ((imm &gt;&gt; (2 * (i &amp; 0x3))) &amp; 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.byte[0] = a.byte[0 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[1] = a.byte[0 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[2] = a.byte[0 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[3] = a.byte[0 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[4] = a.byte[4 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[5] = a.byte[4 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[6] = a.byte[4 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[7] = a.byte[4 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[8] = a.byte[8 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[9] = a.byte[8 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[10] = a.byte[8 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[11] = a.byte[8 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[12] = a.byte[12 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[13] = a.byte[12 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[14] = a.byte[12 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[15] = a.byte[12 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[16] = a.byte[16 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[17] = a.byte[16 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[18] = a.byte[16 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[19] = a.byte[16 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[20] = a.byte[20 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[21] = a.byte[20 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[22] = a.byte[20 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[23] = a.byte[20 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[24] = a.byte[24 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[25] = a.byte[24 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[26] = a.byte[24 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[27] = a.byte[24 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.byte[28] = a.byte[28 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.byte[29] = a.byte[28 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.byte[30] = a.byte[28 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.byte[31] = a.byte[28 + ((imm &gt;&gt; 6) &amp; 0x3)];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvshuf4i_d (__m256i a, __m256i b, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvshuf4i_d (__m256i a, __m256i b, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvshuf4i.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nShuffle every four 64-bit elements in `a` and `b` with indices packed in `imm`, save the result to `dst`.\n\n![](../diagram/xvshuf4i_d.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvshuf4i_d( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{ 0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0xabcdef1314156678 0x1122334455667788 0x1234123443214321 0xabcdef1212341234\n```\n\n\n### Operation\n\n```c++\ndst.dword[0] = (imm & 2) ? b.dword[(imm & 1)] : a.dword[(imm & 1)];\ndst.dword[1] =\n    (imm & 8) ? b.dword[((imm >> 2) & 1)] : a.dword[((imm >> 2) & 1)];\ndst.dword[2] = (imm & 2) ? b.dword[(imm & 1) + 2] : a.dword[(imm & 1) + 2];\ndst.dword[3] =\n    (imm & 8) ? b.dword[((imm >> 2) & 1) + 2] : a.dword[((imm >> 2) & 1) + 2];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf4i_d (__m256i a, __m256i b, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvshuf4i.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle every four 64-bit elements in <code>a</code> and <code>b</code> with indices packed in <code>imm</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvshuf4i_d.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf4i_d( __m256i{ 0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{ 0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0xabcdef1314156678 0x1122334455667788 0x1234123443214321 0xabcdef1212341234\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst.dword[0] = (imm &amp; 2) ? b.dword[(imm &amp; 1)] : a.dword[(imm &amp; 1)];\ndst.dword[1] =\n    (imm &amp; 8) ? b.dword[((imm &gt;&gt; 2) &amp; 1)] : a.dword[((imm &gt;&gt; 2) &amp; 1)];\ndst.dword[2] = (imm &amp; 2) ? b.dword[(imm &amp; 1) + 2] : a.dword[(imm &amp; 1) + 2];\ndst.dword[3] =\n    (imm &amp; 8) ? b.dword[((imm &gt;&gt; 2) &amp; 1) + 2] : a.dword[((imm &gt;&gt; 2) &amp; 1) + 2];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvshuf4i_h (__m256i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvshuf4i_h (__m256i a, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvshuf4i.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nShuffle every four 16-bit elements in `a` with indices packed in `imm`, save the result to `dst`.\n\n![](../diagram/xvshuf4i_h.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvshuf4i_h( __m256i{ 0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0x667814156678ef13 0x4321432143211234 0x4321432143211234 0x5678567856785678\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[(i & ~0x3) + ((imm >> (2 * (i & 0x3))) & 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = a.half[0 + ((imm >> 0) & 0x3)];\n  dst.half[1] = a.half[0 + ((imm >> 2) & 0x3)];\n  dst.half[2] = a.half[0 + ((imm >> 4) & 0x3)];\n  dst.half[3] = a.half[0 + ((imm >> 6) & 0x3)];\n  dst.half[4] = a.half[4 + ((imm >> 0) & 0x3)];\n  dst.half[5] = a.half[4 + ((imm >> 2) & 0x3)];\n  dst.half[6] = a.half[4 + ((imm >> 4) & 0x3)];\n  dst.half[7] = a.half[4 + ((imm >> 6) & 0x3)];\n  dst.half[8] = a.half[8 + ((imm >> 0) & 0x3)];\n  dst.half[9] = a.half[8 + ((imm >> 2) & 0x3)];\n  dst.half[10] = a.half[8 + ((imm >> 4) & 0x3)];\n  dst.half[11] = a.half[8 + ((imm >> 6) & 0x3)];\n  dst.half[12] = a.half[12 + ((imm >> 0) & 0x3)];\n  dst.half[13] = a.half[12 + ((imm >> 2) & 0x3)];\n  dst.half[14] = a.half[12 + ((imm >> 4) & 0x3)];\n  dst.half[15] = a.half[12 + ((imm >> 6) & 0x3)];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf4i_h (__m256i a, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvshuf4i.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle every four 16-bit elements in <code>a</code> with indices packed in <code>imm</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvshuf4i_h.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf4i_h( __m256i{ 0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0x667814156678ef13 0x4321432143211234 0x4321432143211234 0x5678567856785678\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[(i &amp; ~0x3) + ((imm &gt;&gt; (2 * (i &amp; 0x3))) &amp; 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = a.half[0 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.half[1] = a.half[0 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.half[2] = a.half[0 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.half[3] = a.half[0 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.half[4] = a.half[4 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.half[5] = a.half[4 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.half[6] = a.half[4 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.half[7] = a.half[4 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.half[8] = a.half[8 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.half[9] = a.half[8 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.half[10] = a.half[8 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.half[11] = a.half[8 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.half[12] = a.half[12 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.half[13] = a.half[12 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.half[14] = a.half[12 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.half[15] = a.half[12 + ((imm &gt;&gt; 6) &amp; 0x3)];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvshuf4i_w (__m256i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvshuf4i_w (__m256i a, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvshuf4i.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nShuffle every four 32-bit elements in `a` with indices packed in `imm`, save the result to `dst`.\n\n![](../diagram/xvshuf4i_w.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvshuf4i_w( __m256i{ 0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0x1415667843214321 0x14156678abcdef13 0x4321432156785678 0x4321432112341234\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[(i & ~0x3) + ((imm >> (2 * (i & 0x3))) & 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = a.word[0 + ((imm >> 0) & 0x3)];\n  dst.word[1] = a.word[0 + ((imm >> 2) & 0x3)];\n  dst.word[2] = a.word[0 + ((imm >> 4) & 0x3)];\n  dst.word[3] = a.word[0 + ((imm >> 6) & 0x3)];\n  dst.word[4] = a.word[4 + ((imm >> 0) & 0x3)];\n  dst.word[5] = a.word[4 + ((imm >> 2) & 0x3)];\n  dst.word[6] = a.word[4 + ((imm >> 4) & 0x3)];\n  dst.word[7] = a.word[4 + ((imm >> 6) & 0x3)];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf4i_w (__m256i a, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvshuf4i.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle every four 32-bit elements in <code>a</code> with indices packed in <code>imm</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvshuf4i_w.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf4i_w( __m256i{ 0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, 0x12)\n= 0x1415667843214321 0x14156678abcdef13 0x4321432156785678 0x4321432112341234\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[(i &amp; ~0x3) + ((imm &gt;&gt; (2 * (i &amp; 0x3))) &amp; 0x3)];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = a.word[0 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.word[1] = a.word[0 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.word[2] = a.word[0 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.word[3] = a.word[0 + ((imm &gt;&gt; 6) &amp; 0x3)];\n  dst.word[4] = a.word[4 + ((imm &gt;&gt; 0) &amp; 0x3)];\n  dst.word[5] = a.word[4 + ((imm &gt;&gt; 2) &amp; 0x3)];\n  dst.word[6] = a.word[4 + ((imm &gt;&gt; 4) &amp; 0x3)];\n  dst.word[7] = a.word[4 + ((imm &gt;&gt; 6) &amp; 0x3)];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvshuf_b (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvshuf_b (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvshuf.b xr, xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\n\nShuffle bytes from `a` and `b` with indices from `c`.\n\nCaveat: the indices are placed in `c`, while in other `vshuf` intrinsics, they are placed in `a`.\n\n\n![](../diagram/xvshuf_b.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvshuf_b(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, __m256i{0x1f1f00001a0a1b0b, 0x1111120213031404, 0x0102030405060708, 0x1112131405060708})\n= 0x99997878ee21dd43 0x7777661555144413 0x4321433412341278 0x1234121212341278\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  if ((c.byte[i] % 256) >= 64 && (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.byte[i] = 0;\n  } else if ((c.byte[i] % 32) < 16) {\n    dst.byte[i] = b.byte[(c.byte[i] % 32) + ((i >= 16) ? 16 : 0)];\n  } else {\n    dst.byte[i] = a.byte[(c.byte[i] % 32) + ((i >= 16) ? 0 : -16)];\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf_b (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvshuf.b xr, xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle bytes from <code>a</code> and <code>b</code> with indices from <code>c</code>.</p>\n<p>Caveat: the indices are placed in <code>c</code>, while in other <code>vshuf</code> intrinsics, they are placed in <code>a</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvshuf_b.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf_b(__m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678}, __m256i{0x1f1f00001a0a1b0b, 0x1111120213031404, 0x0102030405060708, 0x1112131405060708})\n= 0x99997878ee21dd43 0x7777661555144413 0x4321433412341278 0x1234121212341278\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  if ((c.byte[i] % 256) &gt;= 64 &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.byte[i] = 0;\n  } else if ((c.byte[i] % 32) &lt; 16) {\n    dst.byte[i] = b.byte[(c.byte[i] % 32) + ((i &gt;= 16) ? 16 : 0)];\n  } else {\n    dst.byte[i] = a.byte[(c.byte[i] % 32) + ((i &gt;= 16) ? 0 : -16)];\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvshuf_d (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvshuf_d (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvshuf.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nShuffle 64-bit elements in `b` and `c` with indices from `a`, save the result to `dst`.\n\n![](../diagram/xvshuf_d.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvshuf_d(__m256i{0x0000000000000000, 0x0000000000000003, 0x0000000000000002, 0x0000000000000001}, __m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xabcdef1314156678 0x99aabbccddeeff00 0xabcdef1212341234 0x5678567856785678\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if ((a.dword[i] % 256) >= 64 && (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.dword[i] = 0;\n  } else if ((a.dword[i] % 4) < 2) {\n    dst.dword[i] = c.dword[(a.dword[i] % 4) + ((i >= 2) ? 2 : 0)];\n  } else {\n    dst.dword[i] = b.dword[(a.dword[i] % 4) + ((i >= 2) ? 0 : -2)];\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf_d (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvshuf.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle 64-bit elements in <code>b</code> and <code>c</code> with indices from <code>a</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvshuf_d.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf_d(__m256i{0x0000000000000000, 0x0000000000000003, 0x0000000000000002, 0x0000000000000001}, __m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0xabcdef1314156678 0x99aabbccddeeff00 0xabcdef1212341234 0x5678567856785678\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if ((a.dword[i] % 256) &gt;= 64 &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.dword[i] = 0;\n  } else if ((a.dword[i] % 4) &lt; 2) {\n    dst.dword[i] = c.dword[(a.dword[i] % 4) + ((i &gt;= 2) ? 2 : 0)];\n  } else {\n    dst.dword[i] = b.dword[(a.dword[i] % 4) + ((i &gt;= 2) ? 0 : -2)];\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvshuf_h (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvshuf_h (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvshuf.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nShuffle 16-bit elements in `b` and `c` with indices from `a`, save the result to `dst`.\n\n![](../diagram/xvshuf_h.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvshuf_h(__m256i{0x0001000200030004, 0x0005000a000b000c, 0x000f000e00010002, 0x0008000900020001}, __m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x1415ef13abcd4321 0x432133441122ff00 0xaabbaabb43211234 0x1234123412344321\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if ((a.half[i] % 256) >= 64 && (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.half[i] = 0;\n  } else if ((a.half[i] % 16) < 8) {\n    dst.half[i] = c.half[(a.half[i] % 16) + ((i >= 8) ? 8 : 0)];\n  } else {\n    dst.half[i] = b.half[(a.half[i] % 16) + ((i >= 8) ? 0 : -8)];\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf_h (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvshuf.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle 16-bit elements in <code>b</code> and <code>c</code> with indices from <code>a</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvshuf_h.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf_h(__m256i{0x0001000200030004, 0x0005000a000b000c, 0x000f000e00010002, 0x0008000900020001}, __m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x1415ef13abcd4321 0x432133441122ff00 0xaabbaabb43211234 0x1234123412344321\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if ((a.half[i] % 256) &gt;= 64 &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.half[i] = 0;\n  } else if ((a.half[i] % 16) &lt; 8) {\n    dst.half[i] = c.half[(a.half[i] % 16) + ((i &gt;= 8) ? 8 : 0)];\n  } else {\n    dst.half[i] = b.half[(a.half[i] % 16) + ((i &gt;= 8) ? 0 : -8)];\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvshuf_w (__m256i a, __m256i b, __m256i c)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvshuf_w (__m256i a, __m256i b, __m256i c)\n#include <lasxintrin.h>\nInstruction: xvshuf.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nShuffle 32-bit elements in `b` and `c` with indices from `a`, save the result to `dst`.\n\n![](../diagram/xvshuf_w.svg)\n\n\n### Examples\n\n```c++\n__m256i __lasx_xvshuf_w(__m256i{0x0000000200000004, 0x0000000700000005, 0x0000000100000003, 0x0000000400000000}, __m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x4321432155667788 0x99aabbcc11223344 0x1234123456785678 0x1234123443214321\n```\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if ((a.word[i] % 256) >= 64 && (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.word[i] = 0;\n  } else if ((a.word[i] % 8) < 4) {\n    dst.word[i] = c.word[(a.word[i] % 8) + ((i >= 4) ? 4 : 0)];\n  } else {\n    dst.word[i] = b.word[(a.word[i] % 8) + ((i >= 4) ? 0 : -4)];\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf_w (__m256i a, __m256i b, __m256i c)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvshuf.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Shuffle 32-bit elements in <code>b</code> and <code>c</code> with indices from <code>a</code>, save the result to <code>dst</code>.</p>\n<p><img alt=\"\" src=\"../diagram/xvshuf_w.svg\" /></p>\n<h3>Examples</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvshuf_w(__m256i{0x0000000200000004, 0x0000000700000005, 0x0000000100000003, 0x0000000400000000}, __m256i{0x1122334455667788, 0x99aabbccddeeff00, 0xabcdef1212341234, 0xaabbaabbddeeddee}, __m256i{0xabcdef1314156678, 0x1234123443214321, 0x1234123443214321, 0x5678567856785678})\n= 0x4321432155667788 0x99aabbcc11223344 0x1234123456785678 0x1234123443214321\n</code></pre>\n\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if ((a.word[i] % 256) &gt;= 64 &amp;&amp; (UARCH_LA264 || UARCH_LA464)) {\n    // Caveat: observed in LA264 and LA464\n    dst.word[i] = 0;\n  } else if ((a.word[i] % 8) &lt; 4) {\n    dst.word[i] = c.word[(a.word[i] % 8) + ((i &gt;= 4) ? 4 : 0)];\n  } else {\n    dst.word[i] = b.word[(a.word[i] % 8) + ((i &gt;= 4) ? 0 : -4)];\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shuffling", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsigncov_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsigncov_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsigncov.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nIf the 8-bit element in `a` equals to zero, set the result to zero. If the signed 8-bit element in `a` is positive, copy element in `b` to result. Otherwise, copy negated element in `b` to result. If `a` and `b` are the same vectors, it is equivalent to computing absolute value.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] =\n      (a.byte[i] == 0) ? 0 : ((s8)a.byte[i] > 0 ? b.byte[i] : -b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsigncov_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsigncov.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>If the 8-bit element in <code>a</code> equals to zero, set the result to zero. If the signed 8-bit element in <code>a</code> is positive, copy element in <code>b</code> to result. Otherwise, copy negated element in <code>b</code> to result. If <code>a</code> and <code>b</code> are the same vectors, it is equivalent to computing absolute value.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] =\n      (a.byte[i] == 0) ? 0 : ((s8)a.byte[i] &gt; 0 ? b.byte[i] : -b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsigncov_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsigncov_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsigncov.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nIf the 64-bit element in `a` equals to zero, set the result to zero. If the signed 64-bit element in `a` is positive, copy element in `b` to result. Otherwise, copy negated element in `b` to result. If `a` and `b` are the same vectors, it is equivalent to computing absolute value.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] =\n      (a.dword[i] == 0) ? 0 : ((s64)a.dword[i] > 0 ? b.dword[i] : -b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsigncov_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsigncov.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>If the 64-bit element in <code>a</code> equals to zero, set the result to zero. If the signed 64-bit element in <code>a</code> is positive, copy element in <code>b</code> to result. Otherwise, copy negated element in <code>b</code> to result. If <code>a</code> and <code>b</code> are the same vectors, it is equivalent to computing absolute value.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] =\n      (a.dword[i] == 0) ? 0 : ((s64)a.dword[i] &gt; 0 ? b.dword[i] : -b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsigncov_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsigncov_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsigncov.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nIf the 16-bit element in `a` equals to zero, set the result to zero. If the signed 16-bit element in `a` is positive, copy element in `b` to result. Otherwise, copy negated element in `b` to result. If `a` and `b` are the same vectors, it is equivalent to computing absolute value.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] =\n      (a.half[i] == 0) ? 0 : ((s16)a.half[i] > 0 ? b.half[i] : -b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsigncov_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsigncov.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>If the 16-bit element in <code>a</code> equals to zero, set the result to zero. If the signed 16-bit element in <code>a</code> is positive, copy element in <code>b</code> to result. Otherwise, copy negated element in <code>b</code> to result. If <code>a</code> and <code>b</code> are the same vectors, it is equivalent to computing absolute value.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] =\n      (a.half[i] == 0) ? 0 : ((s16)a.half[i] &gt; 0 ? b.half[i] : -b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsigncov_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsigncov_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsigncov.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nIf the 32-bit element in `a` equals to zero, set the result to zero. If the signed 32-bit element in `a` is positive, copy element in `b` to result. Otherwise, copy negated element in `b` to result. If `a` and `b` are the same vectors, it is equivalent to computing absolute value.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] =\n      (a.word[i] == 0) ? 0 : ((s32)a.word[i] > 0 ? b.word[i] : -b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 2 |\n| 3C6000 | LA664 | 1 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsigncov_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsigncov.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>If the 32-bit element in <code>a</code> equals to zero, set the result to zero. If the signed 32-bit element in <code>a</code> is positive, copy element in <code>b</code> to result. Otherwise, copy negated element in <code>b</code> to result. If <code>a</code> and <code>b</code> are the same vectors, it is equivalent to computing absolute value.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] =\n      (a.word[i] == 0) ? 0 : ((s32)a.word[i] &gt; 0 ? b.word[i] : -b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsle_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsle_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsle.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 8-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] <= (s8)b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsle_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsle.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &lt;= (s8)b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsle_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsle_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsle.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 8-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] <= (u8)b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsle_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsle.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &lt;= (u8)b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsle_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsle_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsle.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 64-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] <= (s64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsle_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsle.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &lt;= (s64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsle_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsle_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsle.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 64-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] <= (u64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsle_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsle.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &lt;= (u64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsle_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsle_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsle.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 16-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i] <= (s16)b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsle_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsle.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i] &lt;= (s16)b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsle_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsle_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsle.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 16-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((u16)a.half[i] <= (u16)b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsle_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsle.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((u16)a.half[i] &lt;= (u16)b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsle_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsle_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsle.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 32-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i] <= (s32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsle_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsle.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i] &lt;= (s32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsle_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsle_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsle.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 32-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((u32)a.word[i] <= (u32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsle_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsle.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((u32)a.word[i] &lt;= (u32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslei_b (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslei_b (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslei.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 8-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] <= imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslei_b (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslei.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &lt;= imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslei_bu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslei_bu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslei.bu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 8-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] <= imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslei_bu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslei.bu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &lt;= imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslei_d (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslei_d (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslei.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 64-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] <= imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslei_d (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslei.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &lt;= imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslei_du (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslei_du (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslei.du xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 64-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] <= imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslei_du (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslei.du xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &lt;= imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslei_h (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslei_h (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslei.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 16-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i] <= imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslei_h (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslei.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i] &lt;= imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslei_hu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslei_hu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslei.hu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 16-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((u16)a.half[i] <= imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslei_hu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslei.hu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((u16)a.half[i] &lt;= imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslei_w (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslei_w (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslei.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 32-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i] <= imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslei_w (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslei.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i] &lt;= imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslei_wu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslei_wu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslei.wu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 32-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than or equal to `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((u32)a.word[i] <= imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslei_wu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslei.wu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than or equal to <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((u32)a.word[i] &lt;= imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsll_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsll_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsll.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical left shift the unsigned 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] << (b.byte[i] & 0x7);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsll_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsll.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] &lt;&lt; (b.byte[i] &amp; 0x7);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsll_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsll_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsll.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical left shift the unsigned 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] << (b.dword[i] & 0x3f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsll_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsll.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] &lt;&lt; (b.dword[i] &amp; 0x3f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsll_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsll_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsll.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical left shift the unsigned 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] << (b.half[i] & 0xf);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsll_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsll.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] &lt;&lt; (b.half[i] &amp; 0xf);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsll_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsll_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsll.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical left shift the unsigned 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] << (b.word[i] & 0x1f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsll_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsll.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] &lt;&lt; (b.word[i] &amp; 0x1f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslli_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslli_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvslli.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical left shift the unsigned 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslli_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslli.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslli_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslli_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvslli.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical left shift the unsigned 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslli_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslli.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslli_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslli_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslli.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical left shift the unsigned 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslli_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslli.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslli_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslli_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslli.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical left shift the unsigned 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslli_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslli.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical left shift the unsigned 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsllwil_d_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsllwil_d_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsllwil.d.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtend and shift signed 32-bit elements in `a` by `imm` to signed 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i] << imm;\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i + 2] << imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) << imm;\n  dst.dword[1] = ((s64)((s32)a.word[1])) << imm;\n  dst.dword[2] = ((s64)((s32)a.word[4])) << imm;\n  dst.dword[3] = ((s64)((s32)a.word[5])) << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsllwil_d_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsllwil.d.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift signed 32-bit elements in <code>a</code> by <code>imm</code> to signed 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i] &lt;&lt; imm;\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[i + 2] &lt;&lt; imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) &lt;&lt; imm;\n  dst.dword[1] = ((s64)((s32)a.word[1])) &lt;&lt; imm;\n  dst.dword[2] = ((s64)((s32)a.word[4])) &lt;&lt; imm;\n  dst.dword[3] = ((s64)((s32)a.word[5])) &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsllwil_du_wu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsllwil_du_wu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsllwil.du.wu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtend and shift unsigned 32-bit elements in `a` by `imm` to unsigned 64-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i] << imm;\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i + 2] << imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) << imm;\n  dst.dword[1] = ((u64)((u32)a.word[1])) << imm;\n  dst.dword[2] = ((u64)((u32)a.word[4])) << imm;\n  dst.dword[3] = ((u64)((u32)a.word[5])) << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsllwil_du_wu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsllwil.du.wu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift unsigned 32-bit elements in <code>a</code> by <code>imm</code> to unsigned 64-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i] &lt;&lt; imm;\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[i + 2] &lt;&lt; imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) &lt;&lt; imm;\n  dst.dword[1] = ((u64)((u32)a.word[1])) &lt;&lt; imm;\n  dst.dword[2] = ((u64)((u32)a.word[4])) &lt;&lt; imm;\n  dst.dword[3] = ((u64)((u32)a.word[5])) &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsllwil_h_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsllwil_h_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvsllwil.h.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtend and shift signed 8-bit elements in `a` by `imm` to signed 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i] << imm;\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i + 8] << imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) << imm;\n  dst.half[1] = ((s16)((s8)a.byte[1])) << imm;\n  dst.half[2] = ((s16)((s8)a.byte[2])) << imm;\n  dst.half[3] = ((s16)((s8)a.byte[3])) << imm;\n  dst.half[4] = ((s16)((s8)a.byte[4])) << imm;\n  dst.half[5] = ((s16)((s8)a.byte[5])) << imm;\n  dst.half[6] = ((s16)((s8)a.byte[6])) << imm;\n  dst.half[7] = ((s16)((s8)a.byte[7])) << imm;\n  dst.half[8] = ((s16)((s8)a.byte[16])) << imm;\n  dst.half[9] = ((s16)((s8)a.byte[17])) << imm;\n  dst.half[10] = ((s16)((s8)a.byte[18])) << imm;\n  dst.half[11] = ((s16)((s8)a.byte[19])) << imm;\n  dst.half[12] = ((s16)((s8)a.byte[20])) << imm;\n  dst.half[13] = ((s16)((s8)a.byte[21])) << imm;\n  dst.half[14] = ((s16)((s8)a.byte[22])) << imm;\n  dst.half[15] = ((s16)((s8)a.byte[23])) << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsllwil_h_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsllwil.h.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift signed 8-bit elements in <code>a</code> by <code>imm</code> to signed 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i] &lt;&lt; imm;\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[i + 8] &lt;&lt; imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) &lt;&lt; imm;\n  dst.half[1] = ((s16)((s8)a.byte[1])) &lt;&lt; imm;\n  dst.half[2] = ((s16)((s8)a.byte[2])) &lt;&lt; imm;\n  dst.half[3] = ((s16)((s8)a.byte[3])) &lt;&lt; imm;\n  dst.half[4] = ((s16)((s8)a.byte[4])) &lt;&lt; imm;\n  dst.half[5] = ((s16)((s8)a.byte[5])) &lt;&lt; imm;\n  dst.half[6] = ((s16)((s8)a.byte[6])) &lt;&lt; imm;\n  dst.half[7] = ((s16)((s8)a.byte[7])) &lt;&lt; imm;\n  dst.half[8] = ((s16)((s8)a.byte[16])) &lt;&lt; imm;\n  dst.half[9] = ((s16)((s8)a.byte[17])) &lt;&lt; imm;\n  dst.half[10] = ((s16)((s8)a.byte[18])) &lt;&lt; imm;\n  dst.half[11] = ((s16)((s8)a.byte[19])) &lt;&lt; imm;\n  dst.half[12] = ((s16)((s8)a.byte[20])) &lt;&lt; imm;\n  dst.half[13] = ((s16)((s8)a.byte[21])) &lt;&lt; imm;\n  dst.half[14] = ((s16)((s8)a.byte[22])) &lt;&lt; imm;\n  dst.half[15] = ((s16)((s8)a.byte[23])) &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsllwil_hu_bu (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsllwil_hu_bu (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvsllwil.hu.bu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtend and shift unsigned 8-bit elements in `a` by `imm` to unsigned 16-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i] << imm;\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i + 8] << imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) << imm;\n  dst.half[1] = ((u16)((u8)a.byte[1])) << imm;\n  dst.half[2] = ((u16)((u8)a.byte[2])) << imm;\n  dst.half[3] = ((u16)((u8)a.byte[3])) << imm;\n  dst.half[4] = ((u16)((u8)a.byte[4])) << imm;\n  dst.half[5] = ((u16)((u8)a.byte[5])) << imm;\n  dst.half[6] = ((u16)((u8)a.byte[6])) << imm;\n  dst.half[7] = ((u16)((u8)a.byte[7])) << imm;\n  dst.half[8] = ((u16)((u8)a.byte[16])) << imm;\n  dst.half[9] = ((u16)((u8)a.byte[17])) << imm;\n  dst.half[10] = ((u16)((u8)a.byte[18])) << imm;\n  dst.half[11] = ((u16)((u8)a.byte[19])) << imm;\n  dst.half[12] = ((u16)((u8)a.byte[20])) << imm;\n  dst.half[13] = ((u16)((u8)a.byte[21])) << imm;\n  dst.half[14] = ((u16)((u8)a.byte[22])) << imm;\n  dst.half[15] = ((u16)((u8)a.byte[23])) << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsllwil_hu_bu (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsllwil.hu.bu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift unsigned 8-bit elements in <code>a</code> by <code>imm</code> to unsigned 16-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i] &lt;&lt; imm;\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[i + 8] &lt;&lt; imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) &lt;&lt; imm;\n  dst.half[1] = ((u16)((u8)a.byte[1])) &lt;&lt; imm;\n  dst.half[2] = ((u16)((u8)a.byte[2])) &lt;&lt; imm;\n  dst.half[3] = ((u16)((u8)a.byte[3])) &lt;&lt; imm;\n  dst.half[4] = ((u16)((u8)a.byte[4])) &lt;&lt; imm;\n  dst.half[5] = ((u16)((u8)a.byte[5])) &lt;&lt; imm;\n  dst.half[6] = ((u16)((u8)a.byte[6])) &lt;&lt; imm;\n  dst.half[7] = ((u16)((u8)a.byte[7])) &lt;&lt; imm;\n  dst.half[8] = ((u16)((u8)a.byte[16])) &lt;&lt; imm;\n  dst.half[9] = ((u16)((u8)a.byte[17])) &lt;&lt; imm;\n  dst.half[10] = ((u16)((u8)a.byte[18])) &lt;&lt; imm;\n  dst.half[11] = ((u16)((u8)a.byte[19])) &lt;&lt; imm;\n  dst.half[12] = ((u16)((u8)a.byte[20])) &lt;&lt; imm;\n  dst.half[13] = ((u16)((u8)a.byte[21])) &lt;&lt; imm;\n  dst.half[14] = ((u16)((u8)a.byte[22])) &lt;&lt; imm;\n  dst.half[15] = ((u16)((u8)a.byte[23])) &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsllwil_w_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsllwil_w_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsllwil.w.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtend and shift signed 16-bit elements in `a` by `imm` to signed 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[i] << imm;\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[i + 4] << imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) << imm;\n  dst.word[1] = ((s32)((s16)a.half[1])) << imm;\n  dst.word[2] = ((s32)((s16)a.half[2])) << imm;\n  dst.word[3] = ((s32)((s16)a.half[3])) << imm;\n  dst.word[4] = ((s32)((s16)a.half[8])) << imm;\n  dst.word[5] = ((s32)((s16)a.half[9])) << imm;\n  dst.word[6] = ((s32)((s16)a.half[10])) << imm;\n  dst.word[7] = ((s32)((s16)a.half[11])) << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsllwil_w_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsllwil.w.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift signed 16-bit elements in <code>a</code> by <code>imm</code> to signed 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (s32)(s16)a.half[i] &lt;&lt; imm;\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[i + 4] &lt;&lt; imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) &lt;&lt; imm;\n  dst.word[1] = ((s32)((s16)a.half[1])) &lt;&lt; imm;\n  dst.word[2] = ((s32)((s16)a.half[2])) &lt;&lt; imm;\n  dst.word[3] = ((s32)((s16)a.half[3])) &lt;&lt; imm;\n  dst.word[4] = ((s32)((s16)a.half[8])) &lt;&lt; imm;\n  dst.word[5] = ((s32)((s16)a.half[9])) &lt;&lt; imm;\n  dst.word[6] = ((s32)((s16)a.half[10])) &lt;&lt; imm;\n  dst.word[7] = ((s32)((s16)a.half[11])) &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsllwil_wu_hu (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsllwil_wu_hu (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsllwil.wu.hu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nExtend and shift unsigned 16-bit elements in `a` by `imm` to unsigned 32-bit result.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[i] << imm;\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[i + 4] << imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) << imm;\n  dst.word[1] = ((u32)((u16)a.half[1])) << imm;\n  dst.word[2] = ((u32)((u16)a.half[2])) << imm;\n  dst.word[3] = ((u32)((u16)a.half[3])) << imm;\n  dst.word[4] = ((u32)((u16)a.half[8])) << imm;\n  dst.word[5] = ((u32)((u16)a.half[9])) << imm;\n  dst.word[6] = ((u32)((u16)a.half[10])) << imm;\n  dst.word[7] = ((u32)((u16)a.half[11])) << imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsllwil_wu_hu (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsllwil.wu.hu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Extend and shift unsigned 16-bit elements in <code>a</code> by <code>imm</code> to unsigned 32-bit result.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (u32)(u16)a.half[i] &lt;&lt; imm;\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[i + 4] &lt;&lt; imm;\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) &lt;&lt; imm;\n  dst.word[1] = ((u32)((u16)a.half[1])) &lt;&lt; imm;\n  dst.word[2] = ((u32)((u16)a.half[2])) &lt;&lt; imm;\n  dst.word[3] = ((u32)((u16)a.half[3])) &lt;&lt; imm;\n  dst.word[4] = ((u32)((u16)a.half[8])) &lt;&lt; imm;\n  dst.word[5] = ((u32)((u16)a.half[9])) &lt;&lt; imm;\n  dst.word[6] = ((u32)((u16)a.half[10])) &lt;&lt; imm;\n  dst.word[7] = ((u32)((u16)a.half[11])) &lt;&lt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslt_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslt_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvslt.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 8-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] < (s8)b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslt_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslt.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &lt; (s8)b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslt_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslt_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvslt.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 8-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] < (u8)b.byte[i]) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslt_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslt.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 8-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &lt; (u8)b.byte[i]) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslt_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslt_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvslt.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 64-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] < (s64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslt_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslt.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &lt; (s64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslt_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslt_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvslt.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 64-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] < (u64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslt_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslt.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 64-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &lt; (u64)b.dword[i]) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslt_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslt_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvslt.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 16-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i] < (s16)b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslt_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslt.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i] &lt; (s16)b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslt_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslt_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvslt.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 16-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((u16)a.half[i] < (u16)b.half[i]) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslt_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslt.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 16-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((u16)a.half[i] &lt; (u16)b.half[i]) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslt_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslt_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvslt.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 32-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i] < (s32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslt_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslt.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i] &lt; (s32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslt_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslt_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvslt.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 32-bit elements in `a` and `b`, store all-ones to `dst` if corresponding element in `a` is less than `b`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((u32)a.word[i] < (u32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslt_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslt.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 32-bit elements in <code>a</code> and <code>b</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>b</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((u32)a.word[i] &lt; (u32)b.word[i]) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslti_b (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslti_b (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslti.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 8-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] < imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslti_b (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslti.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i] &lt; imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslti_bu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslti_bu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslti.bu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 8-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] < imm) ? 0xFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslti_bu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslti.bu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 8-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((u8)a.byte[i] &lt; imm) ? 0xFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslti_d (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslti_d (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslti.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 64-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] < imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslti_d (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslti.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i] &lt; imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslti_du (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslti_du (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslti.du xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 64-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] < imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 4 |\n| 3C6000 | LA664 | 2 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslti_du (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslti.du xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 64-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((u64)a.dword[i] &lt; imm) ? 0xFFFFFFFFFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslti_h (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslti_h (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslti.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 16-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i] < imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslti_h (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslti.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i] &lt; imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslti_hu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslti_hu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslti.hu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 16-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((u16)a.half[i] < imm) ? 0xFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslti_hu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslti.hu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 16-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((u16)a.half[i] &lt; imm) ? 0xFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslti_w (__m256i a, imm_n16_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslti_w (__m256i a, imm_n16_15 imm)\n#include <lasxintrin.h>\nInstruction: xvslti.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the signed 32-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i] < imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslti_w (__m256i a, imm_n16_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslti.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the signed 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i] &lt; imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvslti_wu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvslti_wu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvslti.wu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompare the unsigned 32-bit elements in `a` and `imm`, store all-ones to `dst` if corresponding element in `a` is less than `imm`, zero otherwise.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((u32)a.word[i] < imm) ? 0xFFFFFFFF : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvslti_wu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvslti.wu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compare the unsigned 32-bit elements in <code>a</code> and <code>imm</code>, store all-ones to <code>dst</code> if corresponding element in <code>a</code> is less than <code>imm</code>, zero otherwise.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((u32)a.word[i] &lt; imm) ? 0xFFFFFFFF : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Comparison", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsra_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsra_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsra.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i]) >> (b.byte[i] & 0x7);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsra_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsra.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i]) &gt;&gt; (b.byte[i] &amp; 0x7);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsra_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsra_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsra.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i]) >> (b.dword[i] & 0x3f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsra_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsra.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i]) &gt;&gt; (b.dword[i] &amp; 0x3f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsra_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsra_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsra.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i]) >> (b.half[i] & 0xf);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsra_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsra.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i]) &gt;&gt; (b.half[i] &amp; 0xf);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsra_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsra_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsra.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i]) >> (b.word[i] & 0x1f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsra_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsra.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i]) &gt;&gt; (b.word[i] &amp; 0x1f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrai_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrai_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvsrai.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i]) >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrai_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrai.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = ((s8)a.byte[i]) &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrai_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrai_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsrai.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i]) >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrai_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrai.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = ((s64)a.dword[i]) &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrai_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrai_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsrai.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = ((s16)a.half[i]) >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrai_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrai.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = ((s16)a.half[i]) &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrai_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrai_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsrai.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = ((s32)a.word[i]) >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrai_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrai.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = ((s32)a.word[i]) &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsran_b_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsran_b_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsran.b.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by elements in `b`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i < 8) ? (s8)((s16)a.half[i] >> (b.half[i] & 15)) : 0;\n}\nfor (int i = 16; i < 32; i++) {\n  dst.byte[i] = (i < 24) ? (s8)((s16)a.half[i - 8] >> (b.half[i - 8] & 15)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsran_b_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsran.b.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i &lt; 8) ? (s8)((s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) : 0;\n}\nfor (int i = 16; i &lt; 32; i++) {\n  dst.byte[i] = (i &lt; 24) ? (s8)((s16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsran_h_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsran_h_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsran.h.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by elements in `b`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i < 4) ? (s16)((s32)a.word[i] >> (b.word[i] & 31)) : 0;\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] =\n      (i < 12) ? (s16)((s32)a.word[i - 4] >> (b.word[i - 4] & 31)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsran_h_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsran.h.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i &lt; 4) ? (s16)((s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) : 0;\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] =\n      (i &lt; 12) ? (s16)((s32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsran_w_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsran_w_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsran.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by elements in `b`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? (s32)((s64)a.dword[i] >> (b.dword[i] & 63)) : 0;\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] =\n      (i < 6) ? (s32)((s64)a.dword[i - 2] >> (b.dword[i - 2] & 63)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsran_w_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsran.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? (s32)((s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) : 0;\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] =\n      (i &lt; 6) ? (s32)((s64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrani_b_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrani_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsrani.b.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` and `b` by `imm`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] =\n      (i < 8) ? (s8)((s16)b.half[i] >> imm) : (s8)((s16)a.half[i - 8] >> imm);\n}\nfor (int i = 16; i < 32; i++) {\n  dst.byte[i] = (i < 24) ? (s8)((s16)b.half[i - 8] >> imm)\n                         : (s8)((s16)a.half[i - 16] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrani_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrani.b.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] =\n      (i &lt; 8) ? (s8)((s16)b.half[i] &gt;&gt; imm) : (s8)((s16)a.half[i - 8] &gt;&gt; imm);\n}\nfor (int i = 16; i &lt; 32; i++) {\n  dst.byte[i] = (i &lt; 24) ? (s8)((s16)b.half[i - 8] &gt;&gt; imm)\n                         : (s8)((s16)a.half[i - 16] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrani_d_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrani_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvsrani.d.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 128-bit elements in `a` and `b` by `imm`, truncate to 64-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i < 1) ? (s64)((s128)b.qword[i] >> imm)\n                         : (s64)((s128)a.qword[i - 1] >> imm);\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (i < 3) ? (s64)((s128)b.qword[i - 1] >> imm)\n                         : (s64)((s128)a.qword[i - 2] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrani_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrani.d.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 64-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i &lt; 1) ? (s64)((s128)b.qword[i] &gt;&gt; imm)\n                         : (s64)((s128)a.qword[i - 1] &gt;&gt; imm);\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (i &lt; 3) ? (s64)((s128)b.qword[i - 1] &gt;&gt; imm)\n                         : (s64)((s128)a.qword[i - 2] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrani_h_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrani_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsrani.h.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` and `b` by `imm`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (i < 4) ? (s16)((s32)b.word[i] >> imm) : (s16)((s32)a.word[i - 4] >> imm);\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] = (i < 12) ? (s16)((s32)b.word[i - 4] >> imm)\n                         : (s16)((s32)a.word[i - 8] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrani_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrani.h.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (i &lt; 4) ? (s16)((s32)b.word[i] &gt;&gt; imm) : (s16)((s32)a.word[i - 4] &gt;&gt; imm);\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] = (i &lt; 12) ? (s16)((s32)b.word[i - 4] &gt;&gt; imm)\n                         : (s16)((s32)a.word[i - 8] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrani_w_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrani_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsrani.w.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` and `b` by `imm`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? (s32)((s64)b.dword[i] >> imm)\n                        : (s32)((s64)a.dword[i - 2] >> imm);\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6) ? (s32)((s64)b.dword[i - 2] >> imm)\n                        : (s32)((s64)a.dword[i - 4] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrani_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrani.w.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? (s32)((s64)b.dword[i] &gt;&gt; imm)\n                        : (s32)((s64)a.dword[i - 2] &gt;&gt; imm);\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6) ? (s32)((s64)b.dword[i - 2] &gt;&gt; imm)\n                        : (s32)((s64)a.dword[i - 4] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrar_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrar_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrar.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  if ((b.byte[i] & 0x7) == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = ((s8)a.byte[i] >> (b.byte[i] & 0x7)) +\n                  (((s8)a.byte[i] >> ((b.byte[i] & 0x7) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrar_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrar.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  if ((b.byte[i] &amp; 0x7) == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = ((s8)a.byte[i] &gt;&gt; (b.byte[i] &amp; 0x7)) +\n                  (((s8)a.byte[i] &gt;&gt; ((b.byte[i] &amp; 0x7) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrar_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrar_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrar.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if ((b.dword[i] & 0x3f) == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = ((s64)a.dword[i] >> (b.dword[i] & 0x3f)) +\n                   (((s64)a.dword[i] >> ((b.dword[i] & 0x3f) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrar_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrar.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if ((b.dword[i] &amp; 0x3f) == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = ((s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 0x3f)) +\n                   (((s64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 0x3f) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrar_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrar_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrar.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if ((b.half[i] & 0xf) == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = ((s16)a.half[i] >> (b.half[i] & 0xf)) +\n                  (((s16)a.half[i] >> ((b.half[i] & 0xf) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrar_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrar.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if ((b.half[i] &amp; 0xf) == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = ((s16)a.half[i] &gt;&gt; (b.half[i] &amp; 0xf)) +\n                  (((s16)a.half[i] &gt;&gt; ((b.half[i] &amp; 0xf) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrar_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrar_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrar.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if ((b.word[i] & 0x1f) == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = ((s32)a.word[i] >> (b.word[i] & 0x1f)) +\n                  (((s32)a.word[i] >> ((b.word[i] & 0x1f) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrar_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrar.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if ((b.word[i] &amp; 0x1f) == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = ((s32)a.word[i] &gt;&gt; (b.word[i] &amp; 0x1f)) +\n                  (((s32)a.word[i] &gt;&gt; ((b.word[i] &amp; 0x1f) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrari_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrari_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvsrari.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  if (imm == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = ((s8)a.byte[i] >> imm) + (((s8)a.byte[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrari_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrari.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  if (imm == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = ((s8)a.byte[i] &gt;&gt; imm) + (((s8)a.byte[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrari_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrari_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsrari.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (imm == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] =\n        ((s64)a.dword[i] >> imm) + (((s64)a.dword[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrari_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrari.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (imm == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] =\n        ((s64)a.dword[i] &gt;&gt; imm) + (((s64)a.dword[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrari_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrari_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsrari.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (imm == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] =\n        ((s16)a.half[i] >> imm) + (((s16)a.half[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrari_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrari.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (imm == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] =\n        ((s16)a.half[i] &gt;&gt; imm) + (((s16)a.half[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrari_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrari_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsrari.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (imm == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] =\n        ((s32)a.word[i] >> imm) + (((s32)a.word[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrari_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrari.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (imm == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] =\n        ((s32)a.word[i] &gt;&gt; imm) + (((s32)a.word[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrarn_b_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrarn_b_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrarn.b.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by elements in `b`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u8 shift = (b.half[i] & 15);\n    if (shift == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i] >> shift) +\n                         (((s16)a.half[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u8 shift = (b.half[i - 8] & 15);\n    if (shift == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i - 8] >> shift) +\n                         (((s16)a.half[i - 8] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrarn_b_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrarn.b.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u8 shift = (b.half[i] &amp; 15);\n    if (shift == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i] &gt;&gt; shift) +\n                         (((s16)a.half[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u8 shift = (b.half[i - 8] &amp; 15);\n    if (shift == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i - 8] &gt;&gt; shift) +\n                         (((s16)a.half[i - 8] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrarn_h_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrarn_h_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrarn.h.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by elements in `b`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u8 shift = (b.word[i] & 31);\n    if (shift == 0) {\n      dst.half[i] = (s16)(s32)a.word[i];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i] >> shift) +\n                          (((s32)a.word[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u8 shift = (b.word[i - 4] & 31);\n    if (shift == 0) {\n      dst.half[i] = (s16)(s32)a.word[i - 4];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i - 4] >> shift) +\n                          (((s32)a.word[i - 4] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrarn_h_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrarn.h.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u8 shift = (b.word[i] &amp; 31);\n    if (shift == 0) {\n      dst.half[i] = (s16)(s32)a.word[i];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i] &gt;&gt; shift) +\n                          (((s32)a.word[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u8 shift = (b.word[i - 4] &amp; 31);\n    if (shift == 0) {\n      dst.half[i] = (s16)(s32)a.word[i - 4];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i - 4] &gt;&gt; shift) +\n                          (((s32)a.word[i - 4] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrarn_w_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrarn_w_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrarn.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by elements in `b`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u8 shift = (b.dword[i] & 63);\n    if (shift == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i] >> shift) +\n                          (((s64)a.dword[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u8 shift = (b.dword[i - 2] & 63);\n    if (shift == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i - 2] >> shift) +\n                          (((s64)a.dword[i - 2] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrarn_w_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrarn.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u8 shift = (b.dword[i] &amp; 63);\n    if (shift == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i] &gt;&gt; shift) +\n                          (((s64)a.dword[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u8 shift = (b.dword[i - 2] &amp; 63);\n    if (shift == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i - 2] &gt;&gt; shift) +\n                          (((s64)a.dword[i - 2] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrarni_b_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrarni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsrarni.b.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` and `b` by `imm`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)b.half[i];\n    } else {\n      dst.byte[i] =\n          (s8)(((s16)b.half[i] >> imm) + (((s16)b.half[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i - 8] >> imm) +\n                         (((s16)a.half[i - 8] >> (imm - 1)) & 0x1));\n    }\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)b.half[i - 8];\n    } else {\n      dst.byte[i] = (s8)(((s16)b.half[i - 8] >> imm) +\n                         (((s16)b.half[i - 8] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i - 16];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i - 16] >> imm) +\n                         (((s16)a.half[i - 16] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrarni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrarni.b.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)b.half[i];\n    } else {\n      dst.byte[i] =\n          (s8)(((s16)b.half[i] &gt;&gt; imm) + (((s16)b.half[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i - 8] &gt;&gt; imm) +\n                         (((s16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)b.half[i - 8];\n    } else {\n      dst.byte[i] = (s8)(((s16)b.half[i - 8] &gt;&gt; imm) +\n                         (((s16)b.half[i - 8] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (s8)(s16)a.half[i - 16];\n    } else {\n      dst.byte[i] = (s8)(((s16)a.half[i - 16] &gt;&gt; imm) +\n                         (((s16)a.half[i - 16] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrarni_d_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrarni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvsrarni.d.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 128-bit elements in `a` and `b` by `imm`, truncate to 64-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)b.qword[i];\n    } else {\n      dst.dword[i] = (s64)(((s128)b.qword[i] >> imm) +\n                           (((s128)b.qword[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)a.qword[i - 1];\n    } else {\n      dst.dword[i] = (s64)(((s128)a.qword[i - 1] >> imm) +\n                           (((s128)a.qword[i - 1] >> (imm - 1)) & 0x1));\n    }\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)b.qword[i - 1];\n    } else {\n      dst.dword[i] = (s64)(((s128)b.qword[i - 1] >> imm) +\n                           (((s128)b.qword[i - 1] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)a.qword[i - 2];\n    } else {\n      dst.dword[i] = (s64)(((s128)a.qword[i - 2] >> imm) +\n                           (((s128)a.qword[i - 2] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrarni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrarni.d.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 64-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)b.qword[i];\n    } else {\n      dst.dword[i] = (s64)(((s128)b.qword[i] &gt;&gt; imm) +\n                           (((s128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)a.qword[i - 1];\n    } else {\n      dst.dword[i] = (s64)(((s128)a.qword[i - 1] &gt;&gt; imm) +\n                           (((s128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)b.qword[i - 1];\n    } else {\n      dst.dword[i] = (s64)(((s128)b.qword[i - 1] &gt;&gt; imm) +\n                           (((s128)b.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (s64)(s128)a.qword[i - 2];\n    } else {\n      dst.dword[i] = (s64)(((s128)a.qword[i - 2] &gt;&gt; imm) +\n                           (((s128)a.qword[i - 2] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrarni_h_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrarni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsrarni.h.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` and `b` by `imm`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)b.word[i];\n    } else {\n      dst.half[i] = (s16)(((s32)b.word[i] >> imm) +\n                          (((s32)b.word[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)a.word[i - 4];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i - 4] >> imm) +\n                          (((s32)a.word[i - 4] >> (imm - 1)) & 0x1));\n    }\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)b.word[i - 4];\n    } else {\n      dst.half[i] = (s16)(((s32)b.word[i - 4] >> imm) +\n                          (((s32)b.word[i - 4] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)a.word[i - 8];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i - 8] >> imm) +\n                          (((s32)a.word[i - 8] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrarni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrarni.h.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)b.word[i];\n    } else {\n      dst.half[i] = (s16)(((s32)b.word[i] &gt;&gt; imm) +\n                          (((s32)b.word[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)a.word[i - 4];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i - 4] &gt;&gt; imm) +\n                          (((s32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)b.word[i - 4];\n    } else {\n      dst.half[i] = (s16)(((s32)b.word[i - 4] &gt;&gt; imm) +\n                          (((s32)b.word[i - 4] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (s16)(s32)a.word[i - 8];\n    } else {\n      dst.half[i] = (s16)(((s32)a.word[i - 8] &gt;&gt; imm) +\n                          (((s32)a.word[i - 8] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrarni_w_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrarni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsrarni.w.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` and `b` by `imm`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)b.dword[i];\n    } else {\n      dst.word[i] = (s32)(((s64)b.dword[i] >> imm) +\n                          (((s64)b.dword[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i - 2] >> imm) +\n                          (((s64)a.dword[i - 2] >> (imm - 1)) & 0x1));\n    }\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)b.dword[i - 2];\n    } else {\n      dst.word[i] = (s32)(((s64)b.dword[i - 2] >> imm) +\n                          (((s64)b.dword[i - 2] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i - 4];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i - 4] >> imm) +\n                          (((s64)a.dword[i - 4] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrarni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrarni.w.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)b.dword[i];\n    } else {\n      dst.word[i] = (s32)(((s64)b.dword[i] &gt;&gt; imm) +\n                          (((s64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i - 2] &gt;&gt; imm) +\n                          (((s64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)b.dword[i - 2];\n    } else {\n      dst.word[i] = (s32)(((s64)b.dword[i - 2] &gt;&gt; imm) +\n                          (((s64)b.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (s32)(s64)a.dword[i - 4];\n    } else {\n      dst.word[i] = (s32)(((s64)a.dword[i - 4] &gt;&gt; imm) +\n                          (((s64)a.dword[i - 4] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrl_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrl_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrl.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] >> (b.byte[i] & 0x7);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrl_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrl.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] &gt;&gt; (b.byte[i] &amp; 0x7);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrl_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrl_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrl.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] >> (b.dword[i] & 0x3f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrl_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrl.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] &gt;&gt; (b.dword[i] &amp; 0x3f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrl_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrl_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrl.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] >> (b.half[i] & 0xf);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrl_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrl.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] &gt;&gt; (b.half[i] &amp; 0xf);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrl_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrl_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrl.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] >> (b.word[i] & 0x1f);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrl_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrl.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] &gt;&gt; (b.word[i] &amp; 0x1f);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrli_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrli_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvsrli.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrli_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrli.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrli_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrli_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsrli.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrli_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrli.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrli_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrli_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsrli.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrli_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrli.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrli_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrli_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsrli.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] >> imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrli_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrli.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] &gt;&gt; imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrln_b_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrln_b_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrln.b.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by elements in `b`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] = (i < 8) ? (u8)((u16)a.half[i] >> (b.half[i] & 15)) : 0;\n}\nfor (int i = 16; i < 32; i++) {\n  dst.byte[i] = (i < 24) ? (u8)((u16)a.half[i - 8] >> (b.half[i - 8] & 15)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrln_b_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrln.b.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] = (i &lt; 8) ? (u8)((u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) : 0;\n}\nfor (int i = 16; i &lt; 32; i++) {\n  dst.byte[i] = (i &lt; 24) ? (u8)((u16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrln_h_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrln_h_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrln.h.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by elements in `b`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] = (i < 4) ? (u16)((u32)a.word[i] >> (b.word[i] & 31)) : 0;\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] =\n      (i < 12) ? (u16)((u32)a.word[i - 4] >> (b.word[i - 4] & 31)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrln_h_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrln.h.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] = (i &lt; 4) ? (u16)((u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) : 0;\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] =\n      (i &lt; 12) ? (u16)((u32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrln_w_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrln_w_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrln.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by elements in `b`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? (u32)((u64)a.dword[i] >> (b.dword[i] & 63)) : 0;\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] =\n      (i < 6) ? (u32)((u64)a.dword[i - 2] >> (b.dword[i - 2] & 63)) : 0;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 1 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrln_w_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrln.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? (u32)((u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) : 0;\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] =\n      (i &lt; 6) ? (u32)((u64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63)) : 0;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlni_b_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlni.b.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` and `b` by `imm`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.byte[i] =\n      (i < 8) ? (u8)((u16)b.half[i] >> imm) : (u8)((u16)a.half[i - 8] >> imm);\n}\nfor (int i = 16; i < 32; i++) {\n  dst.byte[i] = (i < 24) ? (u8)((u16)b.half[i - 8] >> imm)\n                         : (u8)((u16)a.half[i - 16] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlni.b.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.byte[i] =\n      (i &lt; 8) ? (u8)((u16)b.half[i] &gt;&gt; imm) : (u8)((u16)a.half[i - 8] &gt;&gt; imm);\n}\nfor (int i = 16; i &lt; 32; i++) {\n  dst.byte[i] = (i &lt; 24) ? (u8)((u16)b.half[i - 8] &gt;&gt; imm)\n                         : (u8)((u16)a.half[i - 16] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlni_d_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlni.d.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 128-bit elements in `a` and `b` by `imm`, truncate to 64-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.dword[i] = (i < 1) ? (u64)((u128)b.qword[i] >> imm)\n                         : (u64)((u128)a.qword[i - 1] >> imm);\n}\nfor (int i = 2; i < 4; i++) {\n  dst.dword[i] = (i < 3) ? (u64)((u128)b.qword[i - 1] >> imm)\n                         : (u64)((u128)a.qword[i - 2] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlni.d.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 64-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.dword[i] = (i &lt; 1) ? (u64)((u128)b.qword[i] &gt;&gt; imm)\n                         : (u64)((u128)a.qword[i - 1] &gt;&gt; imm);\n}\nfor (int i = 2; i &lt; 4; i++) {\n  dst.dword[i] = (i &lt; 3) ? (u64)((u128)b.qword[i - 1] &gt;&gt; imm)\n                         : (u64)((u128)a.qword[i - 2] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlni_h_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlni.h.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` and `b` by `imm`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.half[i] =\n      (i < 4) ? (u16)((u32)b.word[i] >> imm) : (u16)((u32)a.word[i - 4] >> imm);\n}\nfor (int i = 8; i < 16; i++) {\n  dst.half[i] = (i < 12) ? (u16)((u32)b.word[i - 4] >> imm)\n                         : (u16)((u32)a.word[i - 8] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlni.h.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.half[i] =\n      (i &lt; 4) ? (u16)((u32)b.word[i] &gt;&gt; imm) : (u16)((u32)a.word[i - 4] &gt;&gt; imm);\n}\nfor (int i = 8; i &lt; 16; i++) {\n  dst.half[i] = (i &lt; 12) ? (u16)((u32)b.word[i - 4] &gt;&gt; imm)\n                         : (u16)((u32)a.word[i - 8] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlni_w_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlni.w.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` and `b` by `imm`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.word[i] = (i < 2) ? (u32)((u64)b.dword[i] >> imm)\n                        : (u32)((u64)a.dword[i - 2] >> imm);\n}\nfor (int i = 4; i < 8; i++) {\n  dst.word[i] = (i < 6) ? (u32)((u64)b.dword[i - 2] >> imm)\n                        : (u32)((u64)a.dword[i - 4] >> imm);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlni.w.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.word[i] = (i &lt; 2) ? (u32)((u64)b.dword[i] &gt;&gt; imm)\n                        : (u32)((u64)a.dword[i - 2] &gt;&gt; imm);\n}\nfor (int i = 4; i &lt; 8; i++) {\n  dst.word[i] = (i &lt; 6) ? (u32)((u64)b.dword[i - 2] &gt;&gt; imm)\n                        : (u32)((u64)a.dword[i - 4] &gt;&gt; imm);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlr_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlr_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrlr.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 8-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  if ((b.byte[i] & 0x7) == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = (a.byte[i] >> (b.byte[i] & 0x7)) +\n                  ((a.byte[i] >> ((b.byte[i] & 0x7) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlr_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlr.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 8-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  if ((b.byte[i] &amp; 0x7) == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = (a.byte[i] &gt;&gt; (b.byte[i] &amp; 0x7)) +\n                  ((a.byte[i] &gt;&gt; ((b.byte[i] &amp; 0x7) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlr_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlr_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrlr.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if ((b.dword[i] & 0x3f) == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = (a.dword[i] >> (b.dword[i] & 0x3f)) +\n                   ((a.dword[i] >> ((b.dword[i] & 0x3f) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlr_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlr.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if ((b.dword[i] &amp; 0x3f) == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = (a.dword[i] &gt;&gt; (b.dword[i] &amp; 0x3f)) +\n                   ((a.dword[i] &gt;&gt; ((b.dword[i] &amp; 0x3f) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlr_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlr_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrlr.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if ((b.half[i] & 0xf) == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = (a.half[i] >> (b.half[i] & 0xf)) +\n                  ((a.half[i] >> ((b.half[i] & 0xf) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlr_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlr.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if ((b.half[i] &amp; 0xf) == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = (a.half[i] &gt;&gt; (b.half[i] &amp; 0xf)) +\n                  ((a.half[i] &gt;&gt; ((b.half[i] &amp; 0xf) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlr_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlr_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrlr.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by elements in `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if ((b.word[i] & 0x1f) == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = (a.word[i] >> (b.word[i] & 0x1f)) +\n                  ((a.word[i] >> ((b.word[i] & 0x1f) - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlr_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlr.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if ((b.word[i] &amp; 0x1f) == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = (a.word[i] &gt;&gt; (b.word[i] &amp; 0x1f)) +\n                  ((a.word[i] &gt;&gt; ((b.word[i] &amp; 0x1f) - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlri_b (__m256i a, imm0_7 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlri_b (__m256i a, imm0_7 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlri.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 8-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  if (imm == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = (a.byte[i] >> imm) + ((a.byte[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlri_b (__m256i a, imm0_7 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlri.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 8-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  if (imm == 0) {\n    dst.byte[i] = a.byte[i];\n  } else {\n    dst.byte[i] = (a.byte[i] &gt;&gt; imm) + ((a.byte[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlri_d (__m256i a, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlri_d (__m256i a, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlri.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (imm == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = (a.dword[i] >> imm) + ((a.dword[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlri_d (__m256i a, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlri.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (imm == 0) {\n    dst.dword[i] = a.dword[i];\n  } else {\n    dst.dword[i] = (a.dword[i] &gt;&gt; imm) + ((a.dword[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlri_h (__m256i a, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlri_h (__m256i a, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlri.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (imm == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = (a.half[i] >> imm) + ((a.half[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlri_h (__m256i a, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlri.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (imm == 0) {\n    dst.half[i] = a.half[i];\n  } else {\n    dst.half[i] = (a.half[i] &gt;&gt; imm) + ((a.half[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlri_w (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlri_w (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlri.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by `imm`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (imm == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = (a.word[i] >> imm) + ((a.word[i] >> (imm - 1)) & 0x1);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlri_w (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlri.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by <code>imm</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (imm == 0) {\n    dst.word[i] = a.word[i];\n  } else {\n    dst.word[i] = (a.word[i] &gt;&gt; imm) + ((a.word[i] &gt;&gt; (imm - 1)) &amp; 0x1);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlrn_b_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlrn_b_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrlrn.b.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by elements in `b`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u8 shift = (b.half[i] & 15);\n    if (shift == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i] >> shift) +\n                         (((u16)a.half[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u8 shift = (b.half[i - 8] & 15);\n    if (shift == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i - 8] >> shift) +\n                         (((u16)a.half[i - 8] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlrn_b_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlrn.b.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u8 shift = (b.half[i] &amp; 15);\n    if (shift == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i] &gt;&gt; shift) +\n                         (((u16)a.half[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u8 shift = (b.half[i - 8] &amp; 15);\n    if (shift == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i - 8] &gt;&gt; shift) +\n                         (((u16)a.half[i - 8] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlrn_h_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlrn_h_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrlrn.h.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by elements in `b`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u8 shift = (b.word[i] & 31);\n    if (shift == 0) {\n      dst.half[i] = (u16)(u32)a.word[i];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i] >> shift) +\n                          (((u32)a.word[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u8 shift = (b.word[i - 4] & 31);\n    if (shift == 0) {\n      dst.half[i] = (u16)(u32)a.word[i - 4];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i - 4] >> shift) +\n                          (((u32)a.word[i - 4] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlrn_h_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlrn.h.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u8 shift = (b.word[i] &amp; 31);\n    if (shift == 0) {\n      dst.half[i] = (u16)(u32)a.word[i];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i] &gt;&gt; shift) +\n                          (((u32)a.word[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u8 shift = (b.word[i - 4] &amp; 31);\n    if (shift == 0) {\n      dst.half[i] = (u16)(u32)a.word[i - 4];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i - 4] &gt;&gt; shift) +\n                          (((u32)a.word[i - 4] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlrn_w_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlrn_w_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsrlrn.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by elements in `b`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u8 shift = (b.dword[i] & 63);\n    if (shift == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i] >> shift) +\n                          (((u64)a.dword[i] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u8 shift = (b.dword[i - 2] & 63);\n    if (shift == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i - 2] >> shift) +\n                          (((u64)a.dword[i - 2] >> (shift - 1)) & 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlrn_w_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlrn.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u8 shift = (b.dword[i] &amp; 63);\n    if (shift == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i] &gt;&gt; shift) +\n                          (((u64)a.dword[i] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u8 shift = (b.dword[i - 2] &amp; 63);\n    if (shift == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i - 2] &gt;&gt; shift) +\n                          (((u64)a.dword[i - 2] &gt;&gt; (shift - 1)) &amp; 0x1));\n    }\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlrni_b_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlrni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlrni.b.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` and `b` by `imm`, truncate to 8-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)b.half[i];\n    } else {\n      dst.byte[i] =\n          (u8)(((u16)b.half[i] >> imm) + (((u16)b.half[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i - 8] >> imm) +\n                         (((u16)a.half[i - 8] >> (imm - 1)) & 0x1));\n    }\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)b.half[i - 8];\n    } else {\n      dst.byte[i] = (u8)(((u16)b.half[i - 8] >> imm) +\n                         (((u16)b.half[i - 8] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i - 16];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i - 16] >> imm) +\n                         (((u16)a.half[i - 16] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlrni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlrni.b.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 8-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)b.half[i];\n    } else {\n      dst.byte[i] =\n          (u8)(((u16)b.half[i] &gt;&gt; imm) + (((u16)b.half[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i - 8];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i - 8] &gt;&gt; imm) +\n                         (((u16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)b.half[i - 8];\n    } else {\n      dst.byte[i] = (u8)(((u16)b.half[i - 8] &gt;&gt; imm) +\n                         (((u16)b.half[i - 8] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.byte[i] = (u8)(u16)a.half[i - 16];\n    } else {\n      dst.byte[i] = (u8)(((u16)a.half[i - 16] &gt;&gt; imm) +\n                         (((u16)a.half[i - 16] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlrni_d_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlrni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlrni.d.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 128-bit elements in `a` and `b` by `imm`, truncate to 64-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)b.qword[i];\n    } else {\n      dst.dword[i] = (u64)(((u128)b.qword[i] >> imm) +\n                           (((u128)b.qword[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)a.qword[i - 1];\n    } else {\n      dst.dword[i] = (u64)(((u128)a.qword[i - 1] >> imm) +\n                           (((u128)a.qword[i - 1] >> (imm - 1)) & 0x1));\n    }\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)b.qword[i - 1];\n    } else {\n      dst.dword[i] = (u64)(((u128)b.qword[i - 1] >> imm) +\n                           (((u128)b.qword[i - 1] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)a.qword[i - 2];\n    } else {\n      dst.dword[i] = (u64)(((u128)a.qword[i - 2] >> imm) +\n                           (((u128)a.qword[i - 2] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlrni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlrni.d.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 64-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)b.qword[i];\n    } else {\n      dst.dword[i] = (u64)(((u128)b.qword[i] &gt;&gt; imm) +\n                           (((u128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)a.qword[i - 1];\n    } else {\n      dst.dword[i] = (u64)(((u128)a.qword[i - 1] &gt;&gt; imm) +\n                           (((u128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)b.qword[i - 1];\n    } else {\n      dst.dword[i] = (u64)(((u128)b.qword[i - 1] &gt;&gt; imm) +\n                           (((u128)b.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.dword[i] = (u64)(u128)a.qword[i - 2];\n    } else {\n      dst.dword[i] = (u64)(((u128)a.qword[i - 2] &gt;&gt; imm) +\n                           (((u128)a.qword[i - 2] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlrni_h_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlrni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlrni.h.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` and `b` by `imm`, truncate to 16-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)b.word[i];\n    } else {\n      dst.half[i] = (u16)(((u32)b.word[i] >> imm) +\n                          (((u32)b.word[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)a.word[i - 4];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i - 4] >> imm) +\n                          (((u32)a.word[i - 4] >> (imm - 1)) & 0x1));\n    }\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)b.word[i - 4];\n    } else {\n      dst.half[i] = (u16)(((u32)b.word[i - 4] >> imm) +\n                          (((u32)b.word[i - 4] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)a.word[i - 8];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i - 8] >> imm) +\n                          (((u32)a.word[i - 8] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlrni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlrni.h.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 16-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)b.word[i];\n    } else {\n      dst.half[i] = (u16)(((u32)b.word[i] &gt;&gt; imm) +\n                          (((u32)b.word[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)a.word[i - 4];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i - 4] &gt;&gt; imm) +\n                          (((u32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)b.word[i - 4];\n    } else {\n      dst.half[i] = (u16)(((u32)b.word[i - 4] &gt;&gt; imm) +\n                          (((u32)b.word[i - 4] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.half[i] = (u16)(u32)a.word[i - 8];\n    } else {\n      dst.half[i] = (u16)(((u32)a.word[i - 8] &gt;&gt; imm) +\n                          (((u32)a.word[i - 8] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsrlrni_w_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsrlrni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvsrlrni.w.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` and `b` by `imm`, truncate to 32-bit and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)b.dword[i];\n    } else {\n      dst.word[i] = (u32)(((u64)b.dword[i] >> imm) +\n                          (((u64)b.dword[i] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i - 2] >> imm) +\n                          (((u64)a.dword[i - 2] >> (imm - 1)) & 0x1));\n    }\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)b.dword[i - 2];\n    } else {\n      dst.word[i] = (u32)(((u64)b.dword[i - 2] >> imm) +\n                          (((u64)b.dword[i - 2] >> (imm - 1)) & 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i - 4];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i - 4] >> imm) +\n                          (((u64)a.dword[i - 4] >> (imm - 1)) & 0x1));\n    }\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsrlrni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsrlrni.w.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, truncate to 32-bit and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)b.dword[i];\n    } else {\n      dst.word[i] = (u32)(((u64)b.dword[i] &gt;&gt; imm) +\n                          (((u64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i - 2];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i - 2] &gt;&gt; imm) +\n                          (((u64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)b.dword[i - 2];\n    } else {\n      dst.word[i] = (u32)(((u64)b.dword[i - 2] &gt;&gt; imm) +\n                          (((u64)b.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  } else {\n    if (imm == 0) {\n      dst.word[i] = (u32)(u64)a.dword[i - 4];\n    } else {\n      dst.word[i] = (u32)(((u64)a.dword[i - 4] &gt;&gt; imm) +\n                          (((u64)a.dword[i - 4] &gt;&gt; (imm - 1)) &amp; 0x1));\n    }\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssran_b_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssran_b_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssran.b.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by elements in `b`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp = (s16)a.half[i] >> (b.half[i] & 15);\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    s16 temp = (s16)a.half[i - 8] >> (b.half[i - 8] & 15);\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssran_b_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssran.b.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp = (s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15);\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    s16 temp = (s16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15);\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssran_bu_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssran_bu_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssran.bu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` by elements in `b`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp = (s16)a.half[i] >> (b.half[i] & 15);\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    s16 temp = (s16)a.half[i - 8] >> (b.half[i - 8] & 15);\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssran_bu_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssran.bu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp = (s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15);\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    s16 temp = (s16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15);\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssran_h_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssran_h_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssran.h.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by elements in `b`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp = (s32)a.word[i] >> (b.word[i] & 31);\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    s32 temp = (s32)a.word[i - 4] >> (b.word[i - 4] & 31);\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssran_h_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssran.h.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp = (s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31);\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    s32 temp = (s32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31);\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssran_hu_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssran_hu_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssran.hu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` by elements in `b`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp = (s32)a.word[i] >> (b.word[i] & 31);\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    s32 temp = (s32)a.word[i - 4] >> (b.word[i - 4] & 31);\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssran_hu_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssran.hu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp = (s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31);\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    s32 temp = (s32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31);\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssran_w_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssran_w_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssran.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by elements in `b`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp = (s64)a.dword[i] >> (b.dword[i] & 63);\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    s64 temp = (s64)a.dword[i - 2] >> (b.dword[i - 2] & 63);\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssran_w_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssran.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp = (s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63);\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    s64 temp = (s64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63);\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssran_wu_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssran_wu_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssran.wu.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` by elements in `b`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp = (s64)a.dword[i] >> (b.dword[i] & 63);\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    s64 temp = (s64)a.dword[i - 2] >> (b.dword[i - 2] & 63);\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssran_wu_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssran.wu.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp = (s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63);\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    s64 temp = (s64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63);\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrani_b_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrani_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvssrani.b.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` and `b` by `imm`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp = (s16)b.half[i] >> imm;\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    s16 temp = (s16)a.half[i - 8] >> imm;\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    s16 temp = (s16)b.half[i - 8] >> imm;\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    s16 temp = (s16)a.half[i - 16] >> imm;\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrani_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrani.b.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp = (s16)b.half[i] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    s16 temp = (s16)a.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    s16 temp = (s16)b.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    s16 temp = (s16)a.half[i - 16] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrani_bu_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrani_bu_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvssrani.bu.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 16-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp = (s16)b.half[i] >> imm;\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    s16 temp = (s16)a.half[i - 8] >> imm;\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    s16 temp = (s16)b.half[i - 8] >> imm;\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    s16 temp = (s16)a.half[i - 16] >> imm;\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrani_bu_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrani.bu.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp = (s16)b.half[i] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    s16 temp = (s16)a.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    s16 temp = (s16)b.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    s16 temp = (s16)a.half[i - 16] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrani_d_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrani_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvssrani.d.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 128-bit elements in `a` and `b` by `imm`, clamp to fit in signed 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    s128 temp = (s128)b.qword[i] >> imm;\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp = (s128)a.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    s128 temp = (s128)b.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp = (s128)a.qword[i - 2] >> imm;\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrani_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrani.d.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    s128 temp = (s128)b.qword[i] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp = (s128)a.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    s128 temp = (s128)b.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp = (s128)a.qword[i - 2] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrani_du_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrani_du_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvssrani.du.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 128-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    s128 temp = (s128)b.qword[i] >> imm;\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp = (s128)a.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    s128 temp = (s128)b.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp = (s128)a.qword[i - 2] >> imm;\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrani_du_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrani.du.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    s128 temp = (s128)b.qword[i] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp = (s128)a.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    s128 temp = (s128)b.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp = (s128)a.qword[i - 2] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrani_h_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrani_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvssrani.h.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` and `b` by `imm`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp = (s32)b.word[i] >> imm;\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    s32 temp = (s32)a.word[i - 4] >> imm;\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    s32 temp = (s32)b.word[i - 4] >> imm;\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    s32 temp = (s32)a.word[i - 8] >> imm;\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrani_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrani.h.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp = (s32)b.word[i] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    s32 temp = (s32)a.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    s32 temp = (s32)b.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    s32 temp = (s32)a.word[i - 8] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrani_hu_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrani_hu_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvssrani.hu.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 32-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp = (s32)b.word[i] >> imm;\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    s32 temp = (s32)a.word[i - 4] >> imm;\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    s32 temp = (s32)b.word[i - 4] >> imm;\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    s32 temp = (s32)a.word[i - 8] >> imm;\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrani_hu_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrani.hu.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp = (s32)b.word[i] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    s32 temp = (s32)a.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    s32 temp = (s32)b.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    s32 temp = (s32)a.word[i - 8] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrani_w_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrani_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvssrani.w.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` and `b` by `imm`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp = (s64)b.dword[i] >> imm;\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp = (s64)a.dword[i - 2] >> imm;\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    s64 temp = (s64)b.dword[i - 2] >> imm;\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp = (s64)a.dword[i - 4] >> imm;\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrani_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrani.w.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp = (s64)b.dword[i] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp = (s64)a.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    s64 temp = (s64)b.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp = (s64)a.dword[i - 4] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrani_wu_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrani_wu_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvssrani.wu.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift the signed 64-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp = (s64)b.dword[i] >> imm;\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    s64 temp = (s64)a.dword[i - 2] >> imm;\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    s64 temp = (s64)b.dword[i - 2] >> imm;\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    s64 temp = (s64)a.dword[i - 4] >> imm;\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrani_wu_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrani.wu.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp = (s64)b.dword[i] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    s64 temp = (s64)a.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    s64 temp = (s64)b.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    s64 temp = (s64)a.dword[i - 4] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarn_b_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarn_b_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrarn.b.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by elements in `b`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp;\n    if ((b.half[i] & 15) == 0) {\n      temp = (s16)a.half[i];\n    } else {\n      temp = ((s16)a.half[i] >> (b.half[i] & 15)) +\n             (((s16)a.half[i] >> ((b.half[i] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    s16 temp;\n    if ((b.half[i - 8] & 15) == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp = ((s16)a.half[i - 8] >> (b.half[i - 8] & 15)) +\n             (((s16)a.half[i - 8] >> ((b.half[i - 8] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarn_b_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarn.b.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp;\n    if ((b.half[i] &amp; 15) == 0) {\n      temp = (s16)a.half[i];\n    } else {\n      temp = ((s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) +\n             (((s16)a.half[i] &gt;&gt; ((b.half[i] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    s16 temp;\n    if ((b.half[i - 8] &amp; 15) == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp = ((s16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15)) +\n             (((s16)a.half[i - 8] &gt;&gt; ((b.half[i - 8] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarn_bu_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarn_bu_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrarn.bu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` by elements in `b`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp;\n    if ((b.half[i] & 15) == 0) {\n      temp = (s16)a.half[i];\n    } else {\n      temp = ((s16)a.half[i] >> (b.half[i] & 15)) +\n             (((s16)a.half[i] >> ((b.half[i] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    s16 temp;\n    if ((b.half[i - 8] & 15) == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp = ((s16)a.half[i - 8] >> (b.half[i - 8] & 15)) +\n             (((s16)a.half[i - 8] >> ((b.half[i - 8] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarn_bu_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarn.bu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp;\n    if ((b.half[i] &amp; 15) == 0) {\n      temp = (s16)a.half[i];\n    } else {\n      temp = ((s16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) +\n             (((s16)a.half[i] &gt;&gt; ((b.half[i] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    s16 temp;\n    if ((b.half[i - 8] &amp; 15) == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp = ((s16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15)) +\n             (((s16)a.half[i - 8] &gt;&gt; ((b.half[i - 8] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarn_h_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarn_h_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrarn.h.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by elements in `b`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp;\n    if ((b.word[i] & 31) == 0) {\n      temp = (s32)a.word[i];\n    } else {\n      temp = ((s32)a.word[i] >> (b.word[i] & 31)) +\n             (((s32)a.word[i] >> ((b.word[i] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    s32 temp;\n    if ((b.word[i - 4] & 31) == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp = ((s32)a.word[i - 4] >> (b.word[i - 4] & 31)) +\n             (((s32)a.word[i - 4] >> ((b.word[i - 4] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarn_h_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarn.h.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp;\n    if ((b.word[i] &amp; 31) == 0) {\n      temp = (s32)a.word[i];\n    } else {\n      temp = ((s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) +\n             (((s32)a.word[i] &gt;&gt; ((b.word[i] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    s32 temp;\n    if ((b.word[i - 4] &amp; 31) == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp = ((s32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31)) +\n             (((s32)a.word[i - 4] &gt;&gt; ((b.word[i - 4] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarn_hu_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarn_hu_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrarn.hu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` by elements in `b`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp;\n    if ((b.word[i] & 31) == 0) {\n      temp = (s32)a.word[i];\n    } else {\n      temp = ((s32)a.word[i] >> (b.word[i] & 31)) +\n             (((s32)a.word[i] >> ((b.word[i] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    s32 temp;\n    if ((b.word[i - 4] & 31) == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp = ((s32)a.word[i - 4] >> (b.word[i - 4] & 31)) +\n             (((s32)a.word[i - 4] >> ((b.word[i - 4] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarn_hu_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarn.hu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp;\n    if ((b.word[i] &amp; 31) == 0) {\n      temp = (s32)a.word[i];\n    } else {\n      temp = ((s32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) +\n             (((s32)a.word[i] &gt;&gt; ((b.word[i] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    s32 temp;\n    if ((b.word[i - 4] &amp; 31) == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp = ((s32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31)) +\n             (((s32)a.word[i - 4] &gt;&gt; ((b.word[i - 4] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarn_w_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarn_w_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrarn.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by elements in `b`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp;\n    if ((b.dword[i] & 63) == 0) {\n      temp = (s64)a.dword[i];\n    } else {\n      temp = ((s64)a.dword[i] >> (b.dword[i] & 63)) +\n             (((s64)a.dword[i] >> ((b.dword[i] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    s64 temp;\n    if ((b.dword[i - 2] & 63) == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] >> (b.dword[i - 2] & 63)) +\n             (((s64)a.dword[i - 2] >> ((b.dword[i - 2] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarn_w_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarn.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp;\n    if ((b.dword[i] &amp; 63) == 0) {\n      temp = (s64)a.dword[i];\n    } else {\n      temp = ((s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) +\n             (((s64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    s64 temp;\n    if ((b.dword[i - 2] &amp; 63) == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63)) +\n             (((s64)a.dword[i - 2] &gt;&gt; ((b.dword[i - 2] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarn_wu_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarn_wu_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrarn.wu.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` by elements in `b`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp;\n    if ((b.dword[i] & 63) == 0) {\n      temp = (s64)a.dword[i];\n    } else {\n      temp = ((s64)a.dword[i] >> (b.dword[i] & 63)) +\n             (((s64)a.dword[i] >> ((b.dword[i] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    s64 temp;\n    if ((b.dword[i - 2] & 63) == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] >> (b.dword[i - 2] & 63)) +\n             (((s64)a.dword[i - 2] >> ((b.dword[i - 2] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarn_wu_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarn.wu.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp;\n    if ((b.dword[i] &amp; 63) == 0) {\n      temp = (s64)a.dword[i];\n    } else {\n      temp = ((s64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) +\n             (((s64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    s64 temp;\n    if ((b.dword[i - 2] &amp; 63) == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63)) +\n             (((s64)a.dword[i - 2] &gt;&gt; ((b.dword[i - 2] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarni_b_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvssrarni.b.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` and `b` by `imm`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i];\n    } else {\n      temp = ((s16)b.half[i] >> imm) + (((s16)b.half[i] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp =\n          ((s16)a.half[i - 8] >> imm) + (((s16)a.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i - 8];\n    } else {\n      temp =\n          ((s16)b.half[i - 8] >> imm) + (((s16)b.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 16];\n    } else {\n      temp = ((s16)a.half[i - 16] >> imm) +\n             (((s16)a.half[i - 16] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, -128, 127);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarni.b.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i];\n    } else {\n      temp = ((s16)b.half[i] &gt;&gt; imm) + (((s16)b.half[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp =\n          ((s16)a.half[i - 8] &gt;&gt; imm) + (((s16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i - 8];\n    } else {\n      temp =\n          ((s16)b.half[i - 8] &gt;&gt; imm) + (((s16)b.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 16];\n    } else {\n      temp = ((s16)a.half[i - 16] &gt;&gt; imm) +\n             (((s16)a.half[i - 16] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, -128, 127);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarni_bu_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarni_bu_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvssrarni.bu.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 16-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i];\n    } else {\n      temp = ((s16)b.half[i] >> imm) + (((s16)b.half[i] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp =\n          ((s16)a.half[i - 8] >> imm) + (((s16)a.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i - 8];\n    } else {\n      temp =\n          ((s16)b.half[i - 8] >> imm) + (((s16)b.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 16];\n    } else {\n      temp = ((s16)a.half[i - 16] >> imm) +\n             (((s16)a.half[i - 16] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<s16>(temp, 0, 255);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarni_bu_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarni.bu.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i];\n    } else {\n      temp = ((s16)b.half[i] &gt;&gt; imm) + (((s16)b.half[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 8];\n    } else {\n      temp =\n          ((s16)a.half[i - 8] &gt;&gt; imm) + (((s16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)b.half[i - 8];\n    } else {\n      temp =\n          ((s16)b.half[i - 8] &gt;&gt; imm) + (((s16)b.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  } else {\n    s16 temp;\n    if (imm == 0) {\n      temp = (s16)a.half[i - 16];\n    } else {\n      temp = ((s16)a.half[i - 16] &gt;&gt; imm) +\n             (((s16)a.half[i - 16] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;s16&gt;(temp, 0, 255);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarni_d_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvssrarni.d.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 128-bit elements in `a` and `b` by `imm`, clamp to fit in signed 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i];\n    } else {\n      temp = ((s128)b.qword[i] >> imm) + (((s128)b.qword[i] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 1];\n    } else {\n      temp = ((s128)a.qword[i - 1] >> imm) +\n             (((s128)a.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i - 1];\n    } else {\n      temp = ((s128)b.qword[i - 1] >> imm) +\n             (((s128)b.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 2];\n    } else {\n      temp = ((s128)a.qword[i - 2] >> imm) +\n             (((s128)a.qword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarni.d.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i];\n    } else {\n      temp = ((s128)b.qword[i] &gt;&gt; imm) + (((s128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 1];\n    } else {\n      temp = ((s128)a.qword[i - 1] &gt;&gt; imm) +\n             (((s128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i - 1];\n    } else {\n      temp = ((s128)b.qword[i - 1] &gt;&gt; imm) +\n             (((s128)b.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 2];\n    } else {\n      temp = ((s128)a.qword[i - 2] &gt;&gt; imm) +\n             (((s128)a.qword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, -9223372036854775808, 9223372036854775807);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarni_du_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarni_du_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvssrarni.du.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 128-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i];\n    } else {\n      temp = ((s128)b.qword[i] >> imm) + (((s128)b.qword[i] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 1];\n    } else {\n      temp = ((s128)a.qword[i - 1] >> imm) +\n             (((s128)a.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i - 1];\n    } else {\n      temp = ((s128)b.qword[i - 1] >> imm) +\n             (((s128)b.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 2];\n    } else {\n      temp = ((s128)a.qword[i - 2] >> imm) +\n             (((s128)a.qword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<s128>(temp, 0, 18446744073709551615);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarni_du_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarni.du.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i];\n    } else {\n      temp = ((s128)b.qword[i] &gt;&gt; imm) + (((s128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 1];\n    } else {\n      temp = ((s128)a.qword[i - 1] &gt;&gt; imm) +\n             (((s128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)b.qword[i - 1];\n    } else {\n      temp = ((s128)b.qword[i - 1] &gt;&gt; imm) +\n             (((s128)b.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    s128 temp;\n    if (imm == 0) {\n      temp = (s128)a.qword[i - 2];\n    } else {\n      temp = ((s128)a.qword[i - 2] &gt;&gt; imm) +\n             (((s128)a.qword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;s128&gt;(temp, 0, 18446744073709551615);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarni_h_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvssrarni.h.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` and `b` by `imm`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i];\n    } else {\n      temp = ((s32)b.word[i] >> imm) + (((s32)b.word[i] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp =\n          ((s32)a.word[i - 4] >> imm) + (((s32)a.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i - 4];\n    } else {\n      temp =\n          ((s32)b.word[i - 4] >> imm) + (((s32)b.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 8];\n    } else {\n      temp =\n          ((s32)a.word[i - 8] >> imm) + (((s32)a.word[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, -32768, 32767);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarni.h.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i];\n    } else {\n      temp = ((s32)b.word[i] &gt;&gt; imm) + (((s32)b.word[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp =\n          ((s32)a.word[i - 4] &gt;&gt; imm) + (((s32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i - 4];\n    } else {\n      temp =\n          ((s32)b.word[i - 4] &gt;&gt; imm) + (((s32)b.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 8];\n    } else {\n      temp =\n          ((s32)a.word[i - 8] &gt;&gt; imm) + (((s32)a.word[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, -32768, 32767);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarni_hu_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarni_hu_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvssrarni.hu.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 32-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i];\n    } else {\n      temp = ((s32)b.word[i] >> imm) + (((s32)b.word[i] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp =\n          ((s32)a.word[i - 4] >> imm) + (((s32)a.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i - 4];\n    } else {\n      temp =\n          ((s32)b.word[i - 4] >> imm) + (((s32)b.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 8];\n    } else {\n      temp =\n          ((s32)a.word[i - 8] >> imm) + (((s32)a.word[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<s32>(temp, 0, 65535);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarni_hu_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarni.hu.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i];\n    } else {\n      temp = ((s32)b.word[i] &gt;&gt; imm) + (((s32)b.word[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 4];\n    } else {\n      temp =\n          ((s32)a.word[i - 4] &gt;&gt; imm) + (((s32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)b.word[i - 4];\n    } else {\n      temp =\n          ((s32)b.word[i - 4] &gt;&gt; imm) + (((s32)b.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  } else {\n    s32 temp;\n    if (imm == 0) {\n      temp = (s32)a.word[i - 8];\n    } else {\n      temp =\n          ((s32)a.word[i - 8] &gt;&gt; imm) + (((s32)a.word[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;s32&gt;(temp, 0, 65535);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarni_w_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvssrarni.w.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` and `b` by `imm`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i];\n    } else {\n      temp = ((s64)b.dword[i] >> imm) + (((s64)b.dword[i] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] >> imm) +\n             (((s64)a.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i - 2];\n    } else {\n      temp = ((s64)b.dword[i - 2] >> imm) +\n             (((s64)b.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 4];\n    } else {\n      temp = ((s64)a.dword[i - 4] >> imm) +\n             (((s64)a.dword[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, -2147483648, 2147483647);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarni.w.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i];\n    } else {\n      temp = ((s64)b.dword[i] &gt;&gt; imm) + (((s64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] &gt;&gt; imm) +\n             (((s64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i - 2];\n    } else {\n      temp = ((s64)b.dword[i - 2] &gt;&gt; imm) +\n             (((s64)b.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 4];\n    } else {\n      temp = ((s64)a.dword[i - 4] &gt;&gt; imm) +\n             (((s64)a.dword[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, -2147483648, 2147483647);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrarni_wu_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrarni_wu_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvssrarni.wu.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nArithmetic right shift (with rounding) the signed 64-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i];\n    } else {\n      temp = ((s64)b.dword[i] >> imm) + (((s64)b.dword[i] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] >> imm) +\n             (((s64)a.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i - 2];\n    } else {\n      temp = ((s64)b.dword[i - 2] >> imm) +\n             (((s64)b.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 4];\n    } else {\n      temp = ((s64)a.dword[i - 4] >> imm) +\n             (((s64)a.dword[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<s64>(temp, 0, 4294967295);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrarni_wu_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrarni.wu.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Arithmetic right shift (with rounding) the signed 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i];\n    } else {\n      temp = ((s64)b.dword[i] &gt;&gt; imm) + (((s64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 2];\n    } else {\n      temp = ((s64)a.dword[i - 2] &gt;&gt; imm) +\n             (((s64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)b.dword[i - 2];\n    } else {\n      temp = ((s64)b.dword[i - 2] &gt;&gt; imm) +\n             (((s64)b.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  } else {\n    s64 temp;\n    if (imm == 0) {\n      temp = (s64)a.dword[i - 4];\n    } else {\n      temp = ((s64)a.dword[i - 4] &gt;&gt; imm) +\n             (((s64)a.dword[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;s64&gt;(temp, 0, 4294967295);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrln_b_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrln_b_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrln.b.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by elements in `b`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp = (u16)a.half[i] >> (b.half[i] & 15);\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u16 temp = (u16)a.half[i - 8] >> (b.half[i - 8] & 15);\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrln_b_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrln.b.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp = (u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15);\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u16 temp = (u16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15);\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrln_bu_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrln_bu_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrln.bu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` by elements in `b`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp = (u16)a.half[i] >> (b.half[i] & 15);\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u16 temp = (u16)a.half[i - 8] >> (b.half[i - 8] & 15);\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrln_bu_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrln.bu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp = (u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15);\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u16 temp = (u16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15);\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrln_h_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrln_h_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrln.h.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by elements in `b`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp = (u32)a.word[i] >> (b.word[i] & 31);\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u32 temp = (u32)a.word[i - 4] >> (b.word[i - 4] & 31);\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrln_h_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrln.h.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp = (u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31);\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u32 temp = (u32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31);\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrln_hu_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrln_hu_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrln.hu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` by elements in `b`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp = (u32)a.word[i] >> (b.word[i] & 31);\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u32 temp = (u32)a.word[i - 4] >> (b.word[i - 4] & 31);\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrln_hu_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrln.hu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp = (u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31);\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u32 temp = (u32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31);\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrln_w_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrln_w_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrln.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by elements in `b`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp = (u64)a.dword[i] >> (b.dword[i] & 63);\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u64 temp = (u64)a.dword[i - 2] >> (b.dword[i - 2] & 63);\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrln_w_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrln.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp = (u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63);\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u64 temp = (u64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63);\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrln_wu_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrln_wu_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrln.wu.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` by elements in `b`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp = (u64)a.dword[i] >> (b.dword[i] & 63);\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u64 temp = (u64)a.dword[i - 2] >> (b.dword[i - 2] & 63);\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrln_wu_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrln.wu.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp = (u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63);\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u64 temp = (u64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63);\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlni_b_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlni.b.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` and `b` by `imm`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp = (u16)b.half[i] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    u16 temp = (u16)a.half[i - 8] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u16 temp = (u16)b.half[i - 8] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    u16 temp = (u16)a.half[i - 16] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlni.b.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp = (u16)b.half[i] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    u16 temp = (u16)a.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u16 temp = (u16)b.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    u16 temp = (u16)a.half[i - 16] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlni_bu_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlni_bu_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlni.bu.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 16-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp = (u16)b.half[i] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    u16 temp = (u16)a.half[i - 8] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u16 temp = (u16)b.half[i - 8] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    u16 temp = (u16)a.half[i - 16] >> imm;\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlni_bu_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlni.bu.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp = (u16)b.half[i] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    u16 temp = (u16)a.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u16 temp = (u16)b.half[i - 8] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    u16 temp = (u16)a.half[i - 16] &gt;&gt; imm;\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlni_d_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlni.d.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 128-bit elements in `a` and `b` by `imm`, clamp to fit in signed 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    u128 temp = (u128)b.qword[i] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp = (u128)a.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    u128 temp = (u128)b.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp = (u128)a.qword[i - 2] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlni.d.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    u128 temp = (u128)b.qword[i] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp = (u128)a.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    u128 temp = (u128)b.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp = (u128)a.qword[i - 2] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlni_du_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlni_du_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlni.du.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 128-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    u128 temp = (u128)b.qword[i] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp = (u128)a.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    u128 temp = (u128)b.qword[i - 1] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp = (u128)a.qword[i - 2] >> imm;\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlni_du_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlni.du.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    u128 temp = (u128)b.qword[i] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp = (u128)a.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    u128 temp = (u128)b.qword[i - 1] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp = (u128)a.qword[i - 2] &gt;&gt; imm;\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlni_h_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlni.h.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` and `b` by `imm`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp = (u32)b.word[i] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    u32 temp = (u32)a.word[i - 4] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u32 temp = (u32)b.word[i - 4] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    u32 temp = (u32)a.word[i - 8] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlni.h.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp = (u32)b.word[i] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    u32 temp = (u32)a.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u32 temp = (u32)b.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    u32 temp = (u32)a.word[i - 8] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlni_hu_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlni_hu_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlni.hu.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 32-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp = (u32)b.word[i] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    u32 temp = (u32)a.word[i - 4] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u32 temp = (u32)b.word[i - 4] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    u32 temp = (u32)a.word[i - 8] >> imm;\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlni_hu_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlni.hu.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp = (u32)b.word[i] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    u32 temp = (u32)a.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u32 temp = (u32)b.word[i - 4] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    u32 temp = (u32)a.word[i - 8] &gt;&gt; imm;\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlni_w_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlni.w.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` and `b` by `imm`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp = (u64)b.dword[i] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    u64 temp = (u64)a.dword[i - 2] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u64 temp = (u64)b.dword[i - 2] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    u64 temp = (u64)a.dword[i - 4] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlni.w.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp = (u64)b.dword[i] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    u64 temp = (u64)a.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u64 temp = (u64)b.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    u64 temp = (u64)a.dword[i - 4] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlni_wu_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlni_wu_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlni.wu.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift the unsigned 64-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp = (u64)b.dword[i] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    u64 temp = (u64)a.dword[i - 2] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u64 temp = (u64)b.dword[i - 2] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    u64 temp = (u64)a.dword[i - 4] >> imm;\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlni_wu_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlni.wu.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp = (u64)b.dword[i] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    u64 temp = (u64)a.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u64 temp = (u64)b.dword[i - 2] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    u64 temp = (u64)a.dword[i - 4] &gt;&gt; imm;\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrn_b_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrn_b_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrlrn.b.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by elements in `b`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp;\n    if ((b.half[i] & 15) == 0) {\n      temp = (u16)a.half[i];\n    } else {\n      temp = ((u16)a.half[i] >> (b.half[i] & 15)) +\n             (((u16)a.half[i] >> ((b.half[i] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u16 temp;\n    if ((b.half[i - 8] & 15) == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp = ((u16)a.half[i - 8] >> (b.half[i - 8] & 15)) +\n             (((u16)a.half[i - 8] >> ((b.half[i - 8] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrn_b_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrn.b.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp;\n    if ((b.half[i] &amp; 15) == 0) {\n      temp = (u16)a.half[i];\n    } else {\n      temp = ((u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) +\n             (((u16)a.half[i] &gt;&gt; ((b.half[i] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u16 temp;\n    if ((b.half[i - 8] &amp; 15) == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp = ((u16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15)) +\n             (((u16)a.half[i - 8] &gt;&gt; ((b.half[i - 8] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrn_bu_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrn_bu_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrlrn.bu.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` by elements in `b`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp;\n    if ((b.half[i] & 15) == 0) {\n      temp = (u16)a.half[i];\n    } else {\n      temp = ((u16)a.half[i] >> (b.half[i] & 15)) +\n             (((u16)a.half[i] >> ((b.half[i] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u16 temp;\n    if ((b.half[i - 8] & 15) == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp = ((u16)a.half[i - 8] >> (b.half[i - 8] & 15)) +\n             (((u16)a.half[i - 8] >> ((b.half[i - 8] & 15) - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrn_bu_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrn.bu.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp;\n    if ((b.half[i] &amp; 15) == 0) {\n      temp = (u16)a.half[i];\n    } else {\n      temp = ((u16)a.half[i] &gt;&gt; (b.half[i] &amp; 15)) +\n             (((u16)a.half[i] &gt;&gt; ((b.half[i] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u16 temp;\n    if ((b.half[i - 8] &amp; 15) == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp = ((u16)a.half[i - 8] &gt;&gt; (b.half[i - 8] &amp; 15)) +\n             (((u16)a.half[i - 8] &gt;&gt; ((b.half[i - 8] &amp; 15) - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    dst.byte[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrn_h_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrn_h_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrlrn.h.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by elements in `b`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp;\n    if ((b.word[i] & 31) == 0) {\n      temp = (u32)a.word[i];\n    } else {\n      temp = ((u32)a.word[i] >> (b.word[i] & 31)) +\n             (((u32)a.word[i] >> ((b.word[i] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u32 temp;\n    if ((b.word[i - 4] & 31) == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp = ((u32)a.word[i - 4] >> (b.word[i - 4] & 31)) +\n             (((u32)a.word[i - 4] >> ((b.word[i - 4] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrn_h_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrn.h.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp;\n    if ((b.word[i] &amp; 31) == 0) {\n      temp = (u32)a.word[i];\n    } else {\n      temp = ((u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) +\n             (((u32)a.word[i] &gt;&gt; ((b.word[i] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u32 temp;\n    if ((b.word[i - 4] &amp; 31) == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp = ((u32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31)) +\n             (((u32)a.word[i - 4] &gt;&gt; ((b.word[i - 4] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrn_hu_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrn_hu_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrlrn.hu.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` by elements in `b`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp;\n    if ((b.word[i] & 31) == 0) {\n      temp = (u32)a.word[i];\n    } else {\n      temp = ((u32)a.word[i] >> (b.word[i] & 31)) +\n             (((u32)a.word[i] >> ((b.word[i] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u32 temp;\n    if ((b.word[i - 4] & 31) == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp = ((u32)a.word[i - 4] >> (b.word[i - 4] & 31)) +\n             (((u32)a.word[i - 4] >> ((b.word[i - 4] & 31) - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrn_hu_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrn.hu.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp;\n    if ((b.word[i] &amp; 31) == 0) {\n      temp = (u32)a.word[i];\n    } else {\n      temp = ((u32)a.word[i] &gt;&gt; (b.word[i] &amp; 31)) +\n             (((u32)a.word[i] &gt;&gt; ((b.word[i] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u32 temp;\n    if ((b.word[i - 4] &amp; 31) == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp = ((u32)a.word[i - 4] &gt;&gt; (b.word[i - 4] &amp; 31)) +\n             (((u32)a.word[i - 4] &gt;&gt; ((b.word[i - 4] &amp; 31) - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    dst.half[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrn_w_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrn_w_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrlrn.w.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by elements in `b`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp;\n    if ((b.dword[i] & 63) == 0) {\n      temp = (u64)a.dword[i];\n    } else {\n      temp = ((u64)a.dword[i] >> (b.dword[i] & 63)) +\n             (((u64)a.dword[i] >> ((b.dword[i] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u64 temp;\n    if ((b.dword[i - 2] & 63) == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] >> (b.dword[i - 2] & 63)) +\n             (((u64)a.dword[i - 2] >> ((b.dword[i - 2] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrn_w_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrn.w.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp;\n    if ((b.dword[i] &amp; 63) == 0) {\n      temp = (u64)a.dword[i];\n    } else {\n      temp = ((u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) +\n             (((u64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u64 temp;\n    if ((b.dword[i - 2] &amp; 63) == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63)) +\n             (((u64)a.dword[i - 2] &gt;&gt; ((b.dword[i - 2] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrn_wu_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrn_wu_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssrlrn.wu.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` by elements in `b`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp;\n    if ((b.dword[i] & 63) == 0) {\n      temp = (u64)a.dword[i];\n    } else {\n      temp = ((u64)a.dword[i] >> (b.dword[i] & 63)) +\n             (((u64)a.dword[i] >> ((b.dword[i] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u64 temp;\n    if ((b.dword[i - 2] & 63) == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] >> (b.dword[i - 2] & 63)) +\n             (((u64)a.dword[i - 2] >> ((b.dword[i - 2] & 63) - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrn_wu_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrn.wu.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> by elements in <code>b</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp;\n    if ((b.dword[i] &amp; 63) == 0) {\n      temp = (u64)a.dword[i];\n    } else {\n      temp = ((u64)a.dword[i] &gt;&gt; (b.dword[i] &amp; 63)) +\n             (((u64)a.dword[i] &gt;&gt; ((b.dword[i] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u64 temp;\n    if ((b.dword[i - 2] &amp; 63) == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] &gt;&gt; (b.dword[i - 2] &amp; 63)) +\n             (((u64)a.dword[i - 2] &gt;&gt; ((b.dword[i - 2] &amp; 63) - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    dst.word[i] = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrni_b_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlrni.b.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` and `b` by `imm`, clamp to fit in signed 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i];\n    } else {\n      temp = ((u16)b.half[i] >> imm) + (((u16)b.half[i] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp =\n          ((u16)a.half[i - 8] >> imm) + (((u16)a.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i - 8];\n    } else {\n      temp =\n          ((u16)b.half[i - 8] >> imm) + (((u16)b.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 16];\n    } else {\n      temp = ((u16)a.half[i - 16] >> imm) +\n             (((u16)a.half[i - 16] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 127);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrni_b_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrni.b.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i];\n    } else {\n      temp = ((u16)b.half[i] &gt;&gt; imm) + (((u16)b.half[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp =\n          ((u16)a.half[i - 8] &gt;&gt; imm) + (((u16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i - 8];\n    } else {\n      temp =\n          ((u16)b.half[i - 8] &gt;&gt; imm) + (((u16)b.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 16];\n    } else {\n      temp = ((u16)a.half[i - 16] &gt;&gt; imm) +\n             (((u16)a.half[i - 16] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 127);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrni_bu_h (__m256i a, __m256i b, imm0_15 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrni_bu_h (__m256i a, __m256i b, imm0_15 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlrni.bu.h xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 16-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 8-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  if (i < 8) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i];\n    } else {\n      temp = ((u16)b.half[i] >> imm) + (((u16)b.half[i] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp =\n          ((u16)a.half[i - 8] >> imm) + (((u16)a.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  }\n}\nfor (int i = 16; i < 32; i++) {\n  if (i < 24) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i - 8];\n    } else {\n      temp =\n          ((u16)b.half[i - 8] >> imm) + (((u16)b.half[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 16];\n    } else {\n      temp = ((u16)a.half[i - 16] >> imm) +\n             (((u16)a.half[i - 16] >> (imm - 1)) & 1);\n    }\n    dst.byte[i] = clamp<u16>(temp, 0, 255);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrni_bu_h (__m256i a, __m256i b, imm0_15 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrni.bu.h xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 16-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 8-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  if (i &lt; 8) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i];\n    } else {\n      temp = ((u16)b.half[i] &gt;&gt; imm) + (((u16)b.half[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 8];\n    } else {\n      temp =\n          ((u16)a.half[i - 8] &gt;&gt; imm) + (((u16)a.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  }\n}\nfor (int i = 16; i &lt; 32; i++) {\n  if (i &lt; 24) {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)b.half[i - 8];\n    } else {\n      temp =\n          ((u16)b.half[i - 8] &gt;&gt; imm) + (((u16)b.half[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  } else {\n    u16 temp;\n    if (imm == 0) {\n      temp = (u16)a.half[i - 16];\n    } else {\n      temp = ((u16)a.half[i - 16] &gt;&gt; imm) +\n             (((u16)a.half[i - 16] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.byte[i] = clamp&lt;u16&gt;(temp, 0, 255);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrni_d_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlrni.d.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 128-bit elements in `a` and `b` by `imm`, clamp to fit in signed 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i];\n    } else {\n      temp = ((u128)b.qword[i] >> imm) + (((u128)b.qword[i] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 1];\n    } else {\n      temp = ((u128)a.qword[i - 1] >> imm) +\n             (((u128)a.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i - 1];\n    } else {\n      temp = ((u128)b.qword[i - 1] >> imm) +\n             (((u128)b.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 2];\n    } else {\n      temp = ((u128)a.qword[i - 2] >> imm) +\n             (((u128)a.qword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 9223372036854775807);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrni_d_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrni.d.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i];\n    } else {\n      temp = ((u128)b.qword[i] &gt;&gt; imm) + (((u128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 1];\n    } else {\n      temp = ((u128)a.qword[i - 1] &gt;&gt; imm) +\n             (((u128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i - 1];\n    } else {\n      temp = ((u128)b.qword[i - 1] &gt;&gt; imm) +\n             (((u128)b.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 2];\n    } else {\n      temp = ((u128)a.qword[i - 2] &gt;&gt; imm) +\n             (((u128)a.qword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 9223372036854775807);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrni_du_q (__m256i a, __m256i b, imm0_127 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrni_du_q (__m256i a, __m256i b, imm0_127 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlrni.du.q xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 128-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 64-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  if (i < 1) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i];\n    } else {\n      temp = ((u128)b.qword[i] >> imm) + (((u128)b.qword[i] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 1];\n    } else {\n      temp = ((u128)a.qword[i - 1] >> imm) +\n             (((u128)a.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  }\n}\nfor (int i = 2; i < 4; i++) {\n  if (i < 3) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i - 1];\n    } else {\n      temp = ((u128)b.qword[i - 1] >> imm) +\n             (((u128)b.qword[i - 1] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 2];\n    } else {\n      temp = ((u128)a.qword[i - 2] >> imm) +\n             (((u128)a.qword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.dword[i] = clamp<u128>(temp, 0, 18446744073709551615);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrni_du_q (__m256i a, __m256i b, imm0_127 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrni.du.q xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 128-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 64-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  if (i &lt; 1) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i];\n    } else {\n      temp = ((u128)b.qword[i] &gt;&gt; imm) + (((u128)b.qword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 1];\n    } else {\n      temp = ((u128)a.qword[i - 1] &gt;&gt; imm) +\n             (((u128)a.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  }\n}\nfor (int i = 2; i &lt; 4; i++) {\n  if (i &lt; 3) {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)b.qword[i - 1];\n    } else {\n      temp = ((u128)b.qword[i - 1] &gt;&gt; imm) +\n             (((u128)b.qword[i - 1] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  } else {\n    u128 temp;\n    if (imm == 0) {\n      temp = (u128)a.qword[i - 2];\n    } else {\n      temp = ((u128)a.qword[i - 2] &gt;&gt; imm) +\n             (((u128)a.qword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.dword[i] = clamp&lt;u128&gt;(temp, 0, 18446744073709551615);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrni_h_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlrni.h.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` and `b` by `imm`, clamp to fit in signed 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i];\n    } else {\n      temp = ((u32)b.word[i] >> imm) + (((u32)b.word[i] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp =\n          ((u32)a.word[i - 4] >> imm) + (((u32)a.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i - 4];\n    } else {\n      temp =\n          ((u32)b.word[i - 4] >> imm) + (((u32)b.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 8];\n    } else {\n      temp =\n          ((u32)a.word[i - 8] >> imm) + (((u32)a.word[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 32767);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrni_h_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrni.h.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i];\n    } else {\n      temp = ((u32)b.word[i] &gt;&gt; imm) + (((u32)b.word[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp =\n          ((u32)a.word[i - 4] &gt;&gt; imm) + (((u32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i - 4];\n    } else {\n      temp =\n          ((u32)b.word[i - 4] &gt;&gt; imm) + (((u32)b.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 8];\n    } else {\n      temp =\n          ((u32)a.word[i - 8] &gt;&gt; imm) + (((u32)a.word[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 32767);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrni_hu_w (__m256i a, __m256i b, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrni_hu_w (__m256i a, __m256i b, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlrni.hu.w xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 32-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 16-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  if (i < 4) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i];\n    } else {\n      temp = ((u32)b.word[i] >> imm) + (((u32)b.word[i] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp =\n          ((u32)a.word[i - 4] >> imm) + (((u32)a.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  }\n}\nfor (int i = 8; i < 16; i++) {\n  if (i < 12) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i - 4];\n    } else {\n      temp =\n          ((u32)b.word[i - 4] >> imm) + (((u32)b.word[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 8];\n    } else {\n      temp =\n          ((u32)a.word[i - 8] >> imm) + (((u32)a.word[i - 8] >> (imm - 1)) & 1);\n    }\n    dst.half[i] = clamp<u32>(temp, 0, 65535);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrni_hu_w (__m256i a, __m256i b, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrni.hu.w xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 32-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 16-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  if (i &lt; 4) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i];\n    } else {\n      temp = ((u32)b.word[i] &gt;&gt; imm) + (((u32)b.word[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 4];\n    } else {\n      temp =\n          ((u32)a.word[i - 4] &gt;&gt; imm) + (((u32)a.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  }\n}\nfor (int i = 8; i &lt; 16; i++) {\n  if (i &lt; 12) {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)b.word[i - 4];\n    } else {\n      temp =\n          ((u32)b.word[i - 4] &gt;&gt; imm) + (((u32)b.word[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  } else {\n    u32 temp;\n    if (imm == 0) {\n      temp = (u32)a.word[i - 8];\n    } else {\n      temp =\n          ((u32)a.word[i - 8] &gt;&gt; imm) + (((u32)a.word[i - 8] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.half[i] = clamp&lt;u32&gt;(temp, 0, 65535);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrni_w_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlrni.w.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` and `b` by `imm`, clamp to fit in signed 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i];\n    } else {\n      temp = ((u64)b.dword[i] >> imm) + (((u64)b.dword[i] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] >> imm) +\n             (((u64)a.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i - 2];\n    } else {\n      temp = ((u64)b.dword[i - 2] >> imm) +\n             (((u64)b.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 4];\n    } else {\n      temp = ((u64)a.dword[i - 4] >> imm) +\n             (((u64)a.dword[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 2147483647);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrni_w_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrni.w.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in signed 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i];\n    } else {\n      temp = ((u64)b.dword[i] &gt;&gt; imm) + (((u64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] &gt;&gt; imm) +\n             (((u64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i - 2];\n    } else {\n      temp = ((u64)b.dword[i - 2] &gt;&gt; imm) +\n             (((u64)b.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 4];\n    } else {\n      temp = ((u64)a.dword[i - 4] &gt;&gt; imm) +\n             (((u64)a.dword[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 2147483647);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssrlrni_wu_d (__m256i a, __m256i b, imm0_63 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssrlrni_wu_d (__m256i a, __m256i b, imm0_63 imm)\n#include <lasxintrin.h>\nInstruction: xvssrlrni.wu.d xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nLogical right shift (with rounding) the unsigned 64-bit elements in `a` and `b` by `imm`, clamp to fit in unsigned 32-bit integer and store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  if (i < 2) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i];\n    } else {\n      temp = ((u64)b.dword[i] >> imm) + (((u64)b.dword[i] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] >> imm) +\n             (((u64)a.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  }\n}\nfor (int i = 4; i < 8; i++) {\n  if (i < 6) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i - 2];\n    } else {\n      temp = ((u64)b.dword[i - 2] >> imm) +\n             (((u64)b.dword[i - 2] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 4];\n    } else {\n      temp = ((u64)a.dword[i - 4] >> imm) +\n             (((u64)a.dword[i - 4] >> (imm - 1)) & 1);\n    }\n    dst.word[i] = clamp<u64>(temp, 0, 4294967295);\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 4 | 1 |\n| 3A6000 | LA664 | 4 | 2 |\n| 3C6000 | LA664 | 4 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssrlrni_wu_d (__m256i a, __m256i b, imm0_63 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssrlrni.wu.d xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Logical right shift (with rounding) the unsigned 64-bit elements in <code>a</code> and <code>b</code> by <code>imm</code>, clamp to fit in unsigned 32-bit integer and store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  if (i &lt; 2) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i];\n    } else {\n      temp = ((u64)b.dword[i] &gt;&gt; imm) + (((u64)b.dword[i] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 2];\n    } else {\n      temp = ((u64)a.dword[i - 2] &gt;&gt; imm) +\n             (((u64)a.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  }\n}\nfor (int i = 4; i &lt; 8; i++) {\n  if (i &lt; 6) {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)b.dword[i - 2];\n    } else {\n      temp = ((u64)b.dword[i - 2] &gt;&gt; imm) +\n             (((u64)b.dword[i - 2] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  } else {\n    u64 temp;\n    if (imm == 0) {\n      temp = (u64)a.dword[i - 4];\n    } else {\n      temp = ((u64)a.dword[i - 4] &gt;&gt; imm) +\n             (((u64)a.dword[i - 4] &gt;&gt; (imm - 1)) &amp; 1);\n    }\n    dst.word[i] = clamp&lt;u64&gt;(temp, 0, 4294967295);\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Shift", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssub_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssub_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssub.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating subtract the signed 8-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (s8)ssub((s8)a.byte[i], (s8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssub_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssub.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the signed 8-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (s8)ssub((s8)a.byte[i], (s8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssub_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssub_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssub.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating subtract the unsigned 8-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = (u8)ssub((u8)a.byte[i], (u8)b.byte[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssub_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssub.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the unsigned 8-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = (u8)ssub((u8)a.byte[i], (u8)b.byte[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssub_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssub_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssub.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating subtract the signed 64-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)ssub((s64)a.dword[i], (s64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssub_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssub.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the signed 64-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)ssub((s64)a.dword[i], (s64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssub_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssub_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssub.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating subtract the unsigned 64-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)ssub((u64)a.dword[i], (u64)b.dword[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssub_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssub.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the unsigned 64-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)ssub((u64)a.dword[i], (u64)b.dword[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssub_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssub_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssub.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating subtract the signed 16-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)ssub((s16)a.half[i], (s16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssub_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssub.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the signed 16-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)ssub((s16)a.half[i], (s16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssub_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssub_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssub.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating subtract the unsigned 16-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)ssub((u16)a.half[i], (u16)b.half[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssub_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssub.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the unsigned 16-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)ssub((u16)a.half[i], (u16)b.half[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssub_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssub_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssub.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating subtract the signed 32-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)ssub((s32)a.word[i], (s32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssub_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssub.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the signed 32-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)ssub((s32)a.word[i], (s32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvssub_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvssub_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvssub.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSaturating subtract the unsigned 32-bit elements in `a` and `b`, store the result to `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)ssub((u32)a.word[i], (u32)b.word[i]);\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvssub_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvssub.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Saturating subtract the unsigned 32-bit elements in <code>a</code> and <code>b</code>, store the result to <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)ssub((u32)a.word[i], (u32)b.word[i]);\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsub_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsub_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsub.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 8-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] - b.byte[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsub_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsub.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 8-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] - b.byte[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsub_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsub_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsub.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 64-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] - b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsub_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsub.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 64-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] - b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsub_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsub_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsub.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 16-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] - b.half[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsub_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsub.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 16-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] - b.half[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsub_q (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsub_q (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsub.q xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 128-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = a.qword[i] - b.qword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsub_q (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsub.q xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 128-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = a.qword[i] - b.qword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsub_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsub_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsub.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 32-bit elements in `a` and `b`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] - b.word[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsub_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsub.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 32-bit elements in <code>a</code> and <code>b</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] - b.word[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubi_bu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubi_bu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsubi.bu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 8-bit elements in `a` by `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] - imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubi_bu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubi.bu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 8-bit elements in <code>a</code> by <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] - imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubi_du (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubi_du (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsubi.du xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 64-bit elements in `a` by `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] - imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubi_du (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubi.du xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 64-bit elements in <code>a</code> by <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] - imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubi_hu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubi_hu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsubi.hu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 16-bit elements in `a` by `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = a.half[i] - imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubi_hu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubi.hu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 16-bit elements in <code>a</code> by <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = a.half[i] - imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubi_wu (__m256i a, imm0_31 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubi_wu (__m256i a, imm0_31 imm)\n#include <lasxintrin.h>\nInstruction: xvsubi.wu xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract 32-bit elements in `a` by `imm`, save the result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = a.word[i] - imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubi_wu (__m256i a, imm0_31 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubi.wu xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract 32-bit elements in <code>a</code> by <code>imm</code>, save the result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = a.word[i] - imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwev_d_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwev_d_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwev.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract even-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] - (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) - ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) - ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[4])) - ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[6])) - ((s64)((s32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwev_d_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwev.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i] - (s64)(s32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[0])) - ((s64)((s32)b.word[0]));\n  dst.dword[1] = ((s64)((s32)a.word[2])) - ((s64)((s32)b.word[2]));\n  dst.dword[2] = ((s64)((s32)a.word[4])) - ((s64)((s32)b.word[4]));\n  dst.dword[3] = ((s64)((s32)a.word[6])) - ((s64)((s32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwev_d_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwev_d_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwev.d.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract even-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] - (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) - ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) - ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) - ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) - ((u64)((u32)b.word[6]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwev_d_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwev.d.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i] - (u64)(u32)b.word[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[0])) - ((u64)((u32)b.word[0]));\n  dst.dword[1] = ((u64)((u32)a.word[2])) - ((u64)((u32)b.word[2]));\n  dst.dword[2] = ((u64)((u32)a.word[4])) - ((u64)((u32)b.word[4]));\n  dst.dword[3] = ((u64)((u32)a.word[6])) - ((u64)((u32)b.word[6]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwev_h_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwev_h_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwev.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract even-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] - (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) - ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) - ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) - ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) - ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) - ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) - ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) - ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) - ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[16])) - ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[18])) - ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[20])) - ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[22])) - ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[24])) - ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[26])) - ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[28])) - ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[30])) - ((s16)((s8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwev_h_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwev.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i] - (s16)(s8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[0])) - ((s16)((s8)b.byte[0]));\n  dst.half[1] = ((s16)((s8)a.byte[2])) - ((s16)((s8)b.byte[2]));\n  dst.half[2] = ((s16)((s8)a.byte[4])) - ((s16)((s8)b.byte[4]));\n  dst.half[3] = ((s16)((s8)a.byte[6])) - ((s16)((s8)b.byte[6]));\n  dst.half[4] = ((s16)((s8)a.byte[8])) - ((s16)((s8)b.byte[8]));\n  dst.half[5] = ((s16)((s8)a.byte[10])) - ((s16)((s8)b.byte[10]));\n  dst.half[6] = ((s16)((s8)a.byte[12])) - ((s16)((s8)b.byte[12]));\n  dst.half[7] = ((s16)((s8)a.byte[14])) - ((s16)((s8)b.byte[14]));\n  dst.half[8] = ((s16)((s8)a.byte[16])) - ((s16)((s8)b.byte[16]));\n  dst.half[9] = ((s16)((s8)a.byte[18])) - ((s16)((s8)b.byte[18]));\n  dst.half[10] = ((s16)((s8)a.byte[20])) - ((s16)((s8)b.byte[20]));\n  dst.half[11] = ((s16)((s8)a.byte[22])) - ((s16)((s8)b.byte[22]));\n  dst.half[12] = ((s16)((s8)a.byte[24])) - ((s16)((s8)b.byte[24]));\n  dst.half[13] = ((s16)((s8)a.byte[26])) - ((s16)((s8)b.byte[26]));\n  dst.half[14] = ((s16)((s8)a.byte[28])) - ((s16)((s8)b.byte[28]));\n  dst.half[15] = ((s16)((s8)a.byte[30])) - ((s16)((s8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwev_h_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwev_h_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwev.h.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract even-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] - (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) - ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) - ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) - ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) - ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) - ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) - ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) - ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) - ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) - ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) - ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) - ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) - ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) - ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) - ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) - ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) - ((u16)((u8)b.byte[30]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwev_h_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwev.h.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i] - (u16)(u8)b.byte[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[0])) - ((u16)((u8)b.byte[0]));\n  dst.half[1] = ((u16)((u8)a.byte[2])) - ((u16)((u8)b.byte[2]));\n  dst.half[2] = ((u16)((u8)a.byte[4])) - ((u16)((u8)b.byte[4]));\n  dst.half[3] = ((u16)((u8)a.byte[6])) - ((u16)((u8)b.byte[6]));\n  dst.half[4] = ((u16)((u8)a.byte[8])) - ((u16)((u8)b.byte[8]));\n  dst.half[5] = ((u16)((u8)a.byte[10])) - ((u16)((u8)b.byte[10]));\n  dst.half[6] = ((u16)((u8)a.byte[12])) - ((u16)((u8)b.byte[12]));\n  dst.half[7] = ((u16)((u8)a.byte[14])) - ((u16)((u8)b.byte[14]));\n  dst.half[8] = ((u16)((u8)a.byte[16])) - ((u16)((u8)b.byte[16]));\n  dst.half[9] = ((u16)((u8)a.byte[18])) - ((u16)((u8)b.byte[18]));\n  dst.half[10] = ((u16)((u8)a.byte[20])) - ((u16)((u8)b.byte[20]));\n  dst.half[11] = ((u16)((u8)a.byte[22])) - ((u16)((u8)b.byte[22]));\n  dst.half[12] = ((u16)((u8)a.byte[24])) - ((u16)((u8)b.byte[24]));\n  dst.half[13] = ((u16)((u8)a.byte[26])) - ((u16)((u8)b.byte[26]));\n  dst.half[14] = ((u16)((u8)a.byte[28])) - ((u16)((u8)b.byte[28]));\n  dst.half[15] = ((u16)((u8)a.byte[30])) - ((u16)((u8)b.byte[30]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwev_q_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwev_q_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwev.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract even-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] - (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) - ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[2])) - ((s128)((s64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwev_q_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwev.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i] - (s128)(s64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[0])) - ((s128)((s64)b.dword[0]));\n  dst.qword[1] = ((s128)((s64)a.dword[2])) - ((s128)((s64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwev_q_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwev_q_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwev.q.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract even-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] - (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) - ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) - ((u128)((u64)b.dword[2]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwev_q_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwev.q.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i] - (u128)(u64)b.dword[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[0])) - ((u128)((u64)b.dword[0]));\n  dst.qword[1] = ((u128)((u64)a.dword[2])) - ((u128)((u64)b.dword[2]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwev_w_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwev_w_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwev.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract even-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] - (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) - ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) - ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) - ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) - ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[8])) - ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[10])) - ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[12])) - ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[14])) - ((s32)((s16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwev_w_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwev.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i] - (s32)(s16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[0])) - ((s32)((s16)b.half[0]));\n  dst.word[1] = ((s32)((s16)a.half[2])) - ((s32)((s16)b.half[2]));\n  dst.word[2] = ((s32)((s16)a.half[4])) - ((s32)((s16)b.half[4]));\n  dst.word[3] = ((s32)((s16)a.half[6])) - ((s32)((s16)b.half[6]));\n  dst.word[4] = ((s32)((s16)a.half[8])) - ((s32)((s16)b.half[8]));\n  dst.word[5] = ((s32)((s16)a.half[10])) - ((s32)((s16)b.half[10]));\n  dst.word[6] = ((s32)((s16)a.half[12])) - ((s32)((s16)b.half[12]));\n  dst.word[7] = ((s32)((s16)a.half[14])) - ((s32)((s16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwev_w_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwev_w_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwev.w.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract even-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] - (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) - ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) - ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) - ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) - ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) - ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) - ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) - ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) - ((u32)((u16)b.half[14]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwev_w_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwev.w.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract even-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i] - (u32)(u16)b.half[2 * i];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[0])) - ((u32)((u16)b.half[0]));\n  dst.word[1] = ((u32)((u16)a.half[2])) - ((u32)((u16)b.half[2]));\n  dst.word[2] = ((u32)((u16)a.half[4])) - ((u32)((u16)b.half[4]));\n  dst.word[3] = ((u32)((u16)a.half[6])) - ((u32)((u16)b.half[6]));\n  dst.word[4] = ((u32)((u16)a.half[8])) - ((u32)((u16)b.half[8]));\n  dst.word[5] = ((u32)((u16)a.half[10])) - ((u32)((u16)b.half[10]));\n  dst.word[6] = ((u32)((u16)a.half[12])) - ((u32)((u16)b.half[12]));\n  dst.word[7] = ((u32)((u16)a.half[14])) - ((u32)((u16)b.half[14]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwod_d_w (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwod_d_w (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwod.d.w xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned signed 32-bit elements in `a` and signed elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] - (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) - ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) - ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) - ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) - ((s64)((s32)b.word[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwod_d_w (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwod.d.w xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 32-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (s64)(s32)a.word[2 * i + 1] - (s64)(s32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((s64)((s32)a.word[1])) - ((s64)((s32)b.word[1]));\n  dst.dword[1] = ((s64)((s32)a.word[3])) - ((s64)((s32)b.word[3]));\n  dst.dword[2] = ((s64)((s32)a.word[5])) - ((s64)((s32)b.word[5]));\n  dst.dword[3] = ((s64)((s32)a.word[7])) - ((s64)((s32)b.word[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwod_d_wu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwod_d_wu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwod.d.wu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 32-bit elements in `a` and unsigned elements in `b`, save the 64-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] - (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) - ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) - ((u64)((u32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) - ((u64)((u32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) - ((u64)((u32)b.word[7]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwod_d_wu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwod.d.wu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 32-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 64-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = (u64)(u32)a.word[2 * i + 1] - (u64)(u32)b.word[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.dword[0] = ((u64)((u32)a.word[1])) - ((u64)((u32)b.word[1]));\n  dst.dword[1] = ((u64)((u32)a.word[3])) - ((u64)((u32)b.word[3]));\n  dst.dword[2] = ((u64)((u32)a.word[5])) - ((u64)((u32)b.word[5]));\n  dst.dword[3] = ((u64)((u32)a.word[7])) - ((u64)((u32)b.word[7]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwod_h_b (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwod_h_b (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwod.h.b xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned signed 8-bit elements in `a` and signed elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] - (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) - ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) - ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) - ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) - ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) - ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) - ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) - ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) - ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) - ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) - ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) - ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) - ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) - ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) - ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) - ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) - ((s16)((s8)b.byte[31]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwod_h_b (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwod.h.b xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 8-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (s16)(s8)a.byte[2 * i + 1] - (s16)(s8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((s16)((s8)a.byte[1])) - ((s16)((s8)b.byte[1]));\n  dst.half[1] = ((s16)((s8)a.byte[3])) - ((s16)((s8)b.byte[3]));\n  dst.half[2] = ((s16)((s8)a.byte[5])) - ((s16)((s8)b.byte[5]));\n  dst.half[3] = ((s16)((s8)a.byte[7])) - ((s16)((s8)b.byte[7]));\n  dst.half[4] = ((s16)((s8)a.byte[9])) - ((s16)((s8)b.byte[9]));\n  dst.half[5] = ((s16)((s8)a.byte[11])) - ((s16)((s8)b.byte[11]));\n  dst.half[6] = ((s16)((s8)a.byte[13])) - ((s16)((s8)b.byte[13]));\n  dst.half[7] = ((s16)((s8)a.byte[15])) - ((s16)((s8)b.byte[15]));\n  dst.half[8] = ((s16)((s8)a.byte[17])) - ((s16)((s8)b.byte[17]));\n  dst.half[9] = ((s16)((s8)a.byte[19])) - ((s16)((s8)b.byte[19]));\n  dst.half[10] = ((s16)((s8)a.byte[21])) - ((s16)((s8)b.byte[21]));\n  dst.half[11] = ((s16)((s8)a.byte[23])) - ((s16)((s8)b.byte[23]));\n  dst.half[12] = ((s16)((s8)a.byte[25])) - ((s16)((s8)b.byte[25]));\n  dst.half[13] = ((s16)((s8)a.byte[27])) - ((s16)((s8)b.byte[27]));\n  dst.half[14] = ((s16)((s8)a.byte[29])) - ((s16)((s8)b.byte[29]));\n  dst.half[15] = ((s16)((s8)a.byte[31])) - ((s16)((s8)b.byte[31]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwod_h_bu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwod_h_bu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwod.h.bu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 8-bit elements in `a` and unsigned elements in `b`, save the 16-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] - (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) - ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) - ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) - ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) - ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) - ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) - ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) - ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) - ((u16)((u8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) - ((u16)((u8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) - ((u16)((u8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) - ((u16)((u8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) - ((u16)((u8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) - ((u16)((u8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) - ((u16)((u8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) - ((u16)((u8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) - ((u16)((u8)b.byte[31]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwod_h_bu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwod.h.bu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 8-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 16-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 16; i++) {\n  dst.half[i] = (u16)(u8)a.byte[2 * i + 1] - (u16)(u8)b.byte[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.half[0] = ((u16)((u8)a.byte[1])) - ((u16)((u8)b.byte[1]));\n  dst.half[1] = ((u16)((u8)a.byte[3])) - ((u16)((u8)b.byte[3]));\n  dst.half[2] = ((u16)((u8)a.byte[5])) - ((u16)((u8)b.byte[5]));\n  dst.half[3] = ((u16)((u8)a.byte[7])) - ((u16)((u8)b.byte[7]));\n  dst.half[4] = ((u16)((u8)a.byte[9])) - ((u16)((u8)b.byte[9]));\n  dst.half[5] = ((u16)((u8)a.byte[11])) - ((u16)((u8)b.byte[11]));\n  dst.half[6] = ((u16)((u8)a.byte[13])) - ((u16)((u8)b.byte[13]));\n  dst.half[7] = ((u16)((u8)a.byte[15])) - ((u16)((u8)b.byte[15]));\n  dst.half[8] = ((u16)((u8)a.byte[17])) - ((u16)((u8)b.byte[17]));\n  dst.half[9] = ((u16)((u8)a.byte[19])) - ((u16)((u8)b.byte[19]));\n  dst.half[10] = ((u16)((u8)a.byte[21])) - ((u16)((u8)b.byte[21]));\n  dst.half[11] = ((u16)((u8)a.byte[23])) - ((u16)((u8)b.byte[23]));\n  dst.half[12] = ((u16)((u8)a.byte[25])) - ((u16)((u8)b.byte[25]));\n  dst.half[13] = ((u16)((u8)a.byte[27])) - ((u16)((u8)b.byte[27]));\n  dst.half[14] = ((u16)((u8)a.byte[29])) - ((u16)((u8)b.byte[29]));\n  dst.half[15] = ((u16)((u8)a.byte[31])) - ((u16)((u8)b.byte[31]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwod_q_d (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwod_q_d (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwod.q.d xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned signed 64-bit elements in `a` and signed elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] - (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) - ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) - ((s128)((s64)b.dword[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwod_q_d (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwod.q.d xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 64-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (s128)(s64)a.dword[2 * i + 1] - (s128)(s64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((s128)((s64)a.dword[1])) - ((s128)((s64)b.dword[1]));\n  dst.qword[1] = ((s128)((s64)a.dword[3])) - ((s128)((s64)b.dword[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwod_q_du (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwod_q_du (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwod.q.du xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 64-bit elements in `a` and unsigned elements in `b`, save the 128-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] - (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) - ((u128)((u64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) - ((u128)((u64)b.dword[3]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 3 | 2 |\n| 3A6000 | LA664 | 3 | 2 |\n| 3C6000 | LA664 | 3 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwod_q_du (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwod.q.du xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 64-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 128-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 2; i++) {\n  dst.qword[i] = (u128)(u64)a.dword[2 * i + 1] - (u128)(u64)b.dword[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.qword[0] = ((u128)((u64)a.dword[1])) - ((u128)((u64)b.dword[1]));\n  dst.qword[1] = ((u128)((u64)a.dword[3])) - ((u128)((u64)b.dword[3]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwod_w_h (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwod_w_h (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwod.w.h xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned signed 16-bit elements in `a` and signed elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] - (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) - ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) - ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) - ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) - ((s32)((s16)b.half[7]));\n  dst.word[4] = ((s32)((s16)a.half[9])) - ((s32)((s16)b.half[9]));\n  dst.word[5] = ((s32)((s16)a.half[11])) - ((s32)((s16)b.half[11]));\n  dst.word[6] = ((s32)((s16)a.half[13])) - ((s32)((s16)b.half[13]));\n  dst.word[7] = ((s32)((s16)a.half[15])) - ((s32)((s16)b.half[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwod_w_h (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwod.w.h xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned signed 16-bit elements in <code>a</code> and signed elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (s32)(s16)a.half[2 * i + 1] - (s32)(s16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((s32)((s16)a.half[1])) - ((s32)((s16)b.half[1]));\n  dst.word[1] = ((s32)((s16)a.half[3])) - ((s32)((s16)b.half[3]));\n  dst.word[2] = ((s32)((s16)a.half[5])) - ((s32)((s16)b.half[5]));\n  dst.word[3] = ((s32)((s16)a.half[7])) - ((s32)((s16)b.half[7]));\n  dst.word[4] = ((s32)((s16)a.half[9])) - ((s32)((s16)b.half[9]));\n  dst.word[5] = ((s32)((s16)a.half[11])) - ((s32)((s16)b.half[11]));\n  dst.word[6] = ((s32)((s16)a.half[13])) - ((s32)((s16)b.half[13]));\n  dst.word[7] = ((s32)((s16)a.half[15])) - ((s32)((s16)b.half[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvsubwod_w_hu (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvsubwod_w_hu (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvsubwod.w.hu xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nSubtract odd-positioned unsigned 16-bit elements in `a` and unsigned elements in `b`, save the 32-bit result in `dst`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] - (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) - ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) - ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) - ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) - ((u32)((u16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) - ((u32)((u16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) - ((u32)((u16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) - ((u32)((u16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) - ((u32)((u16)b.half[15]));\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 2 | 2 |\n| 3A6000 | LA664 | 2 | 2 |\n| 3C6000 | LA664 | 2 | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvsubwod_w_hu (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsubwod.w.hu xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Subtract odd-positioned unsigned 16-bit elements in <code>a</code> and unsigned elements in <code>b</code>, save the 32-bit result in <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 8; i++) {\n  dst.word[i] = (u32)(u16)a.half[2 * i + 1] - (u32)(u16)b.half[2 * i + 1];\n}\n\n// Expands to:\n\nif (0) {\n  dst.word[0] = ((u32)((u16)a.half[1])) - ((u32)((u16)b.half[1]));\n  dst.word[1] = ((u32)((u16)a.half[3])) - ((u32)((u16)b.half[3]));\n  dst.word[2] = ((u32)((u16)a.half[5])) - ((u32)((u16)b.half[5]));\n  dst.word[3] = ((u32)((u16)a.half[7])) - ((u32)((u16)b.half[7]));\n  dst.word[4] = ((u32)((u16)a.half[9])) - ((u32)((u16)b.half[9]));\n  dst.word[5] = ((u32)((u16)a.half[11])) - ((u32)((u16)b.half[11]));\n  dst.word[6] = ((u32)((u16)a.half[13])) - ((u32)((u16)b.half[13]));\n  dst.word[7] = ((u32)((u16)a.half[15])) - ((u32)((u16)b.half[15]));\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Integer Computation", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvxor_v (__m256i a, __m256i b)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvxor_v (__m256i a, __m256i b)\n#include <lasxintrin.h>\nInstruction: xvxor.v xr, xr, xr\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise XOR between elements in `a` and `b`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 4; i++) {\n  dst.dword[i] = a.dword[i] ^ b.dword[i];\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvxor_v (__m256i a, __m256i b)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvxor.v xr, xr, xr\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise XOR between elements in <code>a</code> and <code>b</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 4; i++) {\n  dst.dword[i] = a.dword[i] ^ b.dword[i];\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "__m256i __lasx_xvxori_b (__m256i a, imm0_255 imm)", "markdown": "### Synopsis\n\n```c++\n__m256i __lasx_xvxori_b (__m256i a, imm0_255 imm)\n#include <lasxintrin.h>\nInstruction: xvxori.b xr, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nCompute bitwise XOR between elements in `a` and `imm`.\n\n\n\n\n\n### Operation\n\n```c++\nfor (int i = 0; i < 32; i++) {\n  dst.byte[i] = a.byte[i] ^ imm;\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 2 |\n| 3A6000 | LA664 | 1 | 4 |\n| 3C6000 | LA664 | 1 | 4 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">__m256i __lasx_xvxori_b (__m256i a, imm0_255 imm)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvxori.b xr, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Compute bitwise XOR between elements in <code>a</code> and <code>imm</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">for (int i = 0; i &lt; 32; i++) {\n  dst.byte[i] = a.byte[i] ^ imm;\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>", "group": "Logical", "extension": "LASX", "display": true}, {"name": "int __lasx_xbnz_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbnz_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetallnez.b fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if all 8-bit elements in `a` are non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 1;\nfor (int i = 0; i < 32; i++) {\n  if (a.byte[i] == 0) {\n    dst = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbnz_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetallnez.b fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if all 8-bit elements in <code>a</code> are non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 1;\nfor (int i = 0; i &lt; 32; i++) {\n  if (a.byte[i] == 0) {\n    dst = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbnz_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbnz_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetallnez.d fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if all 64-bit elements in `a` are non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 1;\nfor (int i = 0; i < 4; i++) {\n  if (a.dword[i] == 0) {\n    dst = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbnz_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetallnez.d fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if all 64-bit elements in <code>a</code> are non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 1;\nfor (int i = 0; i &lt; 4; i++) {\n  if (a.dword[i] == 0) {\n    dst = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbnz_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbnz_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetallnez.h fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if all 16-bit elements in `a` are non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 1;\nfor (int i = 0; i < 16; i++) {\n  if (a.half[i] == 0) {\n    dst = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbnz_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetallnez.h fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if all 16-bit elements in <code>a</code> are non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 1;\nfor (int i = 0; i &lt; 16; i++) {\n  if (a.half[i] == 0) {\n    dst = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbnz_v (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbnz_v (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetnez.v fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if the whole vector `a` is non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = a.qword[0] != 0 || a.qword[1] != 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbnz_v (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetnez.v fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if the whole vector <code>a</code> is non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = a.qword[0] != 0 || a.qword[1] != 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbnz_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbnz_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetallnez.w fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if all 32-bit elements in `a` are non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 1;\nfor (int i = 0; i < 8; i++) {\n  if (a.word[i] == 0) {\n    dst = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbnz_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetallnez.w fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if all 32-bit elements in <code>a</code> are non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 1;\nfor (int i = 0; i &lt; 8; i++) {\n  if (a.word[i] == 0) {\n    dst = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbz_b (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbz_b (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetanyeqz.b fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if any 8-bit element in `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 0;\nfor (int i = 0; i < 32; i++) {\n  if (a.byte[i] == 0) {\n    dst = 1;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbz_b (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetanyeqz.b fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if any 8-bit element in <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 0;\nfor (int i = 0; i &lt; 32; i++) {\n  if (a.byte[i] == 0) {\n    dst = 1;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbz_d (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbz_d (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetanyeqz.d fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if any 64-bit element in `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 0;\nfor (int i = 0; i < 4; i++) {\n  if (a.dword[i] == 0) {\n    dst = 1;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbz_d (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetanyeqz.d fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if any 64-bit element in <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 0;\nfor (int i = 0; i &lt; 4; i++) {\n  if (a.dword[i] == 0) {\n    dst = 1;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbz_h (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbz_h (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetanyeqz.h fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if any 16-bit element in `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 0;\nfor (int i = 0; i < 16; i++) {\n  if (a.half[i] == 0) {\n    dst = 1;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbz_h (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetanyeqz.h fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if any 16-bit element in <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 0;\nfor (int i = 0; i &lt; 16; i++) {\n  if (a.half[i] == 0) {\n    dst = 1;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbz_v (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbz_v (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvseteqz.v fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if the whole vector `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = a.qword[0] == 0 && a.qword[1] == 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbz_v (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvseteqz.v fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if the whole vector <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = a.qword[0] == 0 &amp;&amp; a.qword[1] == 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xbz_w (__m256i a)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xbz_w (__m256i a)\n#include <lasxintrin.h>\nInstruction: xvsetanyeqz.w fcc, xr; bcnez\nCPU Flags: LASX\n```\n\n### Description\n\nExpected to be used in branches: branch if any 32-bit element in `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 0;\nfor (int i = 0; i < 8; i++) {\n  if (a.word[i] == 0) {\n    dst = 1;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xbz_w (__m256i a)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvsetanyeqz.w fcc, xr; bcnez\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if any 32-bit element in <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 0;\nfor (int i = 0; i &lt; 8; i++) {\n  if (a.word[i] == 0) {\n    dst = 1;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LASX", "display": true}, {"name": "int __lasx_xvpickve2gr_w (__m256i a, imm0_7 idx)", "markdown": "### Synopsis\n\n```c++\nint __lasx_xvpickve2gr_w (__m256i a, imm0_7 idx)\n#include <lasxintrin.h>\nInstruction: xvpickve2gr.w r, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (s32)a.word[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lasx_xvpickve2gr_w (__m256i a, imm0_7 idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickve2gr.w r, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (s32)a.word[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "int __lsx_bnz_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bnz_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetallnez.b fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if all 8-bit elements in `a` are non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 1;\nfor (int i = 0; i < 16; i++) {\n  if (a.byte[i] == 0) {\n    dst = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bnz_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetallnez.b fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if all 8-bit elements in <code>a</code> are non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 1;\nfor (int i = 0; i &lt; 16; i++) {\n  if (a.byte[i] == 0) {\n    dst = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bnz_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bnz_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetallnez.d fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if all 64-bit elements in `a` are non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 1;\nfor (int i = 0; i < 2; i++) {\n  if (a.dword[i] == 0) {\n    dst = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bnz_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetallnez.d fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if all 64-bit elements in <code>a</code> are non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 1;\nfor (int i = 0; i &lt; 2; i++) {\n  if (a.dword[i] == 0) {\n    dst = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bnz_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bnz_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetallnez.h fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if all 16-bit elements in `a` are non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 1;\nfor (int i = 0; i < 8; i++) {\n  if (a.half[i] == 0) {\n    dst = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bnz_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetallnez.h fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if all 16-bit elements in <code>a</code> are non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 1;\nfor (int i = 0; i &lt; 8; i++) {\n  if (a.half[i] == 0) {\n    dst = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bnz_v (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bnz_v (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetnez.v fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if the whole vector `a` is non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = a.qword[0] != 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bnz_v (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetnez.v fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if the whole vector <code>a</code> is non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = a.qword[0] != 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bnz_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bnz_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetallnez.w fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if all 32-bit elements in `a` are non-zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 1;\nfor (int i = 0; i < 4; i++) {\n  if (a.word[i] == 0) {\n    dst = 0;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bnz_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetallnez.w fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if all 32-bit elements in <code>a</code> are non-zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 1;\nfor (int i = 0; i &lt; 4; i++) {\n  if (a.word[i] == 0) {\n    dst = 0;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bz_b (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bz_b (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetanyeqz.b fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if any 8-bit element in `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 0;\nfor (int i = 0; i < 16; i++) {\n  if (a.byte[i] == 0) {\n    dst = 1;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bz_b (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetanyeqz.b fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if any 8-bit element in <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 0;\nfor (int i = 0; i &lt; 16; i++) {\n  if (a.byte[i] == 0) {\n    dst = 1;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bz_d (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bz_d (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetanyeqz.d fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if any 64-bit element in `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 0;\nfor (int i = 0; i < 2; i++) {\n  if (a.dword[i] == 0) {\n    dst = 1;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bz_d (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetanyeqz.d fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if any 64-bit element in <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 0;\nfor (int i = 0; i &lt; 2; i++) {\n  if (a.dword[i] == 0) {\n    dst = 1;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bz_h (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bz_h (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetanyeqz.h fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if any 16-bit element in `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 0;\nfor (int i = 0; i < 8; i++) {\n  if (a.half[i] == 0) {\n    dst = 1;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bz_h (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetanyeqz.h fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if any 16-bit element in <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 0;\nfor (int i = 0; i &lt; 8; i++) {\n  if (a.half[i] == 0) {\n    dst = 1;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bz_v (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bz_v (__m128i a)\n#include <lsxintrin.h>\nInstruction: vseteqz.v fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if the whole vector `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = a.qword[0] == 0;\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bz_v (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vseteqz.v fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if the whole vector <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = a.qword[0] == 0;\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_bz_w (__m128i a)", "markdown": "### Synopsis\n\n```c++\nint __lsx_bz_w (__m128i a)\n#include <lsxintrin.h>\nInstruction: vsetanyeqz.w fcc, vr; bcnez\nCPU Flags: LSX\n```\n\n### Description\n\nExpected to be used in branches: branch if any 32-bit element in `a` equals to zero.\n\n\n\n\n\n### Operation\n\n```c++\ndst = 0;\nfor (int i = 0; i < 4; i++) {\n  if (a.word[i] == 0) {\n    dst = 1;\n  }\n}\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | N/A | 2 |\n| 3A6000 | LA664 | N/A | 2 |\n| 3C6000 | LA664 | N/A | 2 |\n| 2K1000LA | LA264 | N/A | 1 |\n| 2K3000 | LA364E | N/A | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_bz_w (__m128i a)\n#include &lt;lsxintrin.h&gt;\nInstruction: vsetanyeqz.w fcc, vr; bcnez\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Expected to be used in branches: branch if any 32-bit element in <code>a</code> equals to zero.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = 0;\nfor (int i = 0; i &lt; 4; i++) {\n  if (a.word[i] == 0) {\n    dst = 1;\n  }\n}\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>N/A</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>N/A</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Branch", "extension": "LSX", "display": true}, {"name": "int __lsx_vpickve2gr_b (__m128i a, imm0_15 idx)", "markdown": "### Synopsis\n\n```c++\nint __lsx_vpickve2gr_b (__m128i a, imm0_15 idx)\n#include <lsxintrin.h>\nInstruction: vpickve2gr.b r, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (s8)a.byte[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_vpickve2gr_b (__m128i a, imm0_15 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickve2gr.b r, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (s8)a.byte[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "int __lsx_vpickve2gr_h (__m128i a, imm0_7 idx)", "markdown": "### Synopsis\n\n```c++\nint __lsx_vpickve2gr_h (__m128i a, imm0_7 idx)\n#include <lsxintrin.h>\nInstruction: vpickve2gr.h r, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (s16)a.half[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_vpickve2gr_h (__m128i a, imm0_7 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickve2gr.h r, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (s16)a.half[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "int __lsx_vpickve2gr_w (__m128i a, imm0_3 idx)", "markdown": "### Synopsis\n\n```c++\nint __lsx_vpickve2gr_w (__m128i a, imm0_3 idx)\n#include <lsxintrin.h>\nInstruction: vpickve2gr.w r, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (s32)a.word[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">int __lsx_vpickve2gr_w (__m128i a, imm0_3 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickve2gr.w r, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (s32)a.word[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "long int __lasx_xvpickve2gr_d (__m256i a, imm0_3 idx)", "markdown": "### Synopsis\n\n```c++\nlong int __lasx_xvpickve2gr_d (__m256i a, imm0_3 idx)\n#include <lasxintrin.h>\nInstruction: xvpickve2gr.d r, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (s64)a.dword[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">long int __lasx_xvpickve2gr_d (__m256i a, imm0_3 idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickve2gr.d r, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (s64)a.dword[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "long int __lsx_vpickve2gr_d (__m128i a, imm0_1 idx)", "markdown": "### Synopsis\n\n```c++\nlong int __lsx_vpickve2gr_d (__m128i a, imm0_1 idx)\n#include <lsxintrin.h>\nInstruction: vpickve2gr.d r, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (s64)a.dword[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">long int __lsx_vpickve2gr_d (__m128i a, imm0_1 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickve2gr.d r, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (s64)a.dword[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "unsigned int __lasx_xvpickve2gr_wu (__m256i a, imm0_7 idx)", "markdown": "### Synopsis\n\n```c++\nunsigned int __lasx_xvpickve2gr_wu (__m256i a, imm0_7 idx)\n#include <lasxintrin.h>\nInstruction: xvpickve2gr.wu r, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (u32)a.word[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">unsigned int __lasx_xvpickve2gr_wu (__m256i a, imm0_7 idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickve2gr.wu r, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (u32)a.word[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "unsigned int __lsx_vpickve2gr_bu (__m128i a, imm0_15 idx)", "markdown": "### Synopsis\n\n```c++\nunsigned int __lsx_vpickve2gr_bu (__m128i a, imm0_15 idx)\n#include <lsxintrin.h>\nInstruction: vpickve2gr.bu r, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (u8)a.byte[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">unsigned int __lsx_vpickve2gr_bu (__m128i a, imm0_15 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickve2gr.bu r, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (u8)a.byte[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "unsigned int __lsx_vpickve2gr_hu (__m128i a, imm0_7 idx)", "markdown": "### Synopsis\n\n```c++\nunsigned int __lsx_vpickve2gr_hu (__m128i a, imm0_7 idx)\n#include <lsxintrin.h>\nInstruction: vpickve2gr.hu r, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (u16)a.half[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">unsigned int __lsx_vpickve2gr_hu (__m128i a, imm0_7 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickve2gr.hu r, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (u16)a.half[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "unsigned int __lsx_vpickve2gr_wu (__m128i a, imm0_3 idx)", "markdown": "### Synopsis\n\n```c++\nunsigned int __lsx_vpickve2gr_wu (__m128i a, imm0_3 idx)\n#include <lsxintrin.h>\nInstruction: vpickve2gr.wu r, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (u32)a.word[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">unsigned int __lsx_vpickve2gr_wu (__m128i a, imm0_3 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickve2gr.wu r, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (u32)a.word[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "unsigned long int __lasx_xvpickve2gr_du (__m256i a, imm0_3 idx)", "markdown": "### Synopsis\n\n```c++\nunsigned long int __lasx_xvpickve2gr_du (__m256i a, imm0_3 idx)\n#include <lasxintrin.h>\nInstruction: xvpickve2gr.du r, xr, imm\nCPU Flags: LASX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (u64)a.dword[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">unsigned long int __lasx_xvpickve2gr_du (__m256i a, imm0_3 idx)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvpickve2gr.du r, xr, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (u64)a.dword[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LASX", "display": true}, {"name": "unsigned long int __lsx_vpickve2gr_du (__m128i a, imm0_1 idx)", "markdown": "### Synopsis\n\n```c++\nunsigned long int __lsx_vpickve2gr_du (__m128i a, imm0_1 idx)\n#include <lsxintrin.h>\nInstruction: vpickve2gr.du r, vr, imm\nCPU Flags: LSX\n```\n\n### Description\n\nPick the `lane` specified by `idx` from `a` and store into `dst`.\n\n\n\n\n\n### Operation\n\n```c++\ndst = (u64)a.dword[idx];\n```\n\nTested on real machine.\n\n\n### Latency and Throughput\n\n| CPU | \u00b5arch | Latency | Throughput (IPC) |\n|-----|-------|---------|------------------|\n| 3C5000 | LA464 | 1 | 1 |\n| 3A6000 | LA664 | 1 | 1 |\n| 3C6000 | LA664 | 1 | 1 |\n| 2K1000LA | LA264 | 2 | 0.5(1/2) |\n| 2K3000 | LA364E | 2 | 0.5(1/2) |", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">unsigned long int __lsx_vpickve2gr_du (__m128i a, imm0_1 idx)\n#include &lt;lsxintrin.h&gt;\nInstruction: vpickve2gr.du r, vr, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Pick the <code>lane</code> specified by <code>idx</code> from <code>a</code> and store into <code>dst</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">dst = (u64)a.dword[idx];\n</code></pre>\n\n<p>Tested on real machine.</p>\n<h3>Latency and Throughput</h3>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>\u00b5arch</th>\n<th>Latency</th>\n<th>Throughput (IPC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3C5000</td>\n<td>LA464</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3A6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3C6000</td>\n<td>LA664</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2K1000LA</td>\n<td>LA264</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n<tr>\n<td>2K3000</td>\n<td>LA364E</td>\n<td>2</td>\n<td>0.5(1/2)</td>\n</tr>\n</tbody>\n</table>", "group": "Misc", "extension": "LSX", "display": true}, {"name": "void __lasx_xvst (__m256i data, void * addr, imm_n2048_2047 offset)", "markdown": "### Synopsis\n\n```c++\nvoid __lasx_xvst (__m256i data, void * addr, imm_n2048_2047 offset)\n#include <lasxintrin.h>\nInstruction: xvst xr, r, imm\nCPU Flags: LASX\n```\n\n### Description\n\nWrite whole vector data in `data` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(256, data, addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lasx_xvst (__m256i data, void * addr, imm_n2048_2047 offset)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvst xr, r, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Write whole vector data in <code>data</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(256, data, addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "void __lasx_xvstelm_b (__m256i data, void * addr, imm_n128_127 offset, imm0_31 lane)", "markdown": "### Synopsis\n\n```c++\nvoid __lasx_xvstelm_b (__m256i data, void * addr, imm_n128_127 offset, imm0_31 lane)\n#include <lasxintrin.h>\nInstruction: xvstelm.b xr, r, imm, imm\nCPU Flags: LASX\n```\n\n### Description\n\nStore the 8-bit element in `data` specified by `lane` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(8, data.byte[lane], addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lasx_xvstelm_b (__m256i data, void * addr, imm_n128_127 offset, imm0_31 lane)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvstelm.b xr, r, imm, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Store the 8-bit element in <code>data</code> specified by <code>lane</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(8, data.byte[lane], addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "void __lasx_xvstelm_d (__m256i data, void * addr, imm_n128_127 offset, imm0_3 lane)", "markdown": "### Synopsis\n\n```c++\nvoid __lasx_xvstelm_d (__m256i data, void * addr, imm_n128_127 offset, imm0_3 lane)\n#include <lasxintrin.h>\nInstruction: xvstelm.d xr, r, imm, imm\nCPU Flags: LASX\n```\n\n### Description\n\nStore the 64-bit element in `data` specified by `lane` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(64, data.dword[lane], addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lasx_xvstelm_d (__m256i data, void * addr, imm_n128_127 offset, imm0_3 lane)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvstelm.d xr, r, imm, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Store the 64-bit element in <code>data</code> specified by <code>lane</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(64, data.dword[lane], addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "void __lasx_xvstelm_h (__m256i data, void * addr, imm_n128_127 offset, imm0_15 lane)", "markdown": "### Synopsis\n\n```c++\nvoid __lasx_xvstelm_h (__m256i data, void * addr, imm_n128_127 offset, imm0_15 lane)\n#include <lasxintrin.h>\nInstruction: xvstelm.h xr, r, imm, imm\nCPU Flags: LASX\n```\n\n### Description\n\nStore the 16-bit element in `data` specified by `lane` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(16, data.half[lane], addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lasx_xvstelm_h (__m256i data, void * addr, imm_n128_127 offset, imm0_15 lane)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvstelm.h xr, r, imm, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Store the 16-bit element in <code>data</code> specified by <code>lane</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(16, data.half[lane], addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "void __lasx_xvstelm_w (__m256i data, void * addr, imm_n128_127 offset, imm0_7 lane)", "markdown": "### Synopsis\n\n```c++\nvoid __lasx_xvstelm_w (__m256i data, void * addr, imm_n128_127 offset, imm0_7 lane)\n#include <lasxintrin.h>\nInstruction: xvstelm.w xr, r, imm, imm\nCPU Flags: LASX\n```\n\n### Description\n\nStore the 32-bit element in `data` specified by `lane` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(32, data.word[lane], addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lasx_xvstelm_w (__m256i data, void * addr, imm_n128_127 offset, imm0_7 lane)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvstelm.w xr, r, imm, imm\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Store the 32-bit element in <code>data</code> specified by <code>lane</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(32, data.word[lane], addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "void __lasx_xvstx (__m256i data, void * addr, long int offset)", "markdown": "### Synopsis\n\n```c++\nvoid __lasx_xvstx (__m256i data, void * addr, long int offset)\n#include <lasxintrin.h>\nInstruction: xvstx xr, r, r\nCPU Flags: LASX\n```\n\n### Description\n\nWrite whole-vector data in `data` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(256, data, addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lasx_xvstx (__m256i data, void * addr, long int offset)\n#include &lt;lasxintrin.h&gt;\nInstruction: xvstx xr, r, r\nCPU Flags: LASX\n</code></pre>\n\n<h3>Description</h3>\n<p>Write whole-vector data in <code>data</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(256, data, addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LASX", "display": true}, {"name": "void __lsx_vst (__m128i data, void * addr, imm_n2048_2047 offset)", "markdown": "### Synopsis\n\n```c++\nvoid __lsx_vst (__m128i data, void * addr, imm_n2048_2047 offset)\n#include <lsxintrin.h>\nInstruction: vst vr, r, imm\nCPU Flags: LSX\n```\n\n### Description\n\nWrite whole vector data in `data` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(128, data, addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lsx_vst (__m128i data, void * addr, imm_n2048_2047 offset)\n#include &lt;lsxintrin.h&gt;\nInstruction: vst vr, r, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Write whole vector data in <code>data</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(128, data, addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "void __lsx_vstelm_b (__m128i data, void * addr, imm_n128_127 offset, imm0_15 lane)", "markdown": "### Synopsis\n\n```c++\nvoid __lsx_vstelm_b (__m128i data, void * addr, imm_n128_127 offset, imm0_15 lane)\n#include <lsxintrin.h>\nInstruction: vstelm.b vr, r, imm, imm\nCPU Flags: LSX\n```\n\n### Description\n\nStore the 8-bit element in `data` specified by `lane` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(8, data.byte[lane], addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lsx_vstelm_b (__m128i data, void * addr, imm_n128_127 offset, imm0_15 lane)\n#include &lt;lsxintrin.h&gt;\nInstruction: vstelm.b vr, r, imm, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Store the 8-bit element in <code>data</code> specified by <code>lane</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(8, data.byte[lane], addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "void __lsx_vstelm_d (__m128i data, void * addr, imm_n128_127 offset, imm0_1 lane)", "markdown": "### Synopsis\n\n```c++\nvoid __lsx_vstelm_d (__m128i data, void * addr, imm_n128_127 offset, imm0_1 lane)\n#include <lsxintrin.h>\nInstruction: vstelm.d vr, r, imm, imm\nCPU Flags: LSX\n```\n\n### Description\n\nStore the 64-bit element in `data` specified by `lane` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(64, data.dword[lane], addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lsx_vstelm_d (__m128i data, void * addr, imm_n128_127 offset, imm0_1 lane)\n#include &lt;lsxintrin.h&gt;\nInstruction: vstelm.d vr, r, imm, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Store the 64-bit element in <code>data</code> specified by <code>lane</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(64, data.dword[lane], addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "void __lsx_vstelm_h (__m128i data, void * addr, imm_n128_127 offset, imm0_7 lane)", "markdown": "### Synopsis\n\n```c++\nvoid __lsx_vstelm_h (__m128i data, void * addr, imm_n128_127 offset, imm0_7 lane)\n#include <lsxintrin.h>\nInstruction: vstelm.h vr, r, imm, imm\nCPU Flags: LSX\n```\n\n### Description\n\nStore the 16-bit element in `data` specified by `lane` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(16, data.half[lane], addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lsx_vstelm_h (__m128i data, void * addr, imm_n128_127 offset, imm0_7 lane)\n#include &lt;lsxintrin.h&gt;\nInstruction: vstelm.h vr, r, imm, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Store the 16-bit element in <code>data</code> specified by <code>lane</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(16, data.half[lane], addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "void __lsx_vstelm_w (__m128i data, void * addr, imm_n128_127 offset, imm0_3 lane)", "markdown": "### Synopsis\n\n```c++\nvoid __lsx_vstelm_w (__m128i data, void * addr, imm_n128_127 offset, imm0_3 lane)\n#include <lsxintrin.h>\nInstruction: vstelm.w vr, r, imm, imm\nCPU Flags: LSX\n```\n\n### Description\n\nStore the 32-bit element in `data` specified by `lane` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(32, data.word[lane], addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lsx_vstelm_w (__m128i data, void * addr, imm_n128_127 offset, imm0_3 lane)\n#include &lt;lsxintrin.h&gt;\nInstruction: vstelm.w vr, r, imm, imm\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Store the 32-bit element in <code>data</code> specified by <code>lane</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(32, data.word[lane], addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}, {"name": "void __lsx_vstx (__m128i data, void * addr, long int offset)", "markdown": "### Synopsis\n\n```c++\nvoid __lsx_vstx (__m128i data, void * addr, long int offset)\n#include <lsxintrin.h>\nInstruction: vstx vr, r, r\nCPU Flags: LSX\n```\n\n### Description\n\nWrite whole-vector data in `data` to memory address `addr + offset`.\n\n\n\n\n\n### Operation\n\n```c++\nmemory_store(128, data, addr + offset);\n```", "content": "<h3>Synopsis</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">void __lsx_vstx (__m128i data, void * addr, long int offset)\n#include &lt;lsxintrin.h&gt;\nInstruction: vstx vr, r, r\nCPU Flags: LSX\n</code></pre>\n\n<h3>Description</h3>\n<p>Write whole-vector data in <code>data</code> to memory address <code>addr + offset</code>.</p>\n<h3>Operation</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">memory_store(128, data, addr + offset);\n</code></pre>", "group": "Memory Load & Store", "extension": "LSX", "display": true}] ;

  let miniSearch = new MiniSearch({
    fields: ['name', 'markdown', 'group', 'extension'],
    storeFields: ['group', 'extension']
  });

  let docs = [];
  for (let i = 0;i < allIntrinsics.length;i++) {
    docs.push({
      id: i,
      ...allIntrinsics[i],
    });
  }
  miniSearch.addAll(docs);

  createApp({
    setup() {
      const urlParams = new URLSearchParams(window.location.search);
      let initialSearch = urlParams.get('q');
      if (initialSearch === null) {
        initialSearch = "";
      }
      const search = ref(initialSearch);

      const allGroups =  ["Bitwise Operations", "Branch", "Floating Point Comparison", "Floating Point Computation", "Floating Point Conversion", "Floating Point Misc", "Fused Multiply-Add", "Integer Comparison", "Integer Computation", "Logical", "Memory Load & Store", "Misc", "Permutation", "Shift", "Shuffling", "Undocumented Intrinsics"] ;
      const allExtensions = ["LSX", "LASX"];
      const groups = ref(allGroups);
      const extensions = ref(allExtensions);

      const intrinsics = computed(() => {
        // update search to url
        // https://stackoverflow.com/questions/10970078/modifying-a-query-string-without-reloading-the-page
        const url = window.location.href;
        var r = new URL(url);
        r.searchParams.set('q', search.value);
        window.history.pushState({ path: r.href }, '', r.href);

        let length = 0;
        if (search.value === "") {
          for (let val of allIntrinsics) {
            if (!groups.value.includes(val.group)) {
              val.display = false;
            } else if (!extensions.value.includes(val.extension)) {
              val.display = false;
            } else {
              val.display = true;
              length = length + 1;
            }
          }
        } else {
          for (let val of allIntrinsics) {
            val.display = false;
          }

          let candidates = miniSearch.search(search.value, {
            prefix: true,
            fuzzy: 0.2,
            combineWith: 'AND'
          });
          for (let val of candidates) {
            if (!groups.value.includes(val.group)) {
              continue;
            } else if (!extensions.value.includes(val.extension)) {
              continue;
            }
            allIntrinsics[val.id].display = true;
            length = length + 1;
          }
        }

        return {
          inner: allIntrinsics,
          length: length,
        };
      });

      return {
        intrinsics,
        search,
        groups,
        allGroups,
        extensions,
        allExtensions
      }
    }
  }).mount('#app')
</script>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../migrating_sse/" class="btn btn-neutral float-left" title="Migrating from SSE to LSX"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../lasx/bitwise_operations/" class="btn btn-neutral float-right" title="Bitwise Operations">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright &copy; 2023-2025 Jiajie Chen</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../migrating_sse/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../lasx/bitwise_operations/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
</script></body>
</html>
